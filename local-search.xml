<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>常用正则</title>
    <link href="/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99/"/>
    <url>/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99/</url>
    
    <content type="html"><![CDATA[<p>学了一些正则之后再去处理数据，感觉天都亮了，但是唯一缺点就是太难记了，趁此机会，记录一下常用的一些正则表达式。</p><h4 id="1-多关键字匹配"><a href="#1-多关键字匹配" class="headerlink" title="1. 多关键字匹配"></a>1. 多关键字匹配</h4><p>使用场景：我有如下字符串集合，我想找到其中包含<code>你</code>或<code>我</code>或<code>他</code>的字符串。<br>使用语法：<code>你|我|他</code></p><div class="code-wrapper"><pre><code class="hljs">你好，我是小明。你好，我是小红。你好，我是小黄。他是谁。有一只小狗。</code></pre></div><h4 id="2-首尾匹配"><a href="#2-首尾匹配" class="headerlink" title="2. 首尾匹配"></a>2. 首尾匹配</h4><p>使用场景1: 我想找到以<code>你</code>开头的字符串。<br>使用语法：<code>^你</code></p><p>使用场景2: 我想找到以<code>你</code>结尾的字符串。<br>使用语法：<code>你$</code></p><p>使用场景3: 我想找到以<code>你</code>开头且以<code>我</code>结尾的字符串。<br>使用语法：<code>^你我$</code></p><p>使用场景4: 我想用<code>你</code>全字匹配<br>使用语法：<code>^你$</code> 或者 <code>\b你\b</code></p><h4 id="3-更精确的模糊匹配"><a href="#3-更精确的模糊匹配" class="headerlink" title="3. 更精确的模糊匹配"></a>3. 更精确的模糊匹配</h4><p>使用场景：我记得我的狗的名字是小什么，但我不记得后面那个字，只记得它叫小黄或者小红或者小蓝<br>使用语法：<code>小[红黄蓝]</code></p><p>同样的，我也可以把这个放到前面来。<br>使用场景：我有个老同学，它叫什么凯，也许是李凯、王凯或者陈凯。<br>使用语法：<code>[李王陈]凯</code></p><h4 id="4-匹配数字"><a href="#4-匹配数字" class="headerlink" title="4. 匹配数字"></a>4. 匹配数字</h4><p>使用场景1：我想找到一个字符串中包含数字的字符串。<br>使用语法：<code>\d</code></p><p>使用场景2：我想找到一个字符串中不包含数字的字符串。<br>使用语法：<code>\D</code></p><p>使用场景3：我想找到一个字符串中包含数字的字符串，并且数字是连续的。<br>使用语法：<code>\d+</code></p><p>使用场景4：我想找到一个字符串中包含数字的字符串，并且数字是连续的，并且数字是3位。<br>使用语法：<code>\d&#123;3&#125;</code></p><p>使用场景5：我想模糊的查找所有2-7的数字。<br>使用语法：<code>[2-7]</code></p><p>使用场景6：我想模糊的查找所有2-7的数字，并且是连续的。<br>使用语法：<code>[2-7]+</code></p><p>使用场景7：我想模糊的查找所有2-7的数字，并且是连续的，并且是3位。<br>使用语法：<code>[2-7]&#123;3&#125;</code></p><h4 id="5-匹配字母"><a href="#5-匹配字母" class="headerlink" title="5. 匹配字母"></a>5. 匹配字母</h4><p>使用场景1：我想找到一个字符串中包含字母的字符串。<br>使用语法：<code>\w</code></p><p>使用场景2：我想找到一个字符串中不包含字母的字符串。<br>使用语法：<code>\W</code></p><p>使用场景3：我想找到一个字符串中包含字母的字符串，并且字母是连续的。<br>使用语法：<code>\w+</code></p><p>使用场景4：我想找到一个字符串中包含字母的字符串，并且字母是连续的，并且字母是3位。<br>使用语法：<code>\w&#123;3&#125;</code></p><p>使用场景5：我想模糊的查找所有字母。<br>使用语法：<code>[a-zA-Z]</code></p><p>使用场景6：我想模糊的查找所有小写字母。<br>使用语法：<code>[a-z]</code></p><p>使用场景7：我想模糊的查找所有大写字母。<br>使用语法：<code>[A-Z]</code></p><p>使用场景8：我想模糊的查找所有字母，并且是连续的。<br>使用语法：<code>[a-zA-Z]+</code></p><p>使用场景9：我想模糊的查找所有字母，并且是连续的，并且是3位。<br>使用语法：<code>[a-zA-Z]&#123;3&#125;</code></p><blockquote><p>看到这里，很多同学可能会想，既然数字和字母都可以使用范围进行匹配，那么中文也可以吗？<br>答案是可以的，但是需要使用Unicode编码。<br>[\u4E00-\u9FFF]       # 基本汉字<br>[\u4E00-\u9FFF\u3400-\u4DBF]  # 基本汉字 + 扩展A区<br>[\u4E00-\u9FFF\u3400-\u4DBF\u20000-\u2A6DF]  # 基本汉字 + 扩展A&#x2F;B&#x2F;C区等</p><p>对于我个人来说，确实是有点难记，有能力的同学可以发掘一下，我们这里简单介绍几个</p></blockquote><h4 id="6-匹配汉字"><a href="#6-匹配汉字" class="headerlink" title="6. 匹配汉字"></a>6. 匹配汉字</h4><p>使用场景1：我想找到一个字符串中包含汉字的字符串。<br>使用语法：<code>\p&#123;Han&#125;</code></p><p>使用场景2：我想找到一个字符串中不包含汉字的字符串。<br>使用语法：<code>\P&#123;Han&#125;</code></p><p>使用场景3：我想找到一个字符串中包含汉字的字符串，并且汉字是连续的。<br>使用语法：<code>\p&#123;Han&#125;+</code></p><p>使用场景4：我想找到一个字符串中包含汉字的字符串，并且汉字是连续的，并且汉字是3位。<br>使用语法：<code>\p&#123;Han&#125;&#123;3&#125;</code></p><p>使用场景5：我想模糊的查找所有汉字。<br>使用语法：<code>[\u4E00-\u9FFF]</code></p><p>使用场景6：我想模糊的查找所有汉字，并且是连续的。<br>使用语法：<code>[\u4E00-\u9FFF]+</code></p><p>使用场景7：我想模糊的查找所有汉字，并且是连续的，并且是3位。<br>使用语法：<code>[\u4E00-\u9FFF]&#123;3&#125;</code></p><p>目前工作中用到最多的就是这些，后面有新的常用正则还会补充。</p>]]></content>
    
    
    
    <tags>
      
      <tag>开发手册</tag>
      
      <tag>效率</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单元测试</title>
    <link href="/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <url>/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>最近在研究如何规范编码，那么单元测试当然是其中必不可少的一部分。记录一下学习过程，方便自己，希望你有需要的时候也能帮到你。</p><h4 id="一些规定"><a href="#一些规定" class="headerlink" title="一些规定"></a>一些规定</h4><p>单元测试有一些强制性的规定，也有一些约定俗成的习惯。<br>强制性的有</p><ul><li>测试文件必须以<code>_test.go</code>结尾，例如<code>string_test.go</code>。</li><li>测试文件中，每个测试函数须以<code>Test</code>开头。</li><li>单元测试的测试函数必须接收<code>*testing.T</code>类型的参数。</li></ul><p>习惯性的有</p><ul><li><p>测试文件一般放在被测文件的后面（习惯因人而异，你也可以在每个包下单独建一个test包用来专门存放测试文件）</p></li><li><p>测试函数中包含被测函数的名字，比如我们有个函数名为<code>func ABC()&#123;&#125;</code>，那么测试函数最好命名为<code>func TestABC(t *testing.T)&#123;&#125;</code>。</p></li></ul><p>​</p><p>综上，我们最好保持如下的项目结构。</p><div class="code-wrapper"><pre><code class="hljs shell">Blog├── util│   ├── string.go # 被测文件│   ├── string_test.go # 测试文件│   ├── float.go│   └── float_test.go├── go.mod└── go.sum</code></pre></div><blockquote><p>为什么要这样设计？</p><ul><li>测试文件与被测文件相邻，方便快速定位。</li><li>使用<code>_test.go</code>后缀是Go的强制要求。</li><li>每个功能模块独立测试，避免混乱。</li></ul></blockquote><p>如上面，我们有个<code>util</code>包，其中放着一些处理各类数据结构的公共方法，每一个文件都配套一个对应的测试文件。我们这里拿<code>string.go</code>和<code>string_test.go</code>来举例。比如我的<code>string.go</code>文件中有一个用于进行大写化(把所有字符串变为大写)的函数。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ToUpperCase</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span><span class="hljs-type">string</span>&#123;    <span class="hljs-keyword">return</span> strings.ToUpper(s)&#125;</code></pre></div><p>那么我们的<code>string_test.go</code>文件中需要有一个对应的测试函数。单元测试的函数有一个规定，需要以<code>Test</code>开头，比如</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestToUpperCase</span><span class="hljs-params">(t *testing.T)</span></span> &#123; <span class="hljs-comment">// 单元测试的参数是  *testing.T</span><span class="hljs-comment">// 准备测试用例</span>testData := []<span class="hljs-keyword">struct</span> &#123;name  <span class="hljs-type">string</span>input <span class="hljs-type">string</span>want  <span class="hljs-type">string</span>&#125;&#123;&#123;<span class="hljs-string">&quot;英文小写转大写&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;HELLO&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;中文不变&quot;</span>, <span class="hljs-string">&quot;你好&quot;</span>, <span class="hljs-string">&quot;你好&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;空字符串&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;带特殊符号&quot;</span>, <span class="hljs-string">&quot;a!b@c#&quot;</span>, <span class="hljs-string">&quot;A!B@C#&quot;</span>&#125;,&#125;<span class="hljs-comment">// 逐个检查</span><span class="hljs-keyword">for</span> _, td := <span class="hljs-keyword">range</span> testData &#123;t.Run(td.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;got := ToUpperCase(td.input)<span class="hljs-keyword">if</span> got != td.want &#123;t.Errorf(<span class="hljs-string">&quot;输入 %q 时出错, 得到 %q, 期望 %q&quot;</span>, td.input, got, td.want)&#125;&#125;)&#125;&#125;</code></pre></div><p>可以看到我们把测试用例放在结构体数组中，这种方式叫做<strong>表格驱动测试</strong>，好处是：</p><ul><li>可以轻松添加新的测试场景</li><li>代码更简洁</li><li>测试更全面</li></ul><h4 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h4><p>那么这个时候问题来了，我们该如何运行这个单元测试呢？有这样一行命令。</p><p><code>go test -v blog/util/ -run=TestTpUpperCase -count=1</code></p><p>很多参数，先不管，我们先运行。</p><div class="code-wrapper"><pre><code class="hljs shell">➜  Blog-demo go test -v blog/util/ -run=ToUpperCase -count=1=== RUN   TestToUpperCase=== RUN   TestToUpperCase/英文小写转大写hello=== RUN   TestToUpperCase/中文不变你好=== RUN   TestToUpperCase/空字符串=== RUN   TestToUpperCase/带特殊符号a!b@c#--- PASS: TestToUpperCase (0.00s)    --- PASS: TestToUpperCase/英文小写转大写 (0.00s)    --- PASS: TestToUpperCase/中文不变 (0.00s)    --- PASS: TestToUpperCase/空字符串 (0.00s)    --- PASS: TestToUpperCase/带特殊符号 (0.00s)PASSok      blog/util       0.215s</code></pre></div><p>可以看到，我们的四个测试用例依次进行，并且都通过了测试。下面我们来看一下这些参数都代表什么。</p><h5 id="v"><a href="#v" class="headerlink" title="-v"></a>-v</h5><p><code>-v</code>参数代表详细输出，你可能在<code>git</code>中用过它，比如<code>git remote -v</code>等。如果你细心的话，你会发现，每个测试用例都给我们打印了详细的测试信息。如果我们去掉<code>-v</code>参数，那么运行测试时，则不会输出这些内容。测试结果如下：</p><div class="code-wrapper"><pre><code class="hljs shell">➜  Blog-demo go test  blog/util/ -run=ToUpperCase -count=1 ok      blog/util       0.450s</code></pre></div><p>我想到这里你应该会明白<code>-v</code>参数的作用了。</p><h5 id="run-ToUpperCase"><a href="#run-ToUpperCase" class="headerlink" title="-run&#x3D;ToUpperCase"></a>-run&#x3D;ToUpperCase</h5><p>在理解<code>blog/util</code>之前，我们需要先知道<code>-run</code>参数。其实<code>-run</code>参数就是以正则的方式匹配需要进行测试的函数。例如现在，<code>-run=ToUpperCase</code>就意味着启动测试时，go会运行**范围内（后面会说什么范围）**所有名字中有<code>ToUpperCase</code>的测试函数。如果我新建一个测试函数，只是在原来的基础上名字加一个<code>2</code>,如下：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> util<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;testing&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestToUpperCase</span><span class="hljs-params">(t *testing.T)</span></span> &#123; <span class="hljs-comment">// 单元测试的参数是  *testing.T</span><span class="hljs-comment">// 准备测试用例</span>testData := []<span class="hljs-keyword">struct</span> &#123;name  <span class="hljs-type">string</span>input <span class="hljs-type">string</span>want  <span class="hljs-type">string</span>&#125;&#123;&#123;<span class="hljs-string">&quot;英文小写转大写&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;HELLO&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;中文不变&quot;</span>, <span class="hljs-string">&quot;你好&quot;</span>, <span class="hljs-string">&quot;你好&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;空字符串&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;带特殊符号&quot;</span>, <span class="hljs-string">&quot;a!b@c#&quot;</span>, <span class="hljs-string">&quot;A!B@C#&quot;</span>&#125;,&#125;<span class="hljs-comment">// 逐个检查</span><span class="hljs-keyword">for</span> _, td := <span class="hljs-keyword">range</span> testData &#123;t.Run(td.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;got := ToUpperCase(td.input)<span class="hljs-keyword">if</span> got != td.want &#123;t.Errorf(<span class="hljs-string">&quot;输入 %q 时出错, 得到 %q, 期望 %q&quot;</span>, td.input, got, td.want)&#125;&#125;)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestToUpperCase2</span><span class="hljs-params">(t *testing.T)</span></span> &#123; <span class="hljs-comment">// 单元测试的参数是  *testing.T</span><span class="hljs-comment">// 准备测试用例</span>testData := []<span class="hljs-keyword">struct</span> &#123;name  <span class="hljs-type">string</span>input <span class="hljs-type">string</span>want  <span class="hljs-type">string</span>&#125;&#123;&#123;<span class="hljs-string">&quot;英文小写转大写&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;HELLO&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;中文不变&quot;</span>, <span class="hljs-string">&quot;你好&quot;</span>, <span class="hljs-string">&quot;你好&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;空字符串&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;带特殊符号&quot;</span>, <span class="hljs-string">&quot;a!b@c#&quot;</span>, <span class="hljs-string">&quot;A!B@C#&quot;</span>&#125;,&#125;<span class="hljs-comment">// 逐个检查</span><span class="hljs-keyword">for</span> _, td := <span class="hljs-keyword">range</span> testData &#123;t.Run(td.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;got := ToUpperCase(td.input)<span class="hljs-keyword">if</span> got != td.want &#123;t.Errorf(<span class="hljs-string">&quot;输入 %q 时出错, 得到 %q, 期望 %q&quot;</span>, td.input, got, td.want)&#125;&#125;)&#125;&#125;</code></pre></div><p>这个时候我运行同样的命令，猜猜会发生什么？</p><div class="code-wrapper"><pre><code class="hljs shell">➜  Blog-demo go test -v blog/util/ -run=ToUpperCase -count=1=== RUN   TestToUpperCase=== RUN   TestToUpperCase/英文小写转大写hello=== RUN   TestToUpperCase/中文不变你好=== RUN   TestToUpperCase/空字符串=== RUN   TestToUpperCase/带特殊符号a!b@c#--- PASS: TestToUpperCase (0.00s)    --- PASS: TestToUpperCase/英文小写转大写 (0.00s)    --- PASS: TestToUpperCase/中文不变 (0.00s)    --- PASS: TestToUpperCase/空字符串 (0.00s)    --- PASS: TestToUpperCase/带特殊符号 (0.00s)=== RUN   TestToUpperCase2=== RUN   TestToUpperCase2/英文小写转大写hello=== RUN   TestToUpperCase2/中文不变你好=== RUN   TestToUpperCase2/空字符串=== RUN   TestToUpperCase2/带特殊符号a!b@c#--- PASS: TestToUpperCase2 (0.00s)    --- PASS: TestToUpperCase2/英文小写转大写 (0.00s)    --- PASS: TestToUpperCase2/中文不变 (0.00s)    --- PASS: TestToUpperCase2/空字符串 (0.00s)    --- PASS: TestToUpperCase2/带特殊符号 (0.00s)PASSok      blog/util       0.440s</code></pre></div><p>没错，如你所料，包含<code>TestToUpperCase</code>的两个测试函数都会启动。当然，他们的结果完全一样。</p><h5 id="blog-util"><a href="#blog-util" class="headerlink" title="blog&#x2F;util"></a>blog&#x2F;util</h5><blockquote><p><code>-run=ToUpperCase</code>就意味着启动测试时，go会运行**范围内（后面会说什么范围）**所有名字中有<code>ToUpperCase</code>的测试函数</p></blockquote><p>我们前面留了一个问题，就是所谓的范围到底是什么？这部分参数就是用来规定范围。不难理解，指的是在哪个文件夹下运行测试。当我带着<code>blog/util</code>这个参数运行测试时，go的测试程序会检索<code>blog/util</code>文件夹下的所有符合条件的测试函数。为了更好的理解，我在<code>float64.go</code>中新建一个函数。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> util<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-comment">// 将浮点数转为字符串(暂不考虑精度问题，只是用于单元测试的展示用例)</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Float64ToString</span><span class="hljs-params">(f <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%g&quot;</span>, f)&#125;</code></pre></div><p>同时，在<code>float64_test.go</code>中创建对应的测试函数。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> util<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;testing&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestFloat64ToString</span><span class="hljs-params">(t *testing.T)</span></span> &#123;testData := []<span class="hljs-keyword">struct</span> &#123;name   <span class="hljs-type">string</span>input  <span class="hljs-type">float64</span>output <span class="hljs-type">string</span>&#125;&#123;&#123;name:   <span class="hljs-string">&quot;zero&quot;</span>,input:  <span class="hljs-number">0</span>,output: <span class="hljs-string">&quot;0&quot;</span>,&#125;,&#123;name:   <span class="hljs-string">&quot;one&quot;</span>,input:  <span class="hljs-number">1</span>,output: <span class="hljs-string">&quot;1&quot;</span>,&#125;,&#123;name:   <span class="hljs-string">&quot;minus one&quot;</span>,input:  <span class="hljs-number">-1</span>,output: <span class="hljs-string">&quot;-1&quot;</span>,&#125;,&#123;name:   <span class="hljs-string">&quot;float&quot;</span>,input:  <span class="hljs-number">0.1</span>,output: <span class="hljs-string">&quot;0.1&quot;</span>,&#125;,&#125;<span class="hljs-keyword">for</span> _, td := <span class="hljs-keyword">range</span> testData &#123;t.Run(td.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-keyword">if</span> output := Float64ToString(td.input); output != td.output &#123;t.Errorf(<span class="hljs-string">&quot;expected %s, got %s&quot;</span>, td.output, output)&#125;&#125;)&#125;&#125;</code></pre></div><p>现在我运行如下命令，</p><div class="code-wrapper"><pre><code class="hljs shell">go test -v blog/util -count=1</code></pre></div><p>注意这里我没有使用<code>-run</code>参数，也就是全匹配。结果如下</p><div class="code-wrapper"><pre><code class="hljs shell">➜  util go test -v blog/util -count=1=== RUN   TestFloat64ToString=== RUN   TestFloat64ToString/zero=== RUN   TestFloat64ToString/one=== RUN   TestFloat64ToString/minus_one=== RUN   TestFloat64ToString/float--- PASS: TestFloat64ToString (0.00s)    --- PASS: TestFloat64ToString/zero (0.00s)    --- PASS: TestFloat64ToString/one (0.00s)    --- PASS: TestFloat64ToString/minus_one (0.00s)    --- PASS: TestFloat64ToString/float (0.00s)=== RUN   TestToUpperCase=== RUN   TestToUpperCase/英文小写转大写hello=== RUN   TestToUpperCase/中文不变你好=== RUN   TestToUpperCase/空字符串=== RUN   TestToUpperCase/带特殊符号a!b@c#--- PASS: TestToUpperCase (0.00s)    --- PASS: TestToUpperCase/英文小写转大写 (0.00s)    --- PASS: TestToUpperCase/中文不变 (0.00s)    --- PASS: TestToUpperCase/空字符串 (0.00s)    --- PASS: TestToUpperCase/带特殊符号 (0.00s)=== RUN   TestToUpperCase2=== RUN   TestToUpperCase2/英文小写转大写hello=== RUN   TestToUpperCase2/中文不变你好=== RUN   TestToUpperCase2/空字符串=== RUN   TestToUpperCase2/带特殊符号a!b@c#--- PASS: TestToUpperCase2 (0.00s)    --- PASS: TestToUpperCase2/英文小写转大写 (0.00s)    --- PASS: TestToUpperCase2/中文不变 (0.00s)    --- PASS: TestToUpperCase2/空字符串 (0.00s)    --- PASS: TestToUpperCase2/带特殊符号 (0.00s)PASSok      blog/util       0.540s</code></pre></div><p>正如我们所预期的，两个文件中的所有测试函数都运行了。那么当我在这个文件夹外创建一个测试函数呢？我新建一个<code>config</code>文件夹，并在其中新建一个文件<code>config.go</code>，其中包含一个初始化函数。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> config<span class="hljs-keyword">type</span> Config <span class="hljs-keyword">struct</span> &#123;Name <span class="hljs-type">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitConfig</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> *Config &#123;<span class="hljs-keyword">return</span> &amp;Config&#123;Name: name,&#125;&#125;</code></pre></div><p>当然会包含一个配套的单元测试文件<code>config_test.go</code>，其中有一个单元测试文件。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> config<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;testing&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestInitConfig</span><span class="hljs-params">(t *testing.T)</span></span> &#123;testData := []<span class="hljs-keyword">struct</span> &#123;name <span class="hljs-type">string</span>want <span class="hljs-type">string</span>&#125;&#123;&#123;name: <span class="hljs-string">&quot;test&quot;</span>,want: <span class="hljs-string">&quot;test&quot;</span>,&#125;,&#123;name: <span class="hljs-string">&quot;test2&quot;</span>,want: <span class="hljs-string">&quot;test2&quot;</span>,&#125;,&#123;name: <span class="hljs-string">&quot;test3&quot;</span>,want: <span class="hljs-string">&quot;test3&quot;</span>,&#125;,&#125;<span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> testData &#123;t.Run(tt.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-keyword">if</span> got := InitConfig(tt.name); got.Name != tt.want &#123;t.Errorf(<span class="hljs-string">&quot;InitConfig() = %v, want %v&quot;</span>, got, tt.want)&#125;&#125;)&#125;&#125;</code></pre></div><p>现在我的文件目录变成了下面这样。</p><div class="code-wrapper"><pre><code class="hljs maxima">Blog├── config│   ├── config.<span class="hljs-built_in">go</span>│   └── config_test.<span class="hljs-built_in">go</span>├── util│   ├── <span class="hljs-built_in">string</span>.<span class="hljs-built_in">go</span>│   ├── string_test.<span class="hljs-built_in">go</span>│   ├── <span class="hljs-built_in">float</span>.<span class="hljs-built_in">go</span>│   └── float_test.<span class="hljs-built_in">go</span>├── <span class="hljs-built_in">go</span>.<span class="hljs-built_in">mod</span>└── <span class="hljs-built_in">go</span>.<span class="hljs-built_in">sum</span></code></pre></div><p>这个时候如果我再运行上面的命令，你会发现<code>config_test.go</code>中的测试正如我们所料，没有运行。</p><div class="code-wrapper"><pre><code class="hljs go">➜  config <span class="hljs-keyword">go</span> test -v blog/util/ -count=<span class="hljs-number">1</span>=== RUN   TestFloat64ToString=== RUN   TestFloat64ToString/zero=== RUN   TestFloat64ToString/one=== RUN   TestFloat64ToString/minus_one=== RUN   TestFloat64ToString/float--- PASS: TestFloat64ToString (<span class="hljs-number">0.00</span>s)    --- PASS: TestFloat64ToString/zero (<span class="hljs-number">0.00</span>s)    --- PASS: TestFloat64ToString/one (<span class="hljs-number">0.00</span>s)    --- PASS: TestFloat64ToString/minus_one (<span class="hljs-number">0.00</span>s)    --- PASS: TestFloat64ToString/float (<span class="hljs-number">0.00</span>s)=== RUN   TestToUpperCase=== RUN   TestToUpperCase/英文小写转大写hello=== RUN   TestToUpperCase/中文不变你好=== RUN   TestToUpperCase/空字符串=== RUN   TestToUpperCase/带特殊符号a!b@c#--- PASS: TestToUpperCase (<span class="hljs-number">0.00</span>s)    --- PASS: TestToUpperCase/英文小写转大写 (<span class="hljs-number">0.00</span>s)    --- PASS: TestToUpperCase/中文不变 (<span class="hljs-number">0.00</span>s)    --- PASS: TestToUpperCase/空字符串 (<span class="hljs-number">0.00</span>s)    --- PASS: TestToUpperCase/带特殊符号 (<span class="hljs-number">0.00</span>s)=== RUN   TestToUpperCase2=== RUN   TestToUpperCase2/英文小写转大写hello=== RUN   TestToUpperCase2/中文不变你好=== RUN   TestToUpperCase2/空字符串=== RUN   TestToUpperCase2/带特殊符号a!b@c#--- PASS: TestToUpperCase2 (<span class="hljs-number">0.00</span>s)    --- PASS: TestToUpperCase2/英文小写转大写 (<span class="hljs-number">0.00</span>s)    --- PASS: TestToUpperCase2/中文不变 (<span class="hljs-number">0.00</span>s)    --- PASS: TestToUpperCase2/空字符串 (<span class="hljs-number">0.00</span>s)    --- PASS: TestToUpperCase2/带特殊符号 (<span class="hljs-number">0.00</span>s)PASSok      blog/util       <span class="hljs-number">0.406</span>s</code></pre></div><p>而当我们运行如下命令的时候，<code>config</code>中的测试又会运行了。</p><div class="code-wrapper"><pre><code class="hljs shell">➜  config go test -v blog/config/ -count=1=== RUN   TestInitConfig=== RUN   TestInitConfig/test=== RUN   TestInitConfig/test2=== RUN   TestInitConfig/test3--- PASS: TestInitConfig (0.00s)    --- PASS: TestInitConfig/test (0.00s)    --- PASS: TestInitConfig/test2 (0.00s)    --- PASS: TestInitConfig/test3 (0.00s)PASSok      blog/config     0.197s</code></pre></div><blockquote><p>[!NOTE] </p><p>需要注意两点，可以自行尝试</p><ul><li>blog&#x2F;util&#x2F; 中的<code>blog</code>并不是目录的名字，而是go module中module的名字。</li><li>这个参数也可以使用相对路径，是相对于当前目录。</li><li>如果省略这个参数，那么go test 会检索当前目录下的所有测试。</li></ul></blockquote><h5 id="count-1"><a href="#count-1" class="headerlink" title="- count &#x3D; 1"></a>- count &#x3D; 1</h5><p><code>-count=1</code>参数在Go测试中主要作用是强行执行测试而不是使用缓存的结果。</p><p>具体来说，默认情况下，Go会缓存成功的测试结果，如果测试文件和相关代码文件没有改变，再次运行相同的测试会直接使用缓存的结果，而不是真正的执行测试。</p><p>如果使用了<code>-count = 1</code>参数，可以实现：</p><ul><li>强制执行测试，忽略缓存</li><li>确保每次都是真实地运行测试代码</li><li>适合测试结果可能会变化的场景（比如依赖外部服务或者对时间的测试）</li></ul><h4 id="失败时终止测试"><a href="#失败时终止测试" class="headerlink" title="失败时终止测试"></a>失败时终止测试</h4><p>前面的几个测试用例中，我们都是使用<code>t.Errorf()</code>返回错误，但当遇到某些错误的时候，可能是因为我们的程序有问题，需要立即终止测试程序，这时候你可以使用<code>t.Fatal()</code>。例如，我们在配置环境的时候，如果环境错误，剩下的就无法进行了。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestImportant</span><span class="hljs-params">(t *testing.T)</span></span> &#123;    setup := prepareTest()    <span class="hljs-keyword">if</span> setup.err != <span class="hljs-literal">nil</span> &#123;        t.Fatal(<span class="hljs-string">&quot;设置失败:&quot;</span>, setup.err)  <span class="hljs-comment">// 立即终止测试</span>    &#125;    <span class="hljs-comment">// 继续测试...</span>&#125;</code></pre></div><h4 id="并行测试"><a href="#并行测试" class="headerlink" title="并行测试"></a>并行测试</h4><blockquote><p>[!TIP]</p><p>先记录一下，没怎么深入研究，研究完了再来补充</p></blockquote><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestParallel</span><span class="hljs-params">(t *testing.T)</span></span> &#123;    tests := []<span class="hljs-keyword">struct</span>&#123;        name <span class="hljs-type">string</span>        input <span class="hljs-type">int</span>    &#125;&#123;        &#123;<span class="hljs-string">&quot;case1&quot;</span>, <span class="hljs-number">1</span>&#125;,        &#123;<span class="hljs-string">&quot;case2&quot;</span>, <span class="hljs-number">2</span>&#125;,    &#125;        <span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> tests &#123;        tt := tt  <span class="hljs-comment">// 捕获循环变量</span>        t.Run(tt.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;            t.Parallel()  <span class="hljs-comment">// 标记并行执行</span>            <span class="hljs-comment">// 测试代码...</span>        &#125;)    &#125;&#125;</code></pre></div><h4 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率</h4><blockquote><p>[!TIP]</p><p>这个后面有时间单独写一篇来介绍</p></blockquote><h4 id="常用的基础单元测试命令"><a href="#常用的基础单元测试命令" class="headerlink" title="常用的基础单元测试命令"></a>常用的基础单元测试命令</h4><h5 id="基础命令格式"><a href="#基础命令格式" class="headerlink" title="基础命令格式"></a>基础命令格式</h5><div class="code-wrapper"><pre><code class="hljs css">bashCopygo test <span class="hljs-selector-attr">[构建/测试标志]</span> <span class="hljs-selector-attr">[包列表]</span> <span class="hljs-selector-attr">[包测试]</span></code></pre></div><h5 id="常用命令示例"><a href="#常用命令示例" class="headerlink" title="常用命令示例"></a>常用命令示例</h5><h6 id="1-基本测试命令"><a href="#1-基本测试命令" class="headerlink" title="1. 基本测试命令"></a>1. 基本测试命令</h6><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 测试当前目录</span>go <span class="hljs-built_in">test</span><span class="hljs-comment"># 测试当前目录及其子目录</span>go <span class="hljs-built_in">test</span> ./...<span class="hljs-comment"># 测试指定包</span>go <span class="hljs-built_in">test</span> example.com/myproject/pkg/util<span class="hljs-comment"># 测试多个包</span>go <span class="hljs-built_in">test</span> pkg1 pkg2<span class="hljs-comment"># 测试指定文件</span>go <span class="hljs-built_in">test</span> file_test.go file.go</code></pre></div><h6 id="2-详细程度控制"><a href="#2-详细程度控制" class="headerlink" title="2. 详细程度控制"></a>2. 详细程度控制</h6><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 显示详细测试信息</span>go <span class="hljs-built_in">test</span> -v<span class="hljs-comment"># 显示更详细的输出（包括测试日志）</span>go <span class="hljs-built_in">test</span> -v -args -test.v<span class="hljs-comment"># 仅显示失败的测试</span>go <span class="hljs-built_in">test</span> -short</code></pre></div><h6 id="3-测试筛选"><a href="#3-测试筛选" class="headerlink" title="3. 测试筛选"></a>3. 测试筛选</h6><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 运行指定的测试函数（支持正则表达式）</span>go <span class="hljs-built_in">test</span> -run TestXxx<span class="hljs-comment"># 运行名称中包含 &quot;String&quot; 的测试</span>go <span class="hljs-built_in">test</span> -run String<span class="hljs-comment"># 运行特定测试和子测试</span>go <span class="hljs-built_in">test</span> -run TestXxx/SubTest<span class="hljs-comment"># 运行所有基准测试</span>go <span class="hljs-built_in">test</span> -run=^$ -bench=.<span class="hljs-comment"># 运行指定的基准测试</span>go <span class="hljs-built_in">test</span> -run=^$ -bench=BenchmarkXxx</code></pre></div><h6 id="4-测试覆盖率"><a href="#4-测试覆盖率" class="headerlink" title="4. 测试覆盖率"></a>4. 测试覆盖率</h6><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 显示测试覆盖率</span>go <span class="hljs-built_in">test</span> -cover<span class="hljs-comment"># 生成测试覆盖率概要文件</span>go <span class="hljs-built_in">test</span> -coverprofile=coverage.out<span class="hljs-comment"># 在浏览器中查看覆盖率报告</span>go tool cover -html=coverage.out<span class="hljs-comment"># 显示每个函数的覆盖率</span>go <span class="hljs-built_in">test</span> -coverprofile=coverage.out -covermode=count<span class="hljs-comment"># 设置覆盖率目标</span>go <span class="hljs-built_in">test</span> -cover -covermode=atomic -coverpkg=./...</code></pre></div><h4 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h4><p>其他还有不少内容这里没有提到，文中这些内容目前对我的工作来说已经够用了。感兴趣的同学可以继续学习：</p><ul><li><p><a href="https://golang.org/pkg/testing/">Go官方测试文档</a></p></li><li><p><a href="https://dave.cheney.net/2019/05/07/prefer-table-driven-tests">Go测试最佳实践</a></p></li><li><p><a href="https://blog.golang.org/subtests">Go高级测试模式</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>编码规范</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】37-写文件</title>
    <link href="/%E3%80%90GolangBot%E3%80%9137-%E5%86%99%E6%96%87%E4%BB%B6/"/>
    <url>/%E3%80%90GolangBot%E3%80%9137-%E5%86%99%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到 <a href="../golangbot/">Golang 教程系列</a> 的第 37 个教程。</p><p>在本教程中，我们将学习如何使用 Go 将数据写入文件。我们还将学习如何并发地写入文件。</p><p>本教程包含以下部分：</p><ul><li>将字符串写入文件</li><li>将字节写入文件</li><li>逐行将数据写入文件</li><li>追加到文件</li><li>并发写入文件</li></ul><p>请在你的本地系统中运行本教程的所有程序，因为 playground 不支持文件操作。</p><h3 id="将字符串写入文件"><a href="#将字符串写入文件" class="headerlink" title="将字符串写入文件"></a>将字符串写入文件</h3><p>最常见的文件写入操作之一是将字符串写入文件。这非常简单。它包括以下步骤：</p><ol><li>创建文件</li><li>将字符串写入文件</li></ol><p>让我们直接看代码。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;os&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;f, err := os.Create(<span class="hljs-string">&quot;test.txt&quot;</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(err)<span class="hljs-keyword">return</span>&#125;l, err := f.WriteString(<span class="hljs-string">&quot;Hello World&quot;</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(err)        f.Close()<span class="hljs-keyword">return</span>&#125;fmt.Println(l, <span class="hljs-string">&quot;bytes written successfully&quot;</span>)err = f.Close()<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(err)<span class="hljs-keyword">return</span>&#125;&#125;</code></pre></div><p>程序第 9 行的 <code>create</code> 函数创建了一个名为 <em>test.txt</em> 的文件。如果该文件已经存在，则 <code>create</code> 函数会截断该文件。此函数返回一个 <a href="https://pkg.go.dev/os#File">文件描述符</a>。</p><p>在第 14 行，我们使用 <code>WriteString</code> 方法将字符串 <strong>Hello World</strong> 写入文件。此方法返回写入的字节数和可能的错误。</p><p>最后，我们在第 21 行关闭文件。</p><p>上述程序将打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">11 bytes written successfully</code></pre></div><p>你可以在运行此程序的目录中找到一个名为 <strong>test.txt</strong> 的文件。如果你使用任何文本编辑器打开该文件，你会发现它包含文本 <strong>Hello World</strong>。</p><h3 id="将字节写入文件"><a href="#将字节写入文件" class="headerlink" title="将字节写入文件"></a>将字节写入文件</h3><p>将字节写入文件与将字符串写入文件非常相似。我们将使用 <a href="https://pkg.go.dev/os#File.Write">Write</a> 方法将字节写入文件。以下程序将字节切片写入文件。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;os&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;f, err := os.Create(<span class="hljs-string">&quot;/home/naveen/bytes&quot;</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(err)<span class="hljs-keyword">return</span>&#125;d2 := []<span class="hljs-type">byte</span>&#123;<span class="hljs-number">104</span>, <span class="hljs-number">101</span>, <span class="hljs-number">108</span>, <span class="hljs-number">108</span>, <span class="hljs-number">111</span>, <span class="hljs-number">32</span>, <span class="hljs-number">98</span>, <span class="hljs-number">121</span>, <span class="hljs-number">116</span>, <span class="hljs-number">101</span>, <span class="hljs-number">115</span>&#125;n2, err := f.Write(d2)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(err)        f.Close()<span class="hljs-keyword">return</span>&#125;fmt.Println(n2, <span class="hljs-string">&quot;bytes written successfully&quot;</span>)err = f.Close()<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(err)<span class="hljs-keyword">return</span>&#125;&#125;</code></pre></div><p>在上述程序中，第 15 行我们使用 <strong>Write</strong> 方法将字节切片写入目录 <code>/home/naveen</code> 中名为 <code>bytes</code> 的文件。你可以将此目录更改为其他目录。程序的其余部分不言自明。该程序将打印 <code>11 bytes written successfully</code>，并创建一个名为 <code>bytes</code> 的文件。打开该文件，你可以看到它包含文本 <code>hello bytes</code>。</p><h3 id="逐行将字符串写入文件"><a href="#逐行将字符串写入文件" class="headerlink" title="逐行将字符串写入文件"></a>逐行将字符串写入文件</h3><p>另一个常见的文件操作是需要逐行将字符串写入文件。在本节中，我们将编写一个程序来创建一个包含以下内容的文件。</p><div class="code-wrapper"><pre><code class="hljs fallback">Welcome to the world of Go.Go is a compiled language.It is easy to learn Go.</code></pre></div><p>让我们直接看代码。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;os&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;f, err := os.Create(<span class="hljs-string">&quot;lines&quot;</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(err)                f.Close()<span class="hljs-keyword">return</span>&#125;d := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;Welcome to the world of Go1.&quot;</span>, <span class="hljs-string">&quot;Go is a compiled language.&quot;</span>, <span class="hljs-string">&quot;It is easy to learn Go.&quot;</span>&#125;<span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> d &#123;fmt.Fprintln(f, v)        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(err)<span class="hljs-keyword">return</span>&#125;&#125;err = f.Close()<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(err)<span class="hljs-keyword">return</span>&#125;fmt.Println(<span class="hljs-string">&quot;file written successfully&quot;</span>)&#125;</code></pre></div><p>在程序的第 9 行，我们创建了一个名为 <strong>lines</strong> 的新文件。在第 17 行，我们使用 for range 循环遍历数组，并使用 <a href="https://golang.org/pkg/fmt/#Fprintln">Fprintln</a> 函数将行写入文件。<strong>Fprintln</strong> 函数以 <code>io.writer</code> 作为参数，并追加一个新行，这正是我们想要的。运行此程序将打印 <code>file written successfully</code>，并在当前目录中创建一个文件 <code>lines</code>。文件 <code>lines</code> 的内容如下：</p><div class="code-wrapper"><pre><code class="hljs fallback">Welcome to the world of Go1.Go is a compiled language.It is easy to learn Go.</code></pre></div><h3 id="追加到文件"><a href="#追加到文件" class="headerlink" title="追加到文件"></a>追加到文件</h3><p>在本节中，我们将向上一节中创建的 <code>lines</code> 文件追加一行。我们将追加行 <strong>File handling is easy</strong> 到 <code>lines</code> 文件。</p><p>文件必须以追加和只写模式打开。这些标志作为参数传递给 <a href="https://pkg.go.dev/os#OpenFile">Open</a> 函数。文件以追加模式打开后，我们将新行添加到文件中。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;os&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;f, err := os.OpenFile(<span class="hljs-string">&quot;lines&quot;</span>, os.O_APPEND|os.O_WRONLY, <span class="hljs-number">0644</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(err)<span class="hljs-keyword">return</span>&#125;newLine := <span class="hljs-string">&quot;File handling is easy.&quot;</span>_, err = fmt.Fprintln(f, newLine)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(err)                f.Close()<span class="hljs-keyword">return</span>&#125;err = f.Close()<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(err)<span class="hljs-keyword">return</span>&#125;fmt.Println(<span class="hljs-string">&quot;file appended successfully&quot;</span>)&#125;</code></pre></div><p>在程序的第 9 行，我们以追加和只写模式打开文件。文件成功打开后，我们在第 15 行向文件添加新行。该程序将打印 <code>file appended successfully</code>。运行此程序后，<code>lines</code> 文件的内容将是：</p><div class="code-wrapper"><pre><code class="hljs fallback">Welcome to the world of Go1.Go is a compiled language.It is easy to learn Go.File handling is easy.</code></pre></div><h3 id="并发写入文件"><a href="#并发写入文件" class="headerlink" title="并发写入文件"></a>并发写入文件</h3><p>当多个 <a href="../%E3%80%90GolangBot%E3%80%9121-Goroutines">goroutines</a> 并发写入文件时，我们将遇到 <a href="../%E3%80%90GolangBot%E3%80%9125-%E4%BA%92%E6%96%A5%E9%94%81/#%E4%BD%BF%E7%94%A8%E4%BA%92%E6%96%A5%E9%94%81%E8%A7%A3%E5%86%B3%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6">竞态条件</a>。因此，必须使用通道来协调对文件的并发写入。</p><p>我们将编写一个程序，创建 100 个 goroutines。每个 goroutine 将并发生成一个随机数，从而总共生成 100 个随机数。这些随机数将被写入文件。我们将通过以下方法解决 <a href="../%E3%80%90GolangBot%E3%80%9125-%E4%BA%92%E6%96%A5%E9%94%81/#%E4%BD%BF%E7%94%A8%E4%BA%92%E6%96%A5%E9%94%81%E8%A7%A3%E5%86%B3%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6">竞态条件</a> 问题。</p><ol><li>创建一个通道，用于读取和写入生成的随机数。</li><li>创建 100 个生产者 goroutines。每个 goroutine 将生成一个随机数，并将随机数写入通道。</li><li>创建一个消费者 goroutine，它将从通道中读取并将生成的随机数写入文件。因此，我们只有一个 goroutine 并发写入文件，从而避免竞态条件 :)</li><li>完成后关闭文件。</li></ol><p>让我们首先编写生成随机数的 <code>produce</code> 函数。</p><div class="code-wrapper"><pre><code class="hljs fallback">func produce(data chan int, wg *sync.WaitGroup) &#123;n := rand.Intn(999)data &lt;- nwg.Done()&#125;</code></pre></div><p>上述函数生成一个随机数并将其写入通道 <code>data</code>，然后在 <a href="../%E3%80%90GolangBot%E3%80%9123-%E7%BC%93%E5%86%B2%E9%80%9A%E9%81%93%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%B1%A0/#waitgroup">waitgroup</a> 上调用 <code>Done</code> 以通知它已完成其任务。</p><p>让我们现在转到写入文件的函数。</p><div class="code-wrapper"><pre><code class="hljs fallback">func consume(data chan int, done chan bool) &#123;f, err := os.Create(&quot;concurrent&quot;)if err != nil &#123;fmt.Println(err)return&#125;for d := range data &#123;_, err = fmt.Fprintln(f, d)if err != nil &#123;fmt.Println(err)f.Close()done &lt;- falsereturn&#125;&#125;err = f.Close()if err != nil &#123;fmt.Println(err)done &lt;- falsereturn&#125;done &lt;- true&#125;</code></pre></div><p><code>consume</code> 函数创建一个名为 <code>concurrent</code> 的文件。然后它从 <code>data</code> 通道读取随机数并将其写入文件。一旦它读取并写入了所有随机数，它就会向 <code>done</code> 通道写入 <code>true</code>，以通知它已完成其任务。</p><p>让我们编写 <code>main</code> 函数并完成此程序。我提供了整个程序如下。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;math/rand&quot;</span><span class="hljs-string">&quot;os&quot;</span><span class="hljs-string">&quot;sync&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">produce</span><span class="hljs-params">(data <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, wg *sync.WaitGroup)</span></span> &#123;n := rand.Intn(<span class="hljs-number">999</span>)data &lt;- nwg.Done()&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">consume</span><span class="hljs-params">(data <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, done <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)</span></span> &#123;f, err := os.Create(<span class="hljs-string">&quot;concurrent&quot;</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(err)<span class="hljs-keyword">return</span>&#125;<span class="hljs-keyword">for</span> d := <span class="hljs-keyword">range</span> data &#123;_, err = fmt.Fprintln(f, d)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(err)f.Close()done &lt;- <span class="hljs-literal">false</span><span class="hljs-keyword">return</span>&#125;&#125;err = f.Close()<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(err)done &lt;- <span class="hljs-literal">false</span><span class="hljs-keyword">return</span>&#125;done &lt;- <span class="hljs-literal">true</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;data := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)wg := sync.WaitGroup&#123;&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;wg.Add(<span class="hljs-number">1</span>)<span class="hljs-keyword">go</span> produce(data, &amp;wg)&#125;<span class="hljs-keyword">go</span> consume(data, done)<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;wg.Wait()<span class="hljs-built_in">close</span>(data)&#125;()d := &lt;-done<span class="hljs-keyword">if</span> d &#123;fmt.Println(<span class="hljs-string">&quot;File written successfully&quot;</span>)&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(<span class="hljs-string">&quot;File writing failed&quot;</span>)&#125;&#125;</code></pre></div><p>主函数在第 41 行创建 <code>data</code> 通道，从中读取随机数并写入。第 42 行的 <code>done</code> 通道由 <code>consume</code> goroutine 用于通知 <code>main</code> 它已完成其任务。第 43 行的 <code>wg</code> waitgroup 用于等待所有 100 个 goroutines 完成生成随机数。</p><p>第 44 行的 <code>for</code> 循环创建了 100 个 goroutines。第 49 行的 goroutine 调用在 waitgroup 上调用 <code>wait()</code>，以等待所有 100 个 goroutines 完成创建随机数。之后，它关闭通道。一旦通道关闭并且 <code>consume</code> goroutine 已完成将所有生成的随机数写入文件，它将在第 37 行向 <code>done</code> 通道写入 <code>true</code>，主 goroutine 被解除阻塞并打印 <code>File written successfully</code>。</p><p>现在你可以在任何文本编辑器中打开文件 <strong>concurrent</strong>，并查看生成的 100 个随机数 :)</p><p>本教程到此结束。希望你喜欢阅读。祝你有个美好的一天。</p><p>上一个教程 - <a href="../%E3%80%90GolangBot%E3%80%9136-%E8%AF%BB%E6%96%87%E4%BB%B6">读取文件</a></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GolangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】36-读文件</title>
    <link href="/%E3%80%90GolangBot%E3%80%9136-%E8%AF%BB%E6%96%87%E4%BB%B6/"/>
    <url>/%E3%80%90GolangBot%E3%80%9136-%E8%AF%BB%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到 <a href="../golangbot/">Golang 教程系列</a> 的第 36 个教程。</p><p>文件读取是任何编程语言中最常见的操作之一。在本教程中，我们将学习如何使用 Go 读取文件。</p><p>本教程包含以下部分：</p><ul><li>将整个文件读入内存<ul><li>使用绝对文件路径</li><li>将文件路径作为命令行标志传递</li><li>将文件打包到二进制文件中</li></ul></li><li>分块读取文件</li><li>逐行读取文件</li></ul><h3 id="将整个文件读入内存"><a href="#将整个文件读入内存" class="headerlink" title="将整个文件读入内存"></a>将整个文件读入内存</h3><p>最基本的文件操作之一是将整个文件读入内存。这可以通过 <a href="https://pkg.go.dev/os">os</a> 包中的 <a href="https://pkg.go.dev/os#ReadFile">ReadFile</a> 函数来实现。</p><p>让我们读取一个文件并打印其内容。</p><p>我通过运行 <code>mkdir ~/Documents/filehandling</code> 在 <code>Documents</code> 目录下创建了一个文件夹 <code>filehandling</code>。</p><p>在 <code>filehandling</code> 目录下运行以下命令，创建一个名为 <code>filehandling</code> 的 Go 模块。</p><div class="code-wrapper"><pre><code class="hljs fallback">go mod init filehandling</code></pre></div><p>我有一个文本文件 <code>test.txt</code>，它将从我们的 Go 程序 <code>filehandling.go</code> 中读取。<code>test.txt</code> 包含以下字符串：</p><div class="code-wrapper"><pre><code class="hljs fallback">Hello World. Welcome to file handling in Go.</code></pre></div><p>这是我的目录结构：</p><div class="code-wrapper"><pre><code class="hljs fallback">├── Documents│   └── filehandling│       ├── filehandling.go|       ├── go.mod│       └── test.txt</code></pre></div><p>让我们直接看代码。创建一个文件 <code>filehandling.go</code>，内容如下：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;os&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;contents, err := os.ReadFile(<span class="hljs-string">&quot;test.txt&quot;</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;File reading error&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;fmt.Println(<span class="hljs-string">&quot;Contents of file:&quot;</span>, <span class="hljs-type">string</span>(contents))&#125;</code></pre></div><p>请在本地环境中运行此程序，因为无法在 playground 中读取文件。</p><p>程序第 9 行读取文件并返回一个字节 <a href="../%E3%80%90GolangBot%E3%80%9111-%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/#%E5%88%87%E7%89%87">slice</a>，存储在 <code>contents</code> 中。在第 14 行，我们将 <code>contents</code> 转换为 <code>string</code> 并显示文件内容。</p><p>请在 <strong>test.txt</strong> 所在的目录下运行此程序。</p><p>如果 <strong>test.txt</strong> 位于 <strong>~&#x2F;Documents&#x2F;filehandling</strong>，则使用以下步骤运行此程序：</p><div class="code-wrapper"><pre><code class="hljs fallback">cd ~/Documents/filehandling/go install filehandling</code></pre></div><p>如果你不知道如何运行 Go 程序，请访问 <a href="../GolangBot%E3%80%912-Hello-World">&#x2F;hello-world-gomod&#x2F;</a> 了解更多。如果你想了解更多关于包和 Go 模块的信息，请访问 <a href="../%E3%80%90GolangBot%E3%80%917-%E5%8C%85">&#x2F;go-packages&#x2F;</a></p><p>该程序将打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">Contents of file: Hello World. Welcome to file handling in Go.</code></pre></div><p>如果从其他位置运行此程序，例如尝试从 <code>~/Documents/</code> 运行程序：</p><div class="code-wrapper"><pre><code class="hljs fallback">cd ~/Documents/filehandling</code></pre></div><p>它将打印以下错误：</p><div class="code-wrapper"><pre><code class="hljs fallback">File reading error open test.txt: no such file or directory</code></pre></div><p>原因是 Go 是一种编译型语言。<code>go install</code> 所做的是从源代码创建一个二进制文件。二进制文件独立于源代码，可以从任何位置运行。由于在运行二进制文件的位置找不到 <code>test.txt</code>，程序会抱怨找不到指定的文件。</p><p>有三种方法可以解决这个问题：</p><ol><li>使用绝对文件路径</li><li>将文件路径作为命令行标志传递</li><li>将文本文件与二进制文件打包在一起</li></ol><p>让我们逐一讨论。</p><h5 id="1-使用绝对文件路径"><a href="#1-使用绝对文件路径" class="headerlink" title="1. 使用绝对文件路径"></a>1. 使用绝对文件路径</h5><p>解决此问题的最简单方法是传递绝对文件路径。我修改了程序，并在第 9 行将路径更改为绝对路径。请将此路径更改为你的 <code>test.txt</code> 的绝对路径。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;os&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;contents, err := os.ReadFile(<span class="hljs-string">&quot;/Users/naveen/Documents/filehandling/test.txt&quot;</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;File reading error&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;fmt.Println(<span class="hljs-string">&quot;Contents of file:&quot;</span>, <span class="hljs-type">string</span>(contents))&#125;</code></pre></div><p>现在，程序可以从任何位置运行，并打印 <code>test.txt</code> 的内容。</p><p>例如，即使我从主目录运行它，它也会工作：</p><div class="code-wrapper"><pre><code class="hljs fallback">cd ~/Documents/filehandlinggo installcd ~filehandling</code></pre></div><p>该程序将打印 <code>test.txt</code> 的内容。</p><p>这似乎是一种简单的方法，但有一个缺点，即文件必须位于程序中指定的路径中，否则此方法将失败。</p><h5 id="2-将文件路径作为命令行标志传递"><a href="#2-将文件路径作为命令行标志传递" class="headerlink" title="2. 将文件路径作为命令行标志传递"></a>2. 将文件路径作为命令行标志传递</h5><p>另一种解决此问题的方法是将文件路径作为命令行参数传递。使用 <a href="https://pkg.go.dev/flag">flag</a> 包，我们可以从命令行获取文件路径作为输入参数，然后读取其内容。</p><p>让我们首先了解 <code>flag</code> 包的工作原理。<code>flag</code> 包有一个 <a href="https://golang.org/pkg/flag/#String">String</a> 函数。该函数接受 3 个参数。第一个是标志的名称，第二个是默认值，第三个是标志的简短描述。</p><p>让我们编写一个小程序来从命令行读取文件名。将 <code>filehandling.go</code> 的内容替换为以下内容：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;flag&quot;</span><span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fptr := flag.String(<span class="hljs-string">&quot;fpath&quot;</span>, <span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&quot;file path to read from&quot;</span>)flag.Parse()fmt.Println(<span class="hljs-string">&quot;value of fpath is&quot;</span>, *fptr)&#125;</code></pre></div><p>程序第 8 行使用 <code>String</code> 函数创建了一个名为 <code>fpath</code> 的字符串标志，默认值为 <code>test.txt</code>，描述为 <code>file path to read from</code>。此函数返回存储标志值的字符串 <a href="https://golangbot.com/variables/">变量</a> 的地址。</p><p>在访问任何标志之前，应调用 <em>flag.Parse()</em>。</p><p>我们在第 10 行打印标志的值。</p><p>当使用以下命令运行此程序时：</p><div class="code-wrapper"><pre><code class="hljs fallback">filehandling -fpath=/path-of-file/test.txt</code></pre></div><p>我们将 <code>/path-of-file/test.txt</code> 作为标志 <code>fpath</code> 的值传递。</p><p>该程序输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">value of fpath is /path-of-file/test.txt</code></pre></div><p>如果仅使用 <code>filehandling</code> 运行程序而不传递任何 <code>fpath</code>，它将打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">value of fpath is test.txt</code></pre></div><p>因为 <code>test.txt</code> 是 <code>fpath</code> 的默认值。</p><p><code>flag</code> 还提供了一个格式良好的输出，显示可用的不同参数。可以通过运行以下命令显示：</p><div class="code-wrapper"><pre><code class="hljs fallback">filehandling --help</code></pre></div><p>此命令将打印以下输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">Usage of filehandling:  -fpath string    file path to read from (default &quot;test.txt&quot;)</code></pre></div><p>不错吧 :)。</p><p>现在我们知道如何从命令行读取文件路径，让我们继续完成我们的文件读取程序。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;flag&quot;</span><span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;os&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fptr := flag.String(<span class="hljs-string">&quot;fpath&quot;</span>, <span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&quot;file path to read from&quot;</span>)flag.Parse()contents, err := os.ReadFile(*fptr)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;File reading error&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;fmt.Println(<span class="hljs-string">&quot;Contents of file:&quot;</span>, <span class="hljs-type">string</span>(contents))&#125;</code></pre></div><p>上面的程序读取从命令行传递的文件路径的内容。使用以下命令运行此程序：</p><div class="code-wrapper"><pre><code class="hljs fallback">filehandling -fpath=/path-of-file/test.txt</code></pre></div><p>请将 <code>/path-of-file/</code> 替换为 <code>test.txt</code> 的绝对路径。例如，在我的情况下，我运行了以下命令：</p><div class="code-wrapper"><pre><code class="hljs fallback">filehandling --fpath=/Users/naveen/Documents/filehandling/test.txt</code></pre></div><p>程序打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">Contents of file: Hello World. Welcome to file handling in Go.</code></pre></div><h5 id="3-将文本文件与二进制文件打包在一起"><a href="#3-将文本文件与二进制文件打包在一起" class="headerlink" title="3. 将文本文件与二进制文件打包在一起"></a>3. 将文本文件与二进制文件打包在一起</h5><p>上述从命令行获取文件路径的选项很好，但有一种更好的方法可以解决此问题。如果能够将文本文件与我们的二进制文件打包在一起，那不是很棒吗？这就是我们接下来要做的。</p><p>标准库中的 <a href="https://pkg.go.dev/embed">embed</a> 包将帮助我们实现这一点。</p><p>导入 <code>embed</code> 包后，可以使用 <code>//go:embed</code> 指令读取文件内容。</p><p>一个程序将帮助我们更好地理解这一点。</p><p>将 <code>filehandling.go</code> 的内容替换为以下内容：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (_ <span class="hljs-string">&quot;embed&quot;</span><span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-comment">//go:embed test.txt</span><span class="hljs-keyword">var</span> contents []<span class="hljs-type">byte</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;Contents of file:&quot;</span>, <span class="hljs-type">string</span>(contents))&#125;</code></pre></div><p>在程序的第 4 行，我们使用下划线前缀导入 <code>embed</code> 包。原因是 <code>embed</code> 没有在代码中显式使用，但第 8 行的 <code>//go:embed</code> 注释需要编译器进行一些预处理。由于我们需要在不显式使用的情况下导入包，因此我们使用下划线前缀以使编译器满意。如果不这样做，编译器会抱怨该包未在任何地方使用。</p><p>第 8 行的 <code>//go:embed test.txt</code> 告诉编译器读取 <code>test.txt</code> 的内容并将其分配给该注释后面的变量。在我们的例子中，<code>contents</code> 变量将保存文件的内容。</p><p>使用以下命令运行程序：</p><div class="code-wrapper"><pre><code class="hljs fallback">cd ~/Documents/filehandlinggo installfilehandling</code></pre></div><p>程序将打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">Contents of file: Hello World. Welcome to file handling in Go.</code></pre></div><p>现在，文件与二进制文件打包在一起，无论从何处执行，Go 二进制文件都可以访问它。例如，尝试从 <code>test.txt</code> 不存在的目录运行程序。</p><div class="code-wrapper"><pre><code class="hljs fallback">cd ~/Documentsfilehandling</code></pre></div><p>上述命令也将打印文件的内容。</p><p>请注意，文件内容应分配给的变量必须在包级别。局部变量不起作用。尝试将程序更改为以下内容：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (_ <span class="hljs-string">&quot;embed&quot;</span><span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">//go:embed test.txt</span><span class="hljs-keyword">var</span> contents []<span class="hljs-type">byte</span>fmt.Println(<span class="hljs-string">&quot;Contents of file:&quot;</span>, <span class="hljs-type">string</span>(contents))&#125;</code></pre></div><p>上面的程序将 <code>contents</code> 作为局部变量。</p><p>程序现在将无法编译，并出现以下错误：</p><div class="code-wrapper"><pre><code class="hljs fallback">./filehandling.go:9:4: go:embed cannot apply to var inside func</code></pre></div><p>如果你有兴趣了解更多关于此设计决策的信息，请阅读 <a href="https://github.com/golang/go/issues/43216">https://github.com/golang/go/issues/43216</a></p><h3 id="分块读取文件"><a href="#分块读取文件" class="headerlink" title="分块读取文件"></a>分块读取文件</h3><p>在上一节中，我们学习了如何将整个文件加载到内存中。当文件的大小非常大时，尤其是在 RAM 不足的情况下，将整个文件读入内存是没有意义的。更优化的方法是分块读取文件。这可以通过 <a href="https://pkg.go.dev/bufio">bufio</a> 包来实现。</p><p>让我们编写一个程序，以 3 字节的块读取我们的 <code>test.txt</code> 文件。将 <code>filehandling.go</code> 的内容替换为以下内容：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;bufio&quot;</span><span class="hljs-string">&quot;flag&quot;</span><span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;io&quot;</span><span class="hljs-string">&quot;log&quot;</span><span class="hljs-string">&quot;os&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fptr := flag.String(<span class="hljs-string">&quot;fpath&quot;</span>, <span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&quot;file path to read from&quot;</span>)flag.Parse()f, err := os.Open(*fptr)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatal(err)&#125;<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">if</span> err = f.Close(); err != <span class="hljs-literal">nil</span> &#123;log.Fatal(err)&#125;&#125;()r := bufio.NewReader(f)b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">3</span>)<span class="hljs-keyword">for</span> &#123;n, err := r.Read(b)<span class="hljs-keyword">if</span> err == io.EOF &#123;fmt.Println(<span class="hljs-string">&quot;finished reading file&quot;</span>)<span class="hljs-keyword">break</span>&#125;<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Printf(<span class="hljs-string">&quot;Error %s reading file&quot;</span>, err)<span class="hljs-keyword">break</span>&#125;fmt.Println(<span class="hljs-type">string</span>(b[<span class="hljs-number">0</span>:n]))&#125;&#125;</code></pre></div><p>在程序的第 16 行，我们使用从命令行标志传递的路径打开文件。</p><p>在第 20 行，我们延迟关闭文件。</p><p>程序的第 26 行创建了一个新的缓冲读取器。在下一行，我们创建了一个长度为 3 的字节切片，文件字节将被读取到其中。</p><p>第 29 行的 <code>Read</code> <a href="../%E3%80%90GolangBot%E3%80%9117-%E6%96%B9%E6%B3%95">方法</a> 读取最多 <code>len(b)</code> 字节，即最多 3 个字节，并返回读取的字节数。我们将返回的字节存储在变量 <code>n</code> 中。在第 38 行，切片从索引 <code>0</code> 读取到 <code>n-1</code>，即读取到 <code>Read</code> 方法返回的字节数，并打印。</p><p>一旦到达文件末尾，<code>read</code> 将返回一个 EOF 错误。我们在第 30 行检查此错误。程序的其余部分很简单。</p><p>如果我们使用以下命令运行上述程序：</p><div class="code-wrapper"><pre><code class="hljs fallback">cd ~/Documents/filehandlinggo installfilehandling -fpath=/path-of-file/test.txt</code></pre></div><p>将输出以下内容：</p><div class="code-wrapper"><pre><code class="hljs fallback">HelloWorld. Welcometofile handling in Go.finished reading file</code></pre></div><h3 id="逐行读取文件"><a href="#逐行读取文件" class="headerlink" title="逐行读取文件"></a>逐行读取文件</h3><p>在本节中，我们将讨论如何使用 Go 逐行读取文件。这可以使用 <a href="https://pkg.go.dev/bufio">bufio</a> 包来完成。</p><p>请将 <code>test.txt</code> 的内容替换为以下内容：</p><div class="code-wrapper"><pre><code class="hljs fallback">Hello World. Welcome to file handling in Go.  This is the second line of the file.  We have reached the end of the file.</code></pre></div><p>以下是逐行读取文件的步骤：</p><ol><li>打开文件</li><li>从文件创建一个新的扫描器</li><li>扫描文件并逐行读取。</li></ol><p>将 <code>filehandling.go</code> 的内容替换为以下内容：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;bufio&quot;</span><span class="hljs-string">&quot;flag&quot;</span><span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;log&quot;</span><span class="hljs-string">&quot;os&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fptr := flag.String(<span class="hljs-string">&quot;fpath&quot;</span>, <span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&quot;file path to read from&quot;</span>)flag.Parse()f, err := os.Open(*fptr)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatal(err)&#125;    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">if</span> err = f.Close(); err != <span class="hljs-literal">nil</span> &#123;log.Fatal(err)&#125;&#125;()s := bufio.NewScanner(f)<span class="hljs-keyword">for</span> s.Scan() &#123;fmt.Println(s.Text())&#125;err = s.Err()<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatal(err)&#125;&#125;</code></pre></div><p>在程序的第 15 行，我们使用从命令行标志传递的路径打开文件。在第 24 行，我们使用文件创建一个新的扫描器。第 25 行的 <code>scan()</code> 方法读取文件的下一行，读取的字符串将通过 <code>text()</code> 方法可用。</p><p>当 Scan 返回 <code>false</code> 后，<code>Err()</code> 方法将返回扫描期间发生的任何错误。如果错误是文件结束，<code>Err()</code> 将返回 <code>nil</code>。</p><p>如果我们使用以下命令运行上述程序：</p><div class="code-wrapper"><pre><code class="hljs fallback">cd ~/Documents/filehandlinggo installfilehandling -fpath=/path-of-file/test.txt</code></pre></div><p>文件的内容将逐行打印，如下所示：</p><div class="code-wrapper"><pre><code class="hljs fallback">Hello World. Welcome to file handling in Go.This is the second line of the file.We have reached the end of the file.</code></pre></div><p><strong>下一个教程 - <a href="../%E3%80%90GolangBot%E3%80%9137-%E5%86%99%E6%96%87%E4%BB%B6">写入文件</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GolangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】35-反射</title>
    <link href="/%E3%80%90GolangBot%E3%80%9135-%E5%8F%8D%E5%B0%84/"/>
    <url>/%E3%80%90GolangBot%E3%80%9135-%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到 <a href="../golangbot/">Golang 教程系列</a> 的第 35 个教程。</p><p>反射是 Go 中的高级主题之一。我将尽量使其简单易懂。</p><p>本教程包含以下部分：</p><ul><li>什么是反射？</li><li>为什么需要检查变量并找到其类型？</li><li>reflect 包<ul><li>reflect.Type 和 reflect.Value</li><li>reflect.Kind</li><li>NumField() 和 Field() 方法</li><li>Int() 和 String() 方法</li></ul></li><li>完整程序</li><li>是否应该使用反射？</li></ul><p>让我们逐一讨论这些部分。</p><h3 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h3><p>反射是程序在运行时检查其变量和值并找到其类型的能力。你可能还不理解这意味着什么，但没关系。通过本教程的学习，你会对反射有一个清晰的理解，所以请继续阅读。</p><h3 id="为什么需要检查变量并找到其类型？"><a href="#为什么需要检查变量并找到其类型？" class="headerlink" title="为什么需要检查变量并找到其类型？"></a>为什么需要检查变量并找到其类型？</h3><p>学习反射时，第一个问题通常是：为什么我们需要在运行时检查<a href="../%E3%80%90GolangBot%E3%80%913-%E5%8F%98%E9%87%8F">变量</a>并找到其类型，而程序中的每个变量都是由我们定义的，我们在编译时就已经知道其类型了。嗯，大多数情况下确实如此，但并非总是如此。</p><p>让我解释一下我的意思。让我们编写一个简单的程序。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;i := <span class="hljs-number">10</span>fmt.Printf(<span class="hljs-string">&quot;%d %T&quot;</span>, i, i)&#125;</code></pre></div><p><a href="https://play.golang.org/p/1oZzPCCG2Qw">在 Playground 中运行</a></p><p>在上面的程序中，<code>i</code> 的类型在编译时是已知的，我们在下一行打印它。这里没有什么神奇的地方。</p><p>现在让我们理解为什么需要在运行时知道变量的类型。假设我们想编写一个简单的<a href="../%E3%80%90GolangBot%E3%80%916-%E5%87%BD%E6%95%B0">函数</a>，它将接受一个<a href="../%E3%80%90GolangBot%E3%80%9116-%E7%BB%93%E6%9E%84%E4%BD%93">结构体</a>作为参数，并使用它创建一个 SQL 插入查询。</p><p>考虑以下程序：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> order <span class="hljs-keyword">struct</span> &#123;ordId      <span class="hljs-type">int</span>customerId <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;o := order&#123;ordId:      <span class="hljs-number">1234</span>,customerId: <span class="hljs-number">567</span>,&#125;fmt.Println(o)&#125;</code></pre></div><p><a href="https://play.golang.org/p/0wLQAVErHuH">在 Playground 中运行</a></p><p>我们需要编写一个函数，它将上述程序中的结构体 <code>o</code> 作为参数，并返回以下 SQL 插入查询：</p><div class="code-wrapper"><pre><code class="hljs fallback">insert into order values(1234, 567)</code></pre></div><p>这个函数很容易编写。让我们现在就来编写它。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> order <span class="hljs-keyword">struct</span> &#123;ordId      <span class="hljs-type">int</span>customerId <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createQuery</span><span class="hljs-params">(o order)</span></span> <span class="hljs-type">string</span> &#123;i := fmt.Sprintf(<span class="hljs-string">&quot;insert into order values(%d, %d)&quot;</span>, o.ordId, o.customerId)<span class="hljs-keyword">return</span> i&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;o := order&#123;ordId:      <span class="hljs-number">1234</span>,customerId: <span class="hljs-number">567</span>,&#125;fmt.Println(createQuery(o))&#125;</code></pre></div><p><a href="https://play.golang.org/p/jhz4VHKIlQ5">在 Playground 中运行</a></p><p>第 12 行的 <code>createQuery</code> 函数通过使用 <code>o</code> 的 <code>ordId</code> 和 <code>customerId</code> 字段创建插入查询。该程序将输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">insert into order values(1234, 567)</code></pre></div><p>现在让我们将查询生成器提升到一个新的水平。如果我们想泛化我们的查询生成器，使其适用于任何结构体，该怎么办？让我通过一个程序来解释我的意思。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">type</span> order <span class="hljs-keyword">struct</span> &#123;ordId      <span class="hljs-type">int</span>customerId <span class="hljs-type">int</span>&#125;<span class="hljs-keyword">type</span> employee <span class="hljs-keyword">struct</span> &#123;name <span class="hljs-type">string</span>id <span class="hljs-type">int</span>address <span class="hljs-type">string</span>salary <span class="hljs-type">int</span>country <span class="hljs-type">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createQuery</span><span class="hljs-params">(q <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">string</span> &#123;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;&#125;</code></pre></div><p>我们的目标是完成上述程序中第 16 行的 <code>createQuery</code> 函数，使其接受任何结构体作为参数，并根据结构体字段创建插入查询。</p><p>例如，如果我们传递以下结构体：</p><div class="code-wrapper"><pre><code class="hljs go">o := order &#123;ordId: <span class="hljs-number">1234</span>,customerId: <span class="hljs-number">567</span>&#125;</code></pre></div><p>我们的 <code>createQuery</code> 函数应返回：</p><div class="code-wrapper"><pre><code class="hljs fallback">insert into order values (1234, 567)</code></pre></div><p>同样，如果我们传递：</p><div class="code-wrapper"><pre><code class="hljs go">e := employee &#123;name: <span class="hljs-string">&quot;Naveen&quot;</span>,id: <span class="hljs-number">565</span>,address: <span class="hljs-string">&quot;Science Park Road, Singapore&quot;</span>,salary: <span class="hljs-number">90000</span>,country: <span class="hljs-string">&quot;Singapore&quot;</span>,&#125;</code></pre></div><p>它应返回：</p><div class="code-wrapper"><pre><code class="hljs fallback">insert into employee values(&quot;Naveen&quot;, 565, &quot;Science Park Road, Singapore&quot;, 90000, &quot;Singapore&quot;)</code></pre></div><p>由于 <code>createQuery</code> 函数应适用于任何结构体，因此它接受一个<a href="../%E3%80%90GolangBot%E3%80%9118-%E6%8E%A5%E5%8F%A3-I/#%E7%A9%BA%E6%8E%A5%E5%8F%A3"><em>interface{}</em></a>作为参数。为简单起见，我们只处理包含 <code>string</code> 和 <code>int</code> 类型字段的结构体，但这可以扩展到任何类型。</p><p><code>createQuery</code> 函数应适用于任何结构体。编写此函数的唯一方法是在运行时检查传递给它的结构体参数的类型，找到其字段，然后创建查询。这就是反射的用武之地。在教程的后续步骤中，我们将学习如何使用 <code>reflect</code> 包实现这一点。</p><h3 id="reflect-包"><a href="#reflect-包" class="headerlink" title="reflect 包"></a>reflect 包</h3><p><a href="https://golang.org/pkg/reflect/">reflect</a> 包在 Go 中实现了运行时反射。reflect 包有助于识别<a href="../%E3%80%90GolangBot%E3%80%9118-%E6%8E%A5%E5%8F%A3-I/#%E7%A9%BA%E6%8E%A5%E5%8F%A3"><em>interface{}</em></a>变量的具体类型和值。这正是我们所需要的。<code>createQuery</code> 函数接受一个 <code>interface&#123;&#125;</code> 参数，并且需要根据 <code>interface&#123;&#125;</code> 参数的具体类型和值创建查询。这正是 reflect 包的作用。</p><p>在编写我们的通用查询生成器程序之前，我们需要先了解 reflect 包中的一些类型和方法。让我们逐一看看它们。</p><h4 id="reflect-Type-和-reflect-Value"><a href="#reflect-Type-和-reflect-Value" class="headerlink" title="reflect.Type 和 reflect.Value"></a>reflect.Type 和 reflect.Value</h4><p><code>interface&#123;&#125;</code> 的具体类型由 <a href="https://golang.org/pkg/reflect/#Type">reflect.Type</a> 表示，其基础值由 <a href="https://golang.org/pkg/reflect/#Value">reflect.Value</a> 表示。有两个函数 <a href="https://golang.org/pkg/reflect/#TypeOf">reflect.TypeOf()</a> 和 <a href="https://golang.org/pkg/reflect/#ValueOf">reflect.ValueOf()</a>，它们分别返回 <code>reflect.Type</code> 和 <code>reflect.Value</code>。这两种类型是创建我们的查询生成器的基础。让我们编写一个简单的示例来理解这两种类型。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;reflect&quot;</span>)<span class="hljs-keyword">type</span> order <span class="hljs-keyword">struct</span> &#123;ordId      <span class="hljs-type">int</span>customerId <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createQuery</span><span class="hljs-params">(q <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;t := reflect.TypeOf(q)v := reflect.ValueOf(q)fmt.Println(<span class="hljs-string">&quot;Type &quot;</span>, t)fmt.Println(<span class="hljs-string">&quot;Value &quot;</span>, v)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;o := order&#123;ordId:      <span class="hljs-number">456</span>,customerId: <span class="hljs-number">56</span>,&#125;createQuery(o)&#125;</code></pre></div><p><a href="https://play.golang.org/p/81BS-bEfbCg">在 Playground 中运行</a></p><p>在上面的程序中，第 13 行的 <code>createQuery</code> 函数接受一个 <code>interface&#123;&#125;</code> 作为参数。第 14 行的 <a href="https://golang.org/pkg/reflect/#TypeOf">reflect.TypeOf</a> 函数接受一个 <code>interface&#123;&#125;</code> 作为参数，并返回包含传递给它的 <code>interface&#123;&#125;</code> 参数的具体类型的 <a href="https://golang.org/pkg/reflect/#Type">reflect.Type</a>。同样，第 15 行的 <a href="https://golang.org/pkg/reflect/#ValueOf">reflect.ValueOf</a> 函数接受一个 <code>interface&#123;&#125;</code> 作为参数，并返回包含传递给它的 <code>interface&#123;&#125;</code> 参数的基础值的 <a href="https://golang.org/pkg/reflect/#Value">reflect.Value</a>。</p><p>上面的程序打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">Type  main.orderValue  &#123;456 56&#125;</code></pre></div><p>从输出中可以看出，程序打印了 <code>interface&#123;&#125;</code> 的具体类型和值。</p><h4 id="reflect-Kind"><a href="#reflect-Kind" class="headerlink" title="reflect.Kind"></a>reflect.Kind</h4><p>反射包中还有一个重要的类型叫做 <a href="https://golang.org/pkg/reflect/#Kind">Kind</a>。</p><p>反射包中的 <code>Kind</code> 和 <code>Type</code> 类型可能看起来很相似，但它们有一个区别，下面的程序将清楚地展示这一点。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;reflect&quot;</span>)<span class="hljs-keyword">type</span> order <span class="hljs-keyword">struct</span> &#123;ordId      <span class="hljs-type">int</span>customerId <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createQuery</span><span class="hljs-params">(q <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;t := reflect.TypeOf(q)k := t.Kind()fmt.Println(<span class="hljs-string">&quot;Type &quot;</span>, t)fmt.Println(<span class="hljs-string">&quot;Kind &quot;</span>, k)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;o := order&#123;ordId:      <span class="hljs-number">456</span>,customerId: <span class="hljs-number">56</span>,&#125;createQuery(o)&#125;</code></pre></div><p><a href="https://play.golang.org/p/Xw3JIzCm54T">在 Playground 中运行</a></p><p>上面的程序输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">Type  main.orderKind  struct</code></pre></div><p>我想你现在应该清楚了两者之间的区别。<code>Type</code> 表示 <code>interface&#123;&#125;</code> 的实际类型，在本例中是 <strong>main.Order</strong>，而 <code>Kind</code> 表示该类型的特定种类。在本例中，它是一个 <strong>struct</strong>。</p><h4 id="NumField-和-Field-方法"><a href="#NumField-和-Field-方法" class="headerlink" title="NumField() 和 Field() 方法"></a>NumField() 和 Field() 方法</h4><p><a href="https://golang.org/pkg/reflect/#Value.NumField">NumField()</a> 方法返回结构体中的字段数，<a href="https://golang.org/pkg/reflect/#Value.Field">Field(i int)</a> 方法返回第 <code>i</code> 个字段的 <code>reflect.Value</code>。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;reflect&quot;</span>)<span class="hljs-keyword">type</span> order <span class="hljs-keyword">struct</span> &#123;ordId      <span class="hljs-type">int</span>customerId <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createQuery</span><span class="hljs-params">(q <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<span class="hljs-keyword">if</span> reflect.ValueOf(q).Kind() == reflect.Struct &#123;v := reflect.ValueOf(q)fmt.Println(<span class="hljs-string">&quot;Number of fields&quot;</span>, v.NumField())<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; v.NumField(); i++ &#123;fmt.Printf(<span class="hljs-string">&quot;Field:%d type:%T value:%v\n&quot;</span>, i, v.Field(i), v.Field(i))&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;o := order&#123;ordId:      <span class="hljs-number">456</span>,customerId: <span class="hljs-number">56</span>,&#125;createQuery(o)&#125;</code></pre></div><p><a href="https://play.golang.org/p/FBHfJfuTaEe">在 Playground 中运行</a></p><p>在上面的程序中，第 14 行我们首先检查 <code>q</code> 的 <code>Kind</code> 是否为 <code>struct</code>，因为 <code>NumField</code> 方法仅适用于结构体。程序的其余部分不言自明。该程序输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">Number of fields 2Field:0 type:reflect.Value value:456Field:1 type:reflect.Value value:56</code></pre></div><h4 id="Int-和-String-方法"><a href="#Int-和-String-方法" class="headerlink" title="Int() 和 String() 方法"></a>Int() 和 String() 方法</h4><p><a href="https://golang.org/pkg/reflect/#Value.Int">Int</a> 和 <a href="https://golang.org/pkg/reflect/#Value.String">String</a> 方法帮助将 <code>reflect.Value</code> 提取为 <code>int64</code> 和 <code>string</code>。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;reflect&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := <span class="hljs-number">56</span>x := reflect.ValueOf(a).Int()fmt.Printf(<span class="hljs-string">&quot;type:%T value:%v\n&quot;</span>, x, x)b := <span class="hljs-string">&quot;Naveen&quot;</span>y := reflect.ValueOf(b).String()fmt.Printf(<span class="hljs-string">&quot;type:%T value:%v\n&quot;</span>, y, y)&#125;</code></pre></div><p><a href="https://play.golang.org/p/UIllrLVoGwI">在 Playground 中运行</a></p><p>在上面的程序中，第 10 行我们将 <code>reflect.Value</code> 提取为 <code>int64</code>，第 13 行我们将其提取为 <code>string</code>。该程序打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">type:int64 value:56type:string value:Naveen</code></pre></div><h3 id="完整程序"><a href="#完整程序" class="headerlink" title="完整程序"></a>完整程序</h3><p>现在我们已经掌握了足够的知识来完成我们的查询生成器，让我们继续完成它。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;reflect&quot;</span>)<span class="hljs-keyword">type</span> order <span class="hljs-keyword">struct</span> &#123;ordId      <span class="hljs-type">int</span>customerId <span class="hljs-type">int</span>&#125;<span class="hljs-keyword">type</span> employee <span class="hljs-keyword">struct</span> &#123;name    <span class="hljs-type">string</span>id      <span class="hljs-type">int</span>address <span class="hljs-type">string</span>salary  <span class="hljs-type">int</span>country <span class="hljs-type">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createQuery</span><span class="hljs-params">(q <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<span class="hljs-keyword">if</span> reflect.ValueOf(q).Kind() == reflect.Struct &#123;t := reflect.TypeOf(q).Name()query := fmt.Sprintf(<span class="hljs-string">&quot;insert into %s values(&quot;</span>, t)v := reflect.ValueOf(q)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; v.NumField(); i++ &#123;<span class="hljs-keyword">switch</span> v.Field(i).Kind() &#123;<span class="hljs-keyword">case</span> reflect.Int:<span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;query = fmt.Sprintf(<span class="hljs-string">&quot;%s%d&quot;</span>, query, v.Field(i).Int())&#125; <span class="hljs-keyword">else</span> &#123;query = fmt.Sprintf(<span class="hljs-string">&quot;%s, %d&quot;</span>, query, v.Field(i).Int())&#125;<span class="hljs-keyword">case</span> reflect.String:<span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;query = fmt.Sprintf(<span class="hljs-string">&quot;%s\&quot;%s\&quot;&quot;</span>, query, v.Field(i).String())&#125; <span class="hljs-keyword">else</span> &#123;query = fmt.Sprintf(<span class="hljs-string">&quot;%s, \&quot;%s\&quot;&quot;</span>, query, v.Field(i).String())&#125;<span class="hljs-keyword">default</span>:fmt.Println(<span class="hljs-string">&quot;Unsupported type&quot;</span>)<span class="hljs-keyword">return</span>&#125;&#125;query = fmt.Sprintf(<span class="hljs-string">&quot;%s)&quot;</span>, query)fmt.Println(query)<span class="hljs-keyword">return</span>&#125;fmt.Println(<span class="hljs-string">&quot;unsupported type&quot;</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;o := order&#123;ordId:      <span class="hljs-number">456</span>,customerId: <span class="hljs-number">56</span>,&#125;createQuery(o)e := employee&#123;name:    <span class="hljs-string">&quot;Naveen&quot;</span>,id:      <span class="hljs-number">565</span>,address: <span class="hljs-string">&quot;Coimbatore&quot;</span>,salary:  <span class="hljs-number">90000</span>,country: <span class="hljs-string">&quot;India&quot;</span>,&#125;createQuery(e)i := <span class="hljs-number">90</span>createQuery(i)&#125;</code></pre></div><p><a href="https://play.golang.org/p/82Bi4RU5c7W">在 Playground 中运行</a></p><p>在第 22 行，我们首先检查传递的参数是否为 <code>struct</code>。在第 23 行，我们使用 <code>Name()</code> 方法从其 <code>reflect.Type</code> 中获取结构体的名称。在下一行，我们使用 <code>t</code> 并开始创建查询。</p><p>第 28 行的 <a href="../%E3%80%90GolangBot%E3%80%9110-switch%E8%AF%AD%E5%8F%A5">case</a> 语句检查当前字段是否为 <code>reflect.Int</code>，如果是，我们使用 <code>Int()</code> 方法将该字段的值提取为 <code>int64</code>。<a href="../%E3%80%90GolangBot%E3%80%918-if-else%E8%AF%AD%E5%8F%A5">if else</a> 语句用于处理边缘情况。请添加日志以理解为什么需要它。类似的逻辑用于在第 34 行提取 <code>string</code>。</p><p>我们还添加了检查，以防止在将不受支持的类型传递给 <code>createQuery</code> 函数时程序崩溃。程序的其余部分不言自明。我建议在适当的位置添加日志并检查其输出，以更好地理解该程序。</p><p>该程序打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">insert into order values(456, 56)insert into employee values(&quot;Naveen&quot;, 565, &quot;Coimbatore&quot;, 90000, &quot;India&quot;)unsupported type</code></pre></div><p>我将把将字段名称添加到输出查询的练习留给读者。请尝试更改程序以打印以下格式的查询：</p><div class="code-wrapper"><pre><code class="hljs fallback">insert into order(ordId, customerId) values(456, 56)</code></pre></div><h3 id="是否应该使用反射？"><a href="#是否应该使用反射？" class="headerlink" title="是否应该使用反射？"></a>是否应该使用反射？</h3><p>在展示了反射的实际用途之后，现在出现了一个真正的问题。你应该使用反射吗？我想引用 <a href="https://en.wikipedia.org/wiki/Rob_Pike">Rob Pike</a> 关于使用反射的谚语来回答这个问题。</p><p><em>清晰胜于聪明。反射从来都不清晰。</em></p><p>反射是 Go 中一个非常强大和高级的概念，应该谨慎使用。使用反射编写清晰且可维护的代码非常困难。应尽可能避免使用它，仅在绝对必要时使用。</p><p><strong>下一个教程 - <a href="../%E3%80%90GolangBot%E3%80%9136-%E8%AF%BB%E6%96%87%E4%BB%B6">读取文件</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GolangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】34-一等公民：函数</title>
    <link href="/%E3%80%90GolangBot%E3%80%9134-%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91%EF%BC%9A%E5%87%BD%E6%95%B0/"/>
    <url>/%E3%80%90GolangBot%E3%80%9134-%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91%EF%BC%9A%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到 <a href="../golangbot/">Golang 教程系列</a> 的第 34 个教程。</p><h3 id="什么是一等函数？"><a href="#什么是一等函数？" class="headerlink" title="什么是一等函数？"></a>什么是一等函数？</h3><p><strong>支持一等函数的语言允许将函数赋值给变量、作为参数传递给其他函数以及从其他函数返回。Go 支持一等函数。</strong></p><p>在本教程中，我们将讨论一等函数的语法和各种用例。</p><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>让我们从一个简单的示例开始，该示例将<a href="../%E3%80%90GolangBot%E3%80%916-%E5%87%BD%E6%95%B0">函数</a>赋值给<a href="../%E3%80%90GolangBot%E3%80%913-%E5%8F%98%E9%87%8F">变量</a>。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;hello world first class function&quot;</span>)&#125;a()fmt.Printf(<span class="hljs-string">&quot;%T&quot;</span>, a)&#125;</code></pre></div><p><a href="https://play.golang.org/p/Xm_ihamhlEv">在 Playground 中运行</a></p><p>在上面的程序中，我们在第 8 行将一个函数赋值给变量 <code>a</code>。这是将函数赋值给变量的语法。如果你仔细观察，赋值给 <code>a</code> 的函数没有名称。<strong>这种函数称为匿名函数，因为它们没有名称。</strong></p><p>调用此函数的唯一方法是使用变量 <code>a</code>。我们在下一行中完成了这一点。<code>a()</code> 调用该函数，并打印 <code>hello world first class function</code>。在第 12 行，我们打印变量 <code>a</code> 的类型。这将打印 <code>func()</code>。</p><p>运行此程序将输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">hello world first class functionfunc()</code></pre></div><p>也可以在不将匿名函数赋值给变量的情况下调用它。让我们在以下示例中看看如何做到这一点。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;hello world first class function&quot;</span>)&#125;()&#125;</code></pre></div><p><a href="https://play.golang.org/p/c0AjB3g8UEn">在 Playground 中运行</a></p><p>在上面的程序中，第 8 行定义了一个匿名函数，紧接着在函数定义之后，我们在第 10 行使用 <code>()</code> 调用该函数。该程序将输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">hello world first class function</code></pre></div><p>也可以像任何其他函数一样向匿名函数传递参数。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n <span class="hljs-type">string</span>)</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;Welcome&quot;</span>, n)&#125;(<span class="hljs-string">&quot;Gophers&quot;</span>)&#125;</code></pre></div><p><a href="https://play.golang.org/p/9ttJ5Wi4fj4">在 Playground 中运行</a></p><p>在上面的程序中，第 10 行向匿名函数传递了一个字符串参数。运行此程序将打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">Welcome Gophers</code></pre></div><h3 id="用户定义的函数类型"><a href="#用户定义的函数类型" class="headerlink" title="用户定义的函数类型"></a>用户定义的函数类型</h3><p>就像我们定义自己的<a href="../%E3%80%90GolangBot%E3%80%9116-%E7%BB%93%E6%9E%84%E4%BD%93/#%E5%A3%B0%E6%98%8E%E7%BB%93%E6%9E%84%E4%BD%93">结构体</a>类型一样，也可以定义自己的函数类型。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> add <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span></code></pre></div><p>上面的代码片段创建了一个新的函数类型 <code>add</code>，它接受两个整数参数并返回一个整数。现在我们可以定义类型为 <code>add</code> 的变量。</p><p>让我们编写一个定义类型为 <code>add</code> 的变量的程序。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> add <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> a add = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> a + b&#125;s := a(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>)fmt.Println(<span class="hljs-string">&quot;Sum&quot;</span>, s)&#125;</code></pre></div><p><a href="https://play.golang.org/p/n3yPQ7hG7ip">在 Playground 中运行</a></p><p>在上面的程序中，第 10 行我们定义了一个类型为 <code>add</code> 的变量 <code>a</code>，并为其分配了一个签名与 <code>add</code> 类型匹配的函数。我们在第 13 行调用该函数并将结果赋值给 <code>s</code>。该程序将打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">Sum 11</code></pre></div><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p><a href="https://en.wikipedia.org/wiki/Higher-order_function">维基百科</a>对高阶函数的定义是<strong>至少执行以下操作之一的函数</strong>：</p><ul><li><strong>接受一个或多个函数作为参数</strong></li><li><strong>返回一个函数作为其结果</strong></li></ul><p>让我们看一些上述两种情况的简单示例。</p><h4 id="将函数作为参数传递给其他函数"><a href="#将函数作为参数传递给其他函数" class="headerlink" title="将函数作为参数传递给其他函数"></a>将函数作为参数传递给其他函数</h4><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">simple</span><span class="hljs-params">(a <span class="hljs-keyword">func</span>(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>) &#123;fmt.Println(a(<span class="hljs-number">60</span>, <span class="hljs-number">7</span>))&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;f := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> a + b&#125;simple(f)&#125;</code></pre></div><p><a href="https://play.golang.org/p/C0MNwz2TSGU">在 Playground 中运行</a></p><p>在上面的示例中，第 7 行我们定义了一个函数 <code>simple</code>，它接受一个<em>接受两个整数参数并返回一个整数的函数</em>作为参数。在 <code>main</code> 函数中，第 12 行我们创建了一个匿名函数 <code>f</code>，其签名与 <code>simple</code> 函数的参数匹配。我们在下一行调用 <code>simple</code> 并将 <code>f</code> 作为参数传递给它。该程序输出 <code>67</code>。</p><h4 id="从其他函数返回函数"><a href="#从其他函数返回函数" class="headerlink" title="从其他函数返回函数"></a>从其他函数返回函数</h4><p>现在让我们重写上面的程序，并从 <code>simple</code> 函数返回一个函数。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">simple</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;f := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> a + b&#125;<span class="hljs-keyword">return</span> f&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;s := simple()fmt.Println(s(<span class="hljs-number">60</span>, <span class="hljs-number">7</span>))&#125;</code></pre></div><p><a href="https://play.golang.org/p/82y2caejUy8">在 Playground 中运行</a></p><p>在上面的程序中，第 7 行的 <code>simple</code> 函数返回一个接受两个 <code>int</code> 参数并返回一个 <code>int</code> 参数的函数。</p><p>在第 15 行调用 <code>simple</code> 函数。<code>simple</code> 函数的返回值赋值给 <code>s</code>。现在 <code>s</code> 包含了 <code>simple</code> 函数返回的函数。我们在第 16 行调用 <code>s</code> 并向其传递两个整数参数。该程序输出 <code>67</code>。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包是匿名函数的一种特殊情况。闭包是访问函数体外定义的变量的匿名函数。</p><p>一个示例将使事情更加清楚。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := <span class="hljs-number">5</span><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;a =&quot;</span>, a)&#125;()&#125;</code></pre></div><p><a href="https://play.golang.org/p/6QriMs-zbnf">在 Playground 中运行</a></p><p>在上面的程序中，匿名函数访问了第 10 行中存在于其主体外部的变量 <code>a</code>。因此，这个匿名函数是一个闭包。</p><p>每个闭包都绑定到其自己的周围变量。让我们通过一个简单的示例来理解这意味着什么。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">appendStr</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;t := <span class="hljs-string">&quot;Hello&quot;</span>c := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(b <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;t = t + <span class="hljs-string">&quot; &quot;</span> + b<span class="hljs-keyword">return</span> t&#125;<span class="hljs-keyword">return</span> c&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := appendStr()b := appendStr()fmt.Println(a(<span class="hljs-string">&quot;World&quot;</span>))fmt.Println(b(<span class="hljs-string">&quot;Everyone&quot;</span>))fmt.Println(a(<span class="hljs-string">&quot;Gopher&quot;</span>))fmt.Println(b(<span class="hljs-string">&quot;!&quot;</span>))&#125;</code></pre></div><p><a href="https://play.golang.org/p/134NiQGPOcS">在 Playground 中运行</a></p><p>在上面的程序中，<code>appendStr</code> 函数返回一个闭包。这个闭包绑定到变量 <code>t</code>。让我们理解这意味着什么。</p><p>第 17 行和第 18 行声明的变量 <code>a</code> 和 <code>b</code> 是闭包，它们绑定到自己的 <code>t</code> 值。</p><p>我们首先使用参数 <code>World</code> 调用 <code>a</code>。现在 <code>a</code> 的 <code>t</code> 值变为 <code>Hello World</code>。</p><p>在第 20 行，我们使用参数 <code>Everyone</code> 调用 <code>b</code>。由于 <code>b</code> 绑定到自己的变量 <code>t</code>，<code>b</code> 的 <code>t</code> 值再次初始化为 <code>Hello</code>。因此，在此函数调用之后，<code>b</code> 的 <code>t</code> 值变为 <code>Hello Everyone</code>。程序的其余部分不言自明。</p><p>该程序将打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">Hello WorldHello EveryoneHello World GopherHello Everyone !</code></pre></div><h3 id="一等函数的实际用途"><a href="#一等函数的实际用途" class="headerlink" title="一等函数的实际用途"></a>一等函数的实际用途</h3><p>到目前为止，我们已经定义了什么是一等函数，并且我们已经看到了一些人为的示例来学习它们的工作原理。现在让我们编写一个具体的程序，展示一等函数的实际用途。</p><p>我们将创建一个程序，根据某些条件过滤学生的<a href="../%E3%80%90GolangBot%E3%80%9111-%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87">切片</a>。让我们逐步解决这个问题。</p><p>首先，让我们定义 <code>student</code> 类型。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> student <span class="hljs-keyword">struct</span> &#123;firstName <span class="hljs-type">string</span>lastName  <span class="hljs-type">string</span>grade     <span class="hljs-type">string</span>country   <span class="hljs-type">string</span>&#125;</code></pre></div><p>下一步是编写 <code>filter</code> 函数。该函数接受一个学生切片和一个确定学生是否符合过滤条件的函数作为参数。一旦我们编写了这个函数，我们会更好地理解它。让我们继续编写它。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">filter</span><span class="hljs-params">(s []student, f <span class="hljs-keyword">func</span>(student)</span></span> <span class="hljs-type">bool</span>) []student &#123;<span class="hljs-keyword">var</span> r []student<span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> s &#123;<span class="hljs-keyword">if</span> f(v) == <span class="hljs-literal">true</span> &#123;r = <span class="hljs-built_in">append</span>(r, v)&#125;&#125;<span class="hljs-keyword">return</span> r&#125;</code></pre></div><p>在上面的函数中，<code>filter</code> 的第二个参数是一个函数，它接受一个 <code>student</code> 作为参数并返回一个 <code>bool</code>。该函数确定特定学生是否符合条件。我们在第 3 行遍历学生切片，并将每个学生作为参数传递给函数 <code>f</code>。如果返回 <code>true</code>，则表示该学生通过了过滤条件，并将其添加到切片 <code>r</code> 中。你可能对这个函数的实际用途感到有些困惑，但一旦我们完成程序，它就会变得清晰。我已经添加了 <code>main</code> 函数，并提供了完整的程序如下。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> student <span class="hljs-keyword">struct</span> &#123;firstName <span class="hljs-type">string</span>lastName  <span class="hljs-type">string</span>grade     <span class="hljs-type">string</span>country   <span class="hljs-type">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">filter</span><span class="hljs-params">(s []student, f <span class="hljs-keyword">func</span>(student)</span></span> <span class="hljs-type">bool</span>) []student &#123;<span class="hljs-keyword">var</span> r []student<span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> s &#123;<span class="hljs-keyword">if</span> f(v) == <span class="hljs-literal">true</span> &#123;r = <span class="hljs-built_in">append</span>(r, v)&#125;&#125;<span class="hljs-keyword">return</span> r&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;s1 := student&#123;firstName: <span class="hljs-string">&quot;Naveen&quot;</span>,lastName:  <span class="hljs-string">&quot;Ramanathan&quot;</span>,grade:     <span class="hljs-string">&quot;A&quot;</span>,country:   <span class="hljs-string">&quot;India&quot;</span>,&#125;s2 := student&#123;firstName: <span class="hljs-string">&quot;Samuel&quot;</span>,lastName:  <span class="hljs-string">&quot;Johnson&quot;</span>,grade:     <span class="hljs-string">&quot;B&quot;</span>,country:   <span class="hljs-string">&quot;USA&quot;</span>,&#125;s := []student&#123;s1, s2&#125;f := filter(s, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s student)</span></span> <span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">if</span> s.grade == <span class="hljs-string">&quot;B&quot;</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;)fmt.Println(f)&#125;</code></pre></div><p><a href="https://play.golang.org/p/YUL1CqSrvfc">在 Playground 中运行</a></p><p>在 <code>main</code> 函数中，我们首先创建两个学生 <code>s1</code> 和 <code>s2</code>，并将它们添加到切片 <code>s</code> 中。现在假设我们想找出所有成绩为 <code>B</code> 的学生。我们在上面的程序中通过传递一个检查学生成绩是否为 <code>B</code> 的函数作为 <code>filter</code> 函数的参数来实现这一点。该程序将打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">[&#123;Samuel Johnson B USA&#125;]</code></pre></div><p>假设我们想找出所有来自印度的学生。这可以通过更改 <code>filter</code> 函数的函数参数轻松实现。我提供了执行此操作的代码如下：</p><div class="code-wrapper"><pre><code class="hljs go">c := filter(s, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s student)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">if</span> s.country == <span class="hljs-string">&quot;India&quot;</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;)fmt.Println(c)</code></pre></div><p>请将此代码添加到 <code>main</code> 函数中并检查输出。</p><p>让我们通过编写另一个程序来结束本节。该程序将对切片的每个元素执行相同的操作并返回结果。例如，如果我们想将切片中的所有整数乘以 5 并返回输出，可以使用一等函数轻松完成。这种对集合的每个元素进行操作的函数称为 <code>map</code> 函数。我提供了程序如下。它是不言自明的。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">iMap</span><span class="hljs-params">(s []<span class="hljs-type">int</span>, f <span class="hljs-keyword">func</span>(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>) []<span class="hljs-type">int</span> &#123;<span class="hljs-keyword">var</span> r []<span class="hljs-type">int</span><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> s &#123;r = <span class="hljs-built_in">append</span>(r, f(v))&#125;<span class="hljs-keyword">return</span> r&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;r := iMap(a, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> n * <span class="hljs-number">5</span>&#125;)fmt.Println(r)&#125;</code></pre></div><p><a href="https://play.golang.org/p/cs37QwCQ_0H">在 Playground 中运行</a></p><p>上面的程序将打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">[25 30 35 40 45]</code></pre></div><p>以下是我们在本教程中学到的内容的快速回顾：</p><ul><li>什么是一等函数？</li><li>匿名函数</li><li>用户定义的函数类型</li><li>高阶函数<ul><li>将函数作为参数传递给其他函数</li><li>从其他函数返回函数</li></ul></li><li>闭包</li><li>一等函数的实际用途</li></ul><p><strong>下一个教程 - <a href="../%E3%80%90GolangBot%E3%80%9135-%E5%8F%8D%E5%B0%84">反射</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GolangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】33-Panic和Recover</title>
    <link href="/%E3%80%90GolangBot%E3%80%9133-Panic%E5%92%8CRecover/"/>
    <url>/%E3%80%90GolangBot%E3%80%9133-Panic%E5%92%8CRecover/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到 <a href="../golangbot/">Golang 教程系列</a> 的第 33 个教程。</p><h3 id="什么是-Panic？"><a href="#什么是-Panic？" class="headerlink" title="什么是 Panic？"></a>什么是 Panic？</h3><p>在 Go 程序中处理异常情况的惯用方法是使用<a href="../%E3%80%90GolangBot%E3%80%9130-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">错误</a>。对于大多数程序中的异常情况，错误处理已经足够。</p><p><strong>但在某些情况下，程序在异常情况发生后无法继续执行。在这种情况下，我们使用 <code>panic</code> 来提前终止程序。当一个<a href="../%E3%80%90GolangBot%E3%80%916-%E5%87%BD%E6%95%B0">函数</a>遇到 panic 时，它的执行会停止，任何<a href="../%E3%80%90GolangBot%E3%80%9129-Defer">defer</a>的函数会被执行，然后控制权返回给它的调用者。这个过程会一直持续，直到当前 <a href="../%E3%80%90GolangBot%E3%80%9121-Goroutines">goroutine</a> 的所有函数都返回，此时程序会打印 panic 消息，接着是堆栈跟踪，然后终止。</strong> 当我们编写一个示例程序时，这个概念会更加清晰。</p><p><strong>可以使用 <code>recover</code> 来恢复对 panic 程序的控制</strong>，我们将在本教程的后面部分讨论这一点。</p><p>panic 和 recover 可以看作是其他语言（如 Java）中的 try-catch-finally 习惯用法，只不过它们在 Go 中很少使用。</p><h3 id="什么时候应该使用-Panic？"><a href="#什么时候应该使用-Panic？" class="headerlink" title="什么时候应该使用 Panic？"></a>什么时候应该使用 Panic？</h3><p>一个重要的因素是，你应该尽量避免使用 panic 和 recover，尽可能使用<a href="../%E3%80%90GolangBot%E3%80%9130-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">错误处理</a>。只有在程序无法继续执行的情况下，才应该使用 panic 和 recover 机制。</p><p>panic 有两个有效的使用场景：</p><ol><li><strong>不可恢复的错误，程序无法继续执行。</strong> 一个例子是 Web 服务器无法绑定到所需的端口。在这种情况下，panic 是合理的，因为如果端口绑定本身失败，就没有其他事情可做了。</li><li><strong>程序员错误。</strong> 假设我们有一个<a href="../%E3%80%90GolangBot%E3%80%9117-%E6%96%B9%E6%B3%95">方法</a>接受一个指针作为参数，而有人使用 <code>nil</code> 参数调用此方法。在这种情况下，我们可以 panic，因为使用 <code>nil</code> 参数调用期望有效指针的方法是程序员的错误。</li></ol><h3 id="Panic-示例"><a href="#Panic-示例" class="headerlink" title="Panic 示例"></a>Panic 示例</h3><p>内置 <code>panic</code> 函数的签名如下：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">panic</span><span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span></code></pre></div><p>传递给 panic 函数的参数将在程序终止时打印出来。当我们编写示例程序时，这一点会更加清楚。让我们马上编写一个示例程序。</p><p>我们将从一个展示 panic 如何工作的简单示例开始。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fullName</span><span class="hljs-params">(firstName *<span class="hljs-type">string</span>, lastName *<span class="hljs-type">string</span>)</span></span> &#123;<span class="hljs-keyword">if</span> firstName == <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;runtime error: first name cannot be nil&quot;</span>)&#125;<span class="hljs-keyword">if</span> lastName == <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;runtime error: last name cannot be nil&quot;</span>)&#125;fmt.Printf(<span class="hljs-string">&quot;%s %s\n&quot;</span>, *firstName, *lastName)fmt.Println(<span class="hljs-string">&quot;returned normally from fullName&quot;</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;firstName := <span class="hljs-string">&quot;Elon&quot;</span>fullName(&amp;firstName, <span class="hljs-literal">nil</span>)fmt.Println(<span class="hljs-string">&quot;returned normally from main&quot;</span>)&#125;</code></pre></div><p><a href="https://play.golang.org/p/xQJYRSCu8S">在 Playground 中运行</a></p><p>上面的程序是一个打印人名的全名的简单程序。第 7 行的 <code>fullName</code> 函数打印一个人的全名。该函数分别在第 8 行和第 11 行检查 <code>firstName</code> 和 <code>lastName</code> 指针是否为 <code>nil</code>。如果是 <code>nil</code>，函数会调用 <code>panic</code> 并传递相应的消息。此消息将在程序终止时打印。</p><p>运行此程序将打印以下输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">panic: runtime error: last name cannot be nilgoroutine 1 [running]:main.fullName(0xc00006af58, 0x0)/tmp/sandbox210590465/prog.go:12 +0x193main.main()/tmp/sandbox210590465/prog.go:20 +0x4d</code></pre></div><p>让我们分析这个输出，以了解 panic 的工作原理以及程序 panic 时如何打印堆栈跟踪。</p><p>在第 19 行，我们将 <code>Elon</code> 赋值给 <code>firstName</code>。我们在第 20 行调用 <code>fullName</code> 函数，并将 <code>lastName</code> 设置为 <code>nil</code>。因此，第 11 行的条件将满足，程序将 panic。当遇到 panic 时，程序执行终止，传递给 panic 函数的参数会被打印，然后是堆栈跟踪。由于程序在第 12 行的 panic 函数调用后终止，第 13、14 和 15 行的代码将不会执行。</p><p>该程序首先打印传递给 <code>panic</code> 函数的消息：</p><div class="code-wrapper"><pre><code class="hljs fallback">panic: runtime error: last name cannot be nil</code></pre></div><p>然后打印堆栈跟踪。</p><p>程序在第 12 行的 <code>fullName</code> 函数中 panic，因此：</p><div class="code-wrapper"><pre><code class="hljs fallback">goroutine 1 [running]:main.fullName(0xc00006af58, 0x0)/tmp/sandbox210590465/prog.go:12 +0x193</code></pre></div><p>将首先打印。然后打印堆栈中的下一个项目。在我们的例子中，第 20 行调用 <code>fullName</code> 的地方是堆栈跟踪中的下一个项目。因此，接下来会打印它。</p><div class="code-wrapper"><pre><code class="hljs fallback">main.main()/tmp/sandbox210590465/prog.go:20 +0x4d</code></pre></div><p>现在我们已经到达了导致 panic 的顶层函数，并且没有更多的层级，因此没有更多内容可打印。</p><h3 id="另一个示例"><a href="#另一个示例" class="headerlink" title="另一个示例"></a>另一个示例</h3><p>panic 也可能由运行时发生的错误引起，例如尝试访问切片中不存在的索引。</p><p>让我们编写一个由于切片越界访问而导致 panic 的示例。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">slicePanic</span><span class="hljs-params">()</span></span> &#123;n := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>&#125;fmt.Println(n[<span class="hljs-number">4</span>])fmt.Println(<span class="hljs-string">&quot;normally returned from a&quot;</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;slicePanic()fmt.Println(<span class="hljs-string">&quot;normally returned from main&quot;</span>)&#125;</code></pre></div><p><a href="https://play.golang.org/p/__PAabvchxt">在 Playground 中运行</a></p><p>在上面的程序中，第 9 行我们尝试访问 <code>n[4]</code>，这是<a href="../%E3%80%90GolangBot%E3%80%9111-%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87">切片</a>中的无效索引。该程序将 panic，并输出以下内容：</p><div class="code-wrapper"><pre><code class="hljs fallback">panic: runtime error: index out of range [4] with length 3goroutine 1 [running]:main.slicePanic()/tmp/sandbox942516049/prog.go:9 +0x1dmain.main()/tmp/sandbox942516049/prog.go:13 +0x22</code></pre></div><h3 id="Panic-期间的-Defer-调用"><a href="#Panic-期间的-Defer-调用" class="headerlink" title="Panic 期间的 Defer 调用"></a>Panic 期间的 Defer 调用</h3><p>让我们回顾一下 panic 的作用。<strong>当一个函数遇到 panic 时，它的执行会停止，任何延迟的函数会被执行，然后控制权返回给它的调用者。这个过程会一直持续，直到当前 goroutine 的所有函数都返回，此时程序会打印 panic 消息，接着是堆栈跟踪，然后终止。</strong></p><p>在上面的示例中，我们没有延迟任何函数调用。如果存在延迟的函数调用，它会被执行，然后控制权返回给它的调用者。</p><p>让我们稍微修改上面的示例并使用 defer 语句。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fullName</span><span class="hljs-params">(firstName *<span class="hljs-type">string</span>, lastName *<span class="hljs-type">string</span>)</span></span> &#123;<span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;deferred call in fullName&quot;</span>)<span class="hljs-keyword">if</span> firstName == <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;runtime error: first name cannot be nil&quot;</span>)&#125;<span class="hljs-keyword">if</span> lastName == <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;runtime error: last name cannot be nil&quot;</span>)&#125;fmt.Printf(<span class="hljs-string">&quot;%s %s\n&quot;</span>, *firstName, *lastName)fmt.Println(<span class="hljs-string">&quot;returned normally from fullName&quot;</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;deferred call in main&quot;</span>)firstName := <span class="hljs-string">&quot;Elon&quot;</span>fullName(&amp;firstName, <span class="hljs-literal">nil</span>)fmt.Println(<span class="hljs-string">&quot;returned normally from main&quot;</span>)&#125;</code></pre></div><p><a href="https://play.golang.org/p/oUFnu-uTmC">在 Playground 中运行</a></p><p>唯一的更改是在第 8 行和第 20 行添加了延迟函数调用。</p><p>该程序打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">deferred call in fullNamedeferred call in mainpanic: runtime error: last name cannot be nilgoroutine 1 [running]:main.fullName(0xc00006af28, 0x0)/tmp/sandbox451943841/prog.go:13 +0x23fmain.main()/tmp/sandbox451943841/prog.go:22 +0xc6</code></pre></div><p>当程序在第 13 行 panic 时，首先执行任何延迟的函数调用，然后控制权返回给调用者，调用者的延迟调用被执行，依此类推，直到到达顶层调用者。</p><p>在我们的例子中，<code>fullName</code> 函数第 8 行的 <code>defer</code> 语句首先执行。这会打印以下消息：</p><div class="code-wrapper"><pre><code class="hljs fallback">deferred call in fullName</code></pre></div><p>然后控制权返回到 <code>main</code> 函数，其延迟调用被执行，因此打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">deferred call in main</code></pre></div><p>现在控制权已经到达顶层函数，因此程序会打印 panic 消息，接着是堆栈跟踪，然后终止。</p><h3 id="从-Panic-中恢复"><a href="#从-Panic-中恢复" class="headerlink" title="从 Panic 中恢复"></a>从 Panic 中恢复</h3><p><em>recover</em> 是一个内置函数，用于恢复对 panic 程序的控制。</p><p>recover 函数的签名如下：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">recover</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">interface</span>&#123;&#125;</code></pre></div><p>recover 只有在延迟函数内部调用时才有用。在延迟函数内部执行 recover 调用会通过恢复正常执行来停止 panic 序列，并检索传递给 panic 函数调用的错误消息。如果在延迟函数外部调用 recover，它将不会停止 panic 序列。</p><p>让我们修改我们的程序并使用 recover 在 panic 后恢复正常执行。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">recoverFullName</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">if</span> r := <span class="hljs-built_in">recover</span>(); r != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;recovered from &quot;</span>, r)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fullName</span><span class="hljs-params">(firstName *<span class="hljs-type">string</span>, lastName *<span class="hljs-type">string</span>)</span></span> &#123;<span class="hljs-keyword">defer</span> recoverFullName()<span class="hljs-keyword">if</span> firstName == <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;runtime error: first name cannot be nil&quot;</span>)&#125;<span class="hljs-keyword">if</span> lastName == <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;runtime error: last name cannot be nil&quot;</span>)&#125;fmt.Printf(<span class="hljs-string">&quot;%s %s\n&quot;</span>, *firstName, *lastName)fmt.Println(<span class="hljs-string">&quot;returned normally from fullName&quot;</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;deferred call in main&quot;</span>)firstName := <span class="hljs-string">&quot;Elon&quot;</span>fullName(&amp;firstName, <span class="hljs-literal">nil</span>)fmt.Println(<span class="hljs-string">&quot;returned normally from main&quot;</span>)&#125;</code></pre></div><p><a href="https://play.golang.org/p/enCM-dd5DUr">在 Playground 中运行</a></p><p>第 7 行的 <code>recoverFullName()</code> 函数调用 <code>recover()</code>，它返回传递给 <code>panic</code> 函数调用的值。在这里，我们只是打印 recover 返回的值。<code>recoverFullName()</code> 在第 14 行的 <code>fullName</code> 函数中被延迟。</p><p>当 <code>fullName</code> panic 时，延迟函数 <code>recoverName()</code> 将被调用，它使用 <code>recover()</code> 来停止 panic 序列。</p><p>该程序将打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">recovered from  runtime error: last name cannot be nilreturned normally from maindeferred call in main</code></pre></div><p>当程序在第 19 行 panic 时，延迟的 <code>recoverFullName</code> 函数被调用，它反过来调用 <code>recover()</code> 来恢复对 panic 序列的控制。第 8 行的 <code>recover()</code> 调用返回传递给 <code>panic()</code> 的参数，因此打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">recovered from  runtime error: last name cannot be nil</code></pre></div><p>在执行 <code>recover()</code> 后，panic 停止，控制权返回给调用者，在本例中是 <code>main</code> 函数。由于 panic 已恢复，程序从 <code>main</code> 的第 29 行继续正常执行 😃。它打印 <code>returned normally from main</code>，然后是 <code>deferred call in main</code>。</p><p>让我们再看一个示例，我们从由于访问切片的无效索引引起的 panic 中恢复。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">recoverInvalidAccess</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">if</span> r := <span class="hljs-built_in">recover</span>(); r != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;Recovered&quot;</span>, r)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">invalidSliceAccess</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">defer</span> recoverInvalidAccess()n := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>&#125;fmt.Println(n[<span class="hljs-number">4</span>])fmt.Println(<span class="hljs-string">&quot;normally returned from a&quot;</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;invalidSliceAccess()fmt.Println(<span class="hljs-string">&quot;normally returned from main&quot;</span>)&#125;</code></pre></div><p><a href="https://play.golang.org/p/Bth98An9Ah0">在 Playground 中运行</a></p><p>运行上面的程序将输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">Recovered runtime error: index out of range [4] with length 3normally returned from main</code></pre></div><p>从输出中可以看出，我们已经从 panic 中恢复。</p><h3 id="恢复后获取堆栈跟踪"><a href="#恢复后获取堆栈跟踪" class="headerlink" title="恢复后获取堆栈跟踪"></a>恢复后获取堆栈跟踪</h3><p>如果我们从 panic 中恢复，我们会丢失有关 panic 的堆栈跟踪。即使在上面的程序恢复后，我们也丢失了堆栈跟踪。</p><p>有一种方法可以使用 Debug <a href="../%E3%80%90GolangBot%E3%80%917-%E5%8C%85">包</a>的 <a href="https://golang.org/pkg/runtime/debug/#PrintStack">PrintStack</a> 函数打印堆栈跟踪。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;runtime/debug&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">recoverFullName</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">if</span> r := <span class="hljs-built_in">recover</span>(); r != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;recovered from &quot;</span>, r)debug.PrintStack()&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fullName</span><span class="hljs-params">(firstName *<span class="hljs-type">string</span>, lastName *<span class="hljs-type">string</span>)</span></span> &#123;<span class="hljs-keyword">defer</span> recoverFullName()<span class="hljs-keyword">if</span> firstName == <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;runtime error: first name cannot be nil&quot;</span>)&#125;<span class="hljs-keyword">if</span> lastName == <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;runtime error: last name cannot be nil&quot;</span>)&#125;fmt.Printf(<span class="hljs-string">&quot;%s %s\n&quot;</span>, *firstName, *lastName)fmt.Println(<span class="hljs-string">&quot;returned normally from fullName&quot;</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;deferred call in main&quot;</span>)firstName := <span class="hljs-string">&quot;Elon&quot;</span>fullName(&amp;firstName, <span class="hljs-literal">nil</span>)fmt.Println(<span class="hljs-string">&quot;returned normally from main&quot;</span>)&#125;</code></pre></div><p><a href="https://play.golang.org/p/9VxcG4Gt-MU">在 Playground 中运行</a></p><p>在上面的程序中，我们在第 11 行使用 <code>debug.PrintStack()</code> 来打印堆栈跟踪。</p><p>该程序将打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">recovered from  runtime error: last name cannot be nilgoroutine 1 [running]:runtime/debug.Stack(0x37, 0x0, 0x0)/usr/local/go-faketime/src/runtime/debug/stack.go:24 +0x9druntime/debug.PrintStack()/usr/local/go-faketime/src/runtime/debug/stack.go:16 +0x22main.recoverFullName()/tmp/sandbox771195810/prog.go:11 +0xb4panic(0x4a1b60, 0x4dc300)/usr/local/go-faketime/src/runtime/panic.go:969 +0x166main.fullName(0xc0000a2f28, 0x0)/tmp/sandbox771195810/prog.go:21 +0x1cbmain.main()/tmp/sandbox771195810/prog.go:30 +0xc6returned normally from maindeferred call in main</code></pre></div><p>从输出中可以看出，panic 已恢复，并打印了 <code>recovered from runtime error: last name cannot be nil</code>。接着打印堆栈跟踪。然后：</p><div class="code-wrapper"><pre><code class="hljs fallback">returned normally from maindeferred call in main</code></pre></div><p>在 panic 恢复后打印。</p><h3 id="Panic、Recover-和-Goroutines"><a href="#Panic、Recover-和-Goroutines" class="headerlink" title="Panic、Recover 和 Goroutines"></a>Panic、Recover 和 Goroutines</h3><p>recover 只有在从发生 panic 的同一个 <a href="../%E3%80%90GolangBot%E3%80%9121-Goroutines">goroutine</a> 中调用时才有效。<strong>无法从不同 goroutine 中发生的 panic 中恢复。</strong> 让我们通过一个示例来理解这一点。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">recovery</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">if</span> r := <span class="hljs-built_in">recover</span>(); r != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;recovered:&quot;</span>, r)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> &#123;<span class="hljs-keyword">defer</span> recovery()fmt.Printf(<span class="hljs-string">&quot;%d + %d = %d\n&quot;</span>, a, b, a+b)done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<span class="hljs-keyword">go</span> divide(a, b, done)&lt;-done&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">divide</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>, done <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;%d / %d = %d&quot;</span>, a, b, a/b)done &lt;- <span class="hljs-literal">true</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;sum(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>)fmt.Println(<span class="hljs-string">&quot;normally returned from main&quot;</span>)&#125;</code></pre></div><p><a href="https://play.golang.org/p/yCPL_4lqbzk">在 Playground 中运行</a></p><p>在上面的程序中，<code>divide()</code> 函数将在第 22 行 panic，因为 <code>b</code> 为零，无法将数字除以零。<code>sum()</code> 函数调用了一个延迟函数 <code>recovery()</code>，用于从 panic 中恢复。<code>divide()</code> 函数在第 17 行作为一个单独的 goroutine 被调用。我们在第 18 行等待 <code>done</code> <a href="../GolangBot%E3%80%9122-Channels">通道</a>以确保 <code>divide()</code> 完成执行。</p><p>你认为程序的输出会是什么？panic 会被恢复吗？答案是否定的。panic 不会被恢复。这是因为 <code>recovery</code> 函数存在于不同的 goroutine 中，而 panic 发生在 <code>divide()</code> 函数中的不同 goroutine 中。因此，无法恢复。</p><p>运行此程序将打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">5 + 0 = 5panic: runtime error: integer divide by zerogoroutine 18 [running]:main.divide(0x5, 0x0, 0xc0000a2000)/tmp/sandbox877118715/prog.go:22 +0x167created by main.sum/tmp/sandbox877118715/prog.go:17 +0x1a9</code></pre></div><p>从输出中可以看出，恢复没有发生。</p><p>如果 <code>divide()</code> 函数在同一个 goroutine 中被调用，我们将能够从 panic 中恢复。</p><p>如果将程序的第 17 行从：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">go</span> divide(a, b, done)</code></pre></div><p>更改为：</p><div class="code-wrapper"><pre><code class="hljs go">divide(a, b, done)</code></pre></div><p>恢复将会发生，因为 panic 发生在同一个 goroutine 中。如果程序使用上述更改运行，它将打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">5 + 0 = 5recovered: runtime error: integer divide by zeronormally returned from main</code></pre></div><p>本教程到此结束。</p><p>以下是我们在本教程中学到的内容的快速回顾：</p><ul><li>什么是 Panic？</li><li>什么时候应该使用 Panic？</li><li>Panic 使用示例</li><li>Panic 期间的 Defer 调用</li><li>从 Panic 中恢复</li><li>恢复后获取堆栈跟踪</li><li>Panic、Recover 和 Goroutines</li></ul><p><strong>下一个教程 - <a href="../%E3%80%90GolangBot%E3%80%9134-%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91%EF%BC%9A%E5%87%BD%E6%95%B0">一等公民：函数</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GolangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】32-错误包装</title>
    <link href="/%E3%80%90GolangBot%E3%80%9132-%E9%94%99%E8%AF%AF%E5%8C%85%E8%A3%85/"/>
    <url>/%E3%80%90GolangBot%E3%80%9132-%E9%94%99%E8%AF%AF%E5%8C%85%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到 <a href="../golangbot/">Golang 教程系列</a> 的第 32 个教程。</p><p>在本教程中，我们将学习 Go 中的错误包装以及为什么我们需要错误包装。让我们开始吧。</p><h3 id="什么是错误包装？"><a href="#什么是错误包装？" class="headerlink" title="什么是错误包装？"></a>什么是错误包装？</h3><p>错误包装是将一个错误封装到另一个错误中的过程。假设我们有一个访问数据库并尝试从数据库中获取记录的 Web 服务器。如果数据库调用返回错误，我们可以决定是否包装此错误或从 Web 服务发送我们自己的自定义错误。让我们编写一个小程序来理解这一点。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;errors&quot;</span><span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">var</span> noRows = errors.New(<span class="hljs-string">&quot;no rows found&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getRecord</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<span class="hljs-keyword">return</span> noRows&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">webService</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<span class="hljs-keyword">if</span> err := getRecord(); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;Error %s when calling DB&quot;</span>, err)&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">if</span> err := webService(); err != <span class="hljs-literal">nil</span> &#123;fmt.Printf(<span class="hljs-string">&quot;Error: %s when calling webservice\n&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;fmt.Println(<span class="hljs-string">&quot;webservice call successful&quot;</span>)&#125;</code></pre></div><p><a href="https://go.dev/play/p/0kVGzdt47GW">在 Playground 中运行</a></p><p>在上面的程序中，在第 16 行，我们发送了调用 <code>getRecord</code> 函数时发生的错误的字符串描述。虽然这看起来像是错误包装，但实际上并不是 :)。让我们在下一节中了解如何包装错误。</p><h3 id="错误包装和-Is-函数"><a href="#错误包装和-Is-函数" class="headerlink" title="错误包装和 Is 函数"></a>错误包装和 Is 函数</h3><p><a href="https://pkg.go.dev/errors">errors</a> 包中的 <a href="https://pkg.go.dev/errors#Is">Is</a> 函数报告错误链中的任何错误是否与目标匹配。在我们的例子中，我们在第 11 行从 <code>getRecord</code> 函数返回 <code>noRows</code> 错误。在第 16 行从 <code>webService</code> 函数返回此错误的字符串格式。让我们修改此程序的 <code>main</code> 函数，并使用 <code>Is</code> 函数检查错误链中的任何错误是否与 <code>noRows</code> 错误匹配。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">if</span> err := webService(); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">if</span> errors.Is(err, noRows) &#123;fmt.Printf(<span class="hljs-string">&quot;The searched record cannot be found. Error returned from DB is %s&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;fmt.Println(<span class="hljs-string">&quot;unknown error when searching record&quot;</span>)<span class="hljs-keyword">return</span>&#125;fmt.Println(<span class="hljs-string">&quot;webservice call successful&quot;</span>)&#125;</code></pre></div><p>在上面的 <code>main</code> 函数中，在第 3 行，<code>Is</code> 函数将检查 <code>err</code> 持有的错误链中的任何错误是否包含 <code>noRows</code> 错误。当前状态的代码将不起作用，并且上述 <code>main</code> 函数第 3 行的 <code>if</code> 条件将失败。为了使其工作，我们需要在从 <code>webService</code> 函数返回时包装 <code>noRows</code> 错误。一种方法是在返回错误时使用 <code>%w</code> 格式说明符而不是 <code>%s</code>。因此，如果我们将返回错误的行修改为：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;Error %w when calling DB&quot;</span>, err)</code></pre></div><p>这意味着新返回的错误包装了原始的 <code>noRows</code>，并且上述 <code>main</code> 函数第 3 行的 <code>if</code> 条件将成功。带有错误包装的完整程序如下。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;errors&quot;</span><span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">var</span> noRows = errors.New(<span class="hljs-string">&quot;no rows found&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getRecord</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<span class="hljs-keyword">return</span> noRows&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">webService</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<span class="hljs-keyword">if</span> err := getRecord(); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;Error %w when calling DB&quot;</span>, err)&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">if</span> err := webService(); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">if</span> errors.Is(err, noRows) &#123;fmt.Printf(<span class="hljs-string">&quot;The searched record cannot be found. Error returned from DB is %s&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;fmt.Println(<span class="hljs-string">&quot;unknown error when searching record&quot;</span>)<span class="hljs-keyword">return</span>&#125;fmt.Println(<span class="hljs-string">&quot;webservice call successful&quot;</span>)&#125;</code></pre></div><p><a href="https://go.dev/play/p/t0h3WtJ5fu5">在 Playground 中运行</a></p><p>运行此程序时，它将打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">The searched record cannot be found. Error returned from DB is Error no rows found when calling DB</code></pre></div><h3 id="As-函数"><a href="#As-函数" class="headerlink" title="As 函数"></a>As 函数</h3><p><a href="https://pkg.go.dev/errors">errors</a> 包中的 <a href="https://pkg.go.dev/errors#As">As</a> 函数将尝试将作为输入传递的错误转换为目标错误类型。如果错误链中的任何错误与目标匹配，它将成功。如果成功，它将返回 true，并将目标设置为错误链中与目标匹配的第一个错误。一个程序将使事情更容易理解 :)</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;errors&quot;</span><span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> DBError <span class="hljs-keyword">struct</span> &#123;desc <span class="hljs-type">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dbError DBError)</span></span> Error() <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">return</span> dbError.desc&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getRecord</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<span class="hljs-keyword">return</span> DBError&#123;desc: <span class="hljs-string">&quot;no rows found&quot;</span>,&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">webService</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<span class="hljs-keyword">if</span> err := getRecord(); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;Error %w when calling DB&quot;</span>, err)&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">if</span> err := webService(); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">var</span> dbError DBError<span class="hljs-keyword">if</span> errors.As(err, &amp;dbError) &#123;fmt.Printf(<span class="hljs-string">&quot;The searched record cannot be found. Error returned from DB is %s&quot;</span>, dbError)<span class="hljs-keyword">return</span>&#125;fmt.Println(<span class="hljs-string">&quot;unknown error when searching record&quot;</span>)<span class="hljs-keyword">return</span>&#125;fmt.Println(<span class="hljs-string">&quot;webservice call successful&quot;</span>)&#125;</code></pre></div><p><a href="https://go.dev/play/p/I268pAa4NyR">在 Playground 中运行</a></p><p>在上面的程序中，我们修改了第 16 行的 <code>getRecord</code> 函数，以返回类型为 <code>DBError</code> 的<a href="../%E3%80%90GolangBot%E3%80%9131-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF">自定义错误</a>。</p><p>在 <code>main</code> 函数的第 32 行，我们尝试将从 <code>webService()</code> 函数调用返回的错误转换为 <code>DBError</code> 类型。第 32 行的 <code>if</code> 语句将成功，因为我们在第 24 行从 <code>webService()</code> 函数返回错误时包装了 <code>DBError</code>。运行此程序将打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">The searched record cannot be found. Error returned from DB is no rows found</code></pre></div><h3 id="我们应该包装错误吗？"><a href="#我们应该包装错误吗？" class="headerlink" title="我们应该包装错误吗？"></a>我们应该包装错误吗？</h3><p>这个问题的答案是，视情况而定。如果我们包装错误，我们将其暴露给我们的库&#x2F;函数的调用者。我们通常不希望包装包含函数内部实现细节的错误。另一个需要记住的重要事情是，如果我们返回一个包装的错误，然后决定删除错误包装，使用我们库的代码将开始失败。因此，包装的错误应被视为 API 的一部分，如果我们决定修改返回的错误，则应进行适当的版本更改。</p><p><strong>下一个教程 - <a href="../%E3%80%90GolangBot%E3%80%9133-Panic%E5%92%8CRecover">Panic 和 Recover</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GolangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】31-自定义错误</title>
    <link href="/%E3%80%90GolangBot%E3%80%9131-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF/"/>
    <url>/%E3%80%90GolangBot%E3%80%9131-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到 <a href="../golangbot/">Golang 教程系列</a> 的第 31 个教程。</p><p>在<a href="../%E3%80%90GolangBot%E3%80%9130-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">上一个教程</a>中，我们学习了 Go 中错误的表示方式以及如何处理标准库中的错误。我们还学习了如何从错误中提取更多信息。</p><p>本教程将介绍如何创建我们自己的自定义错误，以便在我们的函数和包中使用。我们还将使用标准库采用的相同技术来提供有关自定义错误的更多详细信息。</p><h3 id="使用-New-函数创建自定义错误"><a href="#使用-New-函数创建自定义错误" class="headerlink" title="使用 New 函数创建自定义错误"></a>使用 New 函数创建自定义错误</h3><p>创建自定义错误的最简单方法是使用 <a href="https://pkg.go.dev/errors">errors</a> 包的 <a href="https://pkg.go.dev/errors#New">New</a> 函数。</p><p>在我们使用 New <a href="../%E3%80%90GolangBot%E3%80%916-%E5%87%BD%E6%95%B0">函数</a>创建自定义错误之前，让我们先了解它的实现方式。<a href="https://go.dev/src/errors/errors.go?s=293:320#L58">errors 包</a>中 New 函数的实现如下：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> errors<span class="hljs-comment">// New 返回一个将给定文本格式化为错误的错误。</span><span class="hljs-comment">// 即使文本相同，每次调用 New 都会返回一个不同的错误值。</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(text <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;    <span class="hljs-keyword">return</span> &amp;errorString&#123;text&#125;&#125;<span class="hljs-comment">// errorString 是 error 的一个简单实现。</span><span class="hljs-keyword">type</span> errorString <span class="hljs-keyword">struct</span> &#123;    s <span class="hljs-type">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *errorString)</span></span> Error() <span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">return</span> e.s&#125;</code></pre></div><p>实现非常简单。<code>errorString</code> 是一个具有单个字符串字段 <code>s</code> 的<a href="../%E3%80%90GolangBot%E3%80%9116-%E7%BB%93%E6%9E%84%E4%BD%93">结构体</a>类型。<code>error</code> 接口的 <code>Error() string</code> <a href="../%E3%80%90GolangBot%E3%80%9117-%E6%96%B9%E6%B3%95">方法</a>使用 <code>errorString</code> 的<a href="../%E3%80%90GolangBot%E3%80%9117-%E6%96%B9%E6%B3%95/#%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E8%80%85%E4%B8%8E%E5%80%BC%E6%8E%A5%E6%94%B6%E8%80%85">指针接收者</a>在第 14 行实现。</p><p>第 5 行的 <code>New</code> 函数接受一个 <code>string</code> 参数，使用该参数创建一个 <code>errorString</code> 类型的值，并返回其地址。因此，一个新的错误被创建并返回。</p><p>现在我们知道 <code>New</code> 函数的工作原理了，让我们在自己的程序中使用它来创建一个自定义错误。</p><p>我们将创建一个简单的程序来计算圆的面积，并在半径为负时返回错误。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;errors&quot;</span><span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;math&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">circleArea</span><span class="hljs-params">(radius <span class="hljs-type">float64</span>)</span></span> (<span class="hljs-type">float64</span>, <span class="hljs-type">error</span>) &#123;<span class="hljs-keyword">if</span> radius &lt; <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, errors.New(<span class="hljs-string">&quot;Area calculation failed, radius is less than zero&quot;</span>)&#125;<span class="hljs-keyword">return</span> math.Pi * radius * radius, <span class="hljs-literal">nil</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;radius := <span class="hljs-number">-20.0</span>area, err := circleArea(radius)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(err)<span class="hljs-keyword">return</span>&#125;fmt.Printf(<span class="hljs-string">&quot;Area of circle %0.2f&quot;</span>, area)&#125;</code></pre></div><p><a href="https://go.dev/play/p/_vuf6fgkqm">在 Playground 中运行</a></p><p>在上面的程序中，我们在第 10 行检查半径是否小于零。如果是，我们返回面积为 0 以及相应的错误消息。如果半径大于 0，则计算面积并在第 13 行返回 <code>nil</code> 作为错误。</p><p>在主函数中，我们在第 19 行检查错误是否为 <code>nil</code>。如果不是 <code>nil</code>，我们打印错误并返回，否则打印圆的面积。</p><p>在这个程序中，半径小于零，因此它将打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">Area calculation failed, radius is less than zero</code></pre></div><h3 id="使用-Errorf-为错误添加更多信息"><a href="#使用-Errorf-为错误添加更多信息" class="headerlink" title="使用 Errorf 为错误添加更多信息"></a>使用 Errorf 为错误添加更多信息</h3><p>上面的程序运行良好，但如果能打印导致错误的实际半径岂不是更好？这就是 <a href="https://pkg.go.dev/fmt">fmt</a> 包的 <a href="https://pkg.go.dev/fmt#Errorf">Errorf</a> 函数的用武之地。该函数根据格式说明符格式化错误，并返回一个满足 <code>error</code> 接口的<a href="../%E3%80%90GolangBot%E3%80%9114-Strings">字符串</a>值。</p><p>让我们使用 <code>Errorf</code> 函数并使程序更好。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;math&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">circleArea</span><span class="hljs-params">(radius <span class="hljs-type">float64</span>)</span></span> (<span class="hljs-type">float64</span>, <span class="hljs-type">error</span>) &#123;<span class="hljs-keyword">if</span> radius &lt; <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, fmt.Errorf(<span class="hljs-string">&quot;Area calculation failed, radius %0.2f is less than zero&quot;</span>, radius)&#125;<span class="hljs-keyword">return</span> math.Pi * radius * radius, <span class="hljs-literal">nil</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;radius := <span class="hljs-number">-20.0</span>area, err := circleArea(radius)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(err)<span class="hljs-keyword">return</span>&#125;fmt.Printf(<span class="hljs-string">&quot;Area of circle %0.2f&quot;</span>, area)&#125;</code></pre></div><p><a href="https://go.dev/play/p/HQ7bvjT4o2">在 Playground 中运行</a></p><p>在上面的程序中，<code>Errorf</code> 在第 10 行用于打印导致错误的实际半径。运行该程序将输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">Area calculation failed, radius -20.00 is less than zero</code></pre></div><h3 id="使用结构体类型和字段为错误提供更多信息"><a href="#使用结构体类型和字段为错误提供更多信息" class="headerlink" title="使用结构体类型和字段为错误提供更多信息"></a>使用结构体类型和字段为错误提供更多信息</h3><p>也可以使用实现 error <a href="../%E3%80%90GolangBot%E3%80%9118-%E6%8E%A5%E5%8F%A3-I">接口</a>的结构体类型作为错误。这为错误处理提供了更大的灵活性。在我们之前的示例中，如果我们想访问导致错误的半径，唯一的方法是解析错误描述 <code>Area calculation failed, radius -20.00 is less than zero</code>。这不是一个合适的方式，因为如果描述发生变化，我们的代码将会崩溃。</p><p>我们将使用上一教程中“<a href="../%E3%80%90GolangBot%E3%80%9130-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/#1-%E5%B0%86%E9%94%99%E8%AF%AF%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%BA%95%E5%B1%82%E7%B1%BB%E5%9E%8B%E5%B9%B6%E4%BB%8E%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E6%AE%B5%E4%B8%AD%E6%A3%80%E7%B4%A2%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">将错误转换为底层类型并从结构体字段中检索更多信息</a>”部分中描述的策略，并使用结构体字段来提供对导致错误的半径的访问。我们将创建一个实现 error 接口的结构体类型，并使用其字段来提供有关错误的更多信息。</p><p>第一步是创建一个表示错误的结构体类型。错误类型的命名约定是名称应以文本 <code>Error</code> 结尾。因此，我们将我们的结构体类型命名为 <code>areaError</code>。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> areaError <span class="hljs-keyword">struct</span> &#123;err    <span class="hljs-type">string</span>radius <span class="hljs-type">float64</span>&#125;</code></pre></div><p>上述结构体类型有一个 <code>radius</code> 字段，用于存储导致错误的半径值，<code>err</code> 字段存储实际的错误消息。</p><p>下一步是实现 error 接口。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *areaError)</span></span> Error() <span class="hljs-type">string</span> &#123;      <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;radius %0.2f: %s&quot;</span>, e.radius, e.err)&#125;</code></pre></div><p>在上面的代码片段中，我们使用指针接收者 <code>*areaError</code> 实现了 error 接口的 <code>Error() string</code> 方法。此方法打印半径和错误描述。</p><p>让我们通过编写 <code>main</code> 函数和 <code>circleArea</code> 函数来完成程序。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;errors&quot;</span><span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;math&quot;</span>)<span class="hljs-keyword">type</span> areaError <span class="hljs-keyword">struct</span> &#123;err    <span class="hljs-type">string</span>radius <span class="hljs-type">float64</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *areaError)</span></span> Error() <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;radius %0.2f: %s&quot;</span>, e.radius, e.err)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">circleArea</span><span class="hljs-params">(radius <span class="hljs-type">float64</span>)</span></span> (<span class="hljs-type">float64</span>, <span class="hljs-type">error</span>) &#123;<span class="hljs-keyword">if</span> radius &lt; <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, &amp;areaError&#123;err:    <span class="hljs-string">&quot;radius is negative&quot;</span>,radius: radius,&#125;&#125;<span class="hljs-keyword">return</span> math.Pi * radius * radius, <span class="hljs-literal">nil</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;radius := <span class="hljs-number">-20.0</span>area, err := circleArea(radius)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">var</span> areaError *areaError<span class="hljs-keyword">if</span> errors.As(err, &amp;areaError) &#123;fmt.Printf(<span class="hljs-string">&quot;Area calculation failed, radius %0.2f is less than zero&quot;</span>, areaError.radius)<span class="hljs-keyword">return</span>&#125;fmt.Println(err)<span class="hljs-keyword">return</span>&#125;fmt.Printf(<span class="hljs-string">&quot;Area of rectangle %0.2f&quot;</span>, area)&#125;</code></pre></div><p><a href="https://go.dev/play/p/X4GvrehVTGA">在 Playground 中运行</a></p><p>在上面的程序中，<code>circleArea</code> 函数在第 18 行用于计算圆的面积。该函数首先检查半径是否小于零，如果是，则使用导致错误的半径和相应的错误消息创建一个 <code>areaError</code> 类型的值，然后在第 20 行返回其地址以及面积为 0。<strong>因此，我们使用自定义错误结构体的字段提供了有关错误的更多信息，在这种情况下是导致错误的半径。</strong></p><p>如果半径不为负，则此函数计算并返回面积，并在第 25 行返回 <code>nil</code> 错误。</p><p>在主函数的第 30 行，我们尝试计算半径为 -20 的圆的面积。由于半径小于零，将返回错误。</p><p>我们在第 31 行检查错误是否为 <code>nil</code>，并在第 33 行尝试将其转换为 <code>*areaError</code> 类型。<strong>如果错误是 <code>*areaError</code> 类型，我们在第 34 行使用 <code>areaError.radius</code> 获取导致错误的半径，打印自定义错误消息并从程序返回。</strong></p><p>如果错误不是 <code>*areaError</code> 类型，我们只需在第 37 行打印错误并返回。如果没有错误，则会在第 40 行打印面积。</p><p>该程序将打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">Area calculation failed, radius -20.00 is less than zero</code></pre></div><p>现在让我们使用上一教程中描述的<a href="../%E3%80%90GolangBot%E3%80%9130-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/#2-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%A3%80%E7%B4%A2%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">第二种策略</a>，并在自定义错误类型上使用方法以提供有关错误的更多信息。</p><h3 id="使用结构体类型上的方法为错误提供更多信息"><a href="#使用结构体类型上的方法为错误提供更多信息" class="headerlink" title="使用结构体类型上的方法为错误提供更多信息"></a>使用结构体类型上的方法为错误提供更多信息</h3><p>在本节中，我们将编写一个计算矩形面积的程序。如果长度或宽度小于零，该程序将打印错误。</p><p>第一步是创建一个表示错误的结构体。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> areaError <span class="hljs-keyword">struct</span> &#123;err    <span class="hljs-type">string</span> <span class="hljs-comment">//错误描述</span>length <span class="hljs-type">float64</span> <span class="hljs-comment">//导致错误的长度</span>width  <span class="hljs-type">float64</span> <span class="hljs-comment">//导致错误的宽度</span>&#125;</code></pre></div><p>上述错误结构体类型包含一个错误描述字段以及导致错误的长度和宽度。</p><p>现在我们有了错误类型，让我们实现 error 接口，并在错误类型上添加一些方法以提供有关错误的更多信息。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *areaError)</span></span> Error() <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">return</span> e.err&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *areaError)</span></span> lengthNegative() <span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">return</span> e.length &lt; <span class="hljs-number">0</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *areaError)</span></span> widthNegative() <span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">return</span> e.width &lt; <span class="hljs-number">0</span>&#125;</code></pre></div><p>在上面的代码片段中，我们从 <code>Error() string</code> 方法返回错误的描述。<code>lengthNegative() bool</code> 方法在长度小于零时返回 true，<code>widthNegative() bool</code> 方法在宽度小于零时返回 true。<strong>这两种方法提供了有关错误的更多信息，在这种情况下，它们表明面积计算失败是由于长度为负还是宽度为负。因此，我们使用了结构体错误类型上的方法来提供有关错误的更多信息。</strong></p><p>下一步是编写面积计算函数。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rectArea</span><span class="hljs-params">(length, width <span class="hljs-type">float64</span>)</span></span> (<span class="hljs-type">float64</span>, <span class="hljs-type">error</span>) &#123;err := <span class="hljs-string">&quot;&quot;</span><span class="hljs-keyword">if</span> length &lt; <span class="hljs-number">0</span> &#123;err += <span class="hljs-string">&quot;length is less than zero&quot;</span>&#125;<span class="hljs-keyword">if</span> width &lt; <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">if</span> err == <span class="hljs-string">&quot;&quot;</span> &#123;err = <span class="hljs-string">&quot;width is less than zero&quot;</span>&#125; <span class="hljs-keyword">else</span> &#123;err += <span class="hljs-string">&quot;, width is less than zero&quot;</span>&#125;&#125;<span class="hljs-keyword">if</span> err != <span class="hljs-string">&quot;&quot;</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, &amp;areaError&#123;err:    err,length: length,width:  width,&#125;&#125;<span class="hljs-keyword">return</span> length * width, <span class="hljs-literal">nil</span>&#125;</code></pre></div><p>上面的 <code>rectArea</code> 函数检查长度或宽度是否小于零，如果是，则返回 <code>*areaError</code> 类型的错误，否则返回矩形的面积并将 <code>nil</code> 作为错误。</p><p>让我们通过创建主函数来完成这个程序。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;length, width := <span class="hljs-number">-5.0</span>, <span class="hljs-number">-9.0</span>area, err := rectArea(length, width)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">var</span> areaError *areaError<span class="hljs-keyword">if</span> errors.As(err, &amp;areaError) &#123;<span class="hljs-keyword">if</span> areaError.lengthNegative() &#123;fmt.Printf(<span class="hljs-string">&quot;error: length %0.2f is less than zero\n&quot;</span>, areaError.length)&#125;<span class="hljs-keyword">if</span> areaError.widthNegative() &#123;fmt.Printf(<span class="hljs-string">&quot;error: width %0.2f is less than zero\n&quot;</span>, areaError.width)&#125;<span class="hljs-keyword">return</span>&#125;fmt.Println(err)<span class="hljs-keyword">return</span>&#125;fmt.Println(<span class="hljs-string">&quot;area of rect&quot;</span>, area)&#125;</code></pre></div><p>在主函数中，我们在第 4 行检查错误是否为 <code>nil</code>。如果不是 nil，我们尝试将其转换为 <code>*areaError</code> 类型。然后使用 <code>lengthNegative()</code> 和 <code>widthNegative()</code> 方法，我们检查错误是否是由于长度为负或宽度为负。我们打印相应的错误消息并从程序返回。<strong>因此，我们使用了错误结构体类型上的方法来提供有关错误的更多信息。</strong></p><p>如果没有错误，将打印矩形的面积。</p><p>以下是完整的程序供您参考。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;errors&quot;</span><span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> areaError <span class="hljs-keyword">struct</span> &#123;err    <span class="hljs-type">string</span>  <span class="hljs-comment">//错误描述</span>length <span class="hljs-type">float64</span> <span class="hljs-comment">//导致错误的长度</span>width  <span class="hljs-type">float64</span> <span class="hljs-comment">//导致错误的宽度</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *areaError)</span></span> Error() <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">return</span> e.err&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *areaError)</span></span> lengthNegative() <span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">return</span> e.length &lt; <span class="hljs-number">0</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *areaError)</span></span> widthNegative() <span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">return</span> e.width &lt; <span class="hljs-number">0</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rectArea</span><span class="hljs-params">(length, width <span class="hljs-type">float64</span>)</span></span> (<span class="hljs-type">float64</span>, <span class="hljs-type">error</span>) &#123;err := <span class="hljs-string">&quot;&quot;</span><span class="hljs-keyword">if</span> length &lt; <span class="hljs-number">0</span> &#123;err += <span class="hljs-string">&quot;length is less than zero&quot;</span>&#125;<span class="hljs-keyword">if</span> width &lt; <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">if</span> err == <span class="hljs-string">&quot;&quot;</span> &#123;err = <span class="hljs-string">&quot;width is less than zero&quot;</span>&#125; <span class="hljs-keyword">else</span> &#123;err += <span class="hljs-string">&quot;, width is less than zero&quot;</span>&#125;&#125;<span class="hljs-keyword">if</span> err != <span class="hljs-string">&quot;&quot;</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, &amp;areaError&#123;err:    err,length: length,width:  width,&#125;&#125;<span class="hljs-keyword">return</span> length * width, <span class="hljs-literal">nil</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;length, width := <span class="hljs-number">-5.0</span>, <span class="hljs-number">-9.0</span>area, err := rectArea(length, width)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">var</span> areaError *areaError<span class="hljs-keyword">if</span> errors.As(err, &amp;areaError) &#123;<span class="hljs-keyword">if</span> areaError.lengthNegative() &#123;fmt.Printf(<span class="hljs-string">&quot;error: length %0.2f is less than zero\n&quot;</span>, areaError.length)&#125;<span class="hljs-keyword">if</span> areaError.widthNegative() &#123;fmt.Printf(<span class="hljs-string">&quot;error: width %0.2f is less than zero\n&quot;</span>, areaError.width)&#125;<span class="hljs-keyword">return</span>&#125;fmt.Println(err)<span class="hljs-keyword">return</span>&#125;fmt.Println(<span class="hljs-string">&quot;area of rect&quot;</span>, area)&#125;</code></pre></div><p><a href="https://go.dev/play/p/9xxF9fVw1fe">在 Playground 中运行</a></p><p>该程序将输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">error: length -5.00 is less than zeroerror: width -9.00 is less than zero</code></pre></div><p>我们已经看到了在<a href="../%E3%80%90GolangBot%E3%80%9130-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/">错误处理</a>教程中描述的三种方式中的两种示例，以提供有关错误的更多信息。</p><p>第三种方式使用<a href="../%E3%80%90GolangBot%E3%80%9130-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/#3-%E7%9B%B4%E6%8E%A5%E6%AF%94%E8%BE%83">直接比较</a>非常简单。我将把它留作练习，让您弄清楚如何使用此策略来提供有关我们自定义错误的更多信息。</p><p>本教程到此结束。</p><p>以下是我们在本教程中学到的内容的快速回顾：</p><ul><li>使用 New 函数创建自定义错误</li><li>使用 Errorf 为错误添加更多信息</li><li>使用结构体类型和字段为错误提供更多信息</li><li>使用结构体类型上的方法为错误提供更多信息</li></ul><p><strong>下一个教程 - <a href="../_posts/%E3%80%90GolangBot%E3%80%9132-%E9%94%99%E8%AF%AF%E5%8C%85%E8%A3%85">错误包装</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GolangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】30-错误处理</title>
    <link href="/%E3%80%90GolangBot%E3%80%9130-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
    <url>/%E3%80%90GolangBot%E3%80%9130-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到 <a href="../golangbot/">Golang 教程系列</a> 的第 30 个教程。</p><h3 id="什么是错误？"><a href="#什么是错误？" class="headerlink" title="什么是错误？"></a>什么是错误？</h3><p>错误表示程序中发生的任何异常情况。假设我们尝试打开一个文件，而该文件在文件系统中不存在。这是一种异常情况，它被表示为一个错误。</p><p>在 Go 中，错误是普通的值。就像任何其他内置<a href="../%E3%80%90GolangBot%E3%80%914-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">类型</a>（如 <code>int</code>、<code>float64</code> 等）一样，错误值可以存储在<a href="../%E3%80%90GolangBot%E3%80%913-%E5%8F%98%E9%87%8F">变量</a>中，作为参数传递给函数，从<a href="../%E3%80%90GolangBot%E3%80%916-%E5%87%BD%E6%95%B0">函数</a>中返回，等等。</p><p>错误使用内置的 <code>error</code> 类型表示。我们将在本教程的后面部分了解更多关于 <code>error</code> 类型的内容。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>让我们从一个尝试打开不存在的文件的示例程序开始。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;os&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;f, err := os.Open(<span class="hljs-string">&quot;/test.txt&quot;</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(err)<span class="hljs-keyword">return</span>&#125;fmt.Println(f.Name(), <span class="hljs-string">&quot;opened successfully&quot;</span>)&#125;</code></pre></div><p><a href="https://go.dev/play/p/yOhAviFM05">在 Playground 中运行</a></p><p>在上面的程序的第 9 行，我们尝试打开路径为 <code>/test.txt</code> 的文件（显然在 Playground 中不存在）。<code>os</code> 包的 <em><a href="https://pkg.go.dev/os#Open">Open</a></em> 函数的签名如下：</p><p><strong>func Open(name string) (*File, error)</strong></p><p>如果文件成功打开，<code>Open</code> 函数将返回文件句柄，并且错误为 <code>nil</code>。如果在打开文件时发生错误，将返回一个非 <code>nil</code> 的错误。</p><p>如果一个<a href="../%E3%80%90GolangBot%E3%80%916-%E5%87%BD%E6%95%B0">函数</a>或<a href="../%E3%80%90GolangBot%E3%80%9117-%E6%96%B9%E6%B3%95">方法</a>返回一个错误，按照惯例，它应该是函数返回的最后一个值。因此，<code>Open</code> 函数将 <code>error</code> 作为最后一个值返回。</p><p><strong>在 Go 中处理错误的惯用方法是将返回的错误与 <code>nil</code> 进行比较。<code>nil</code> 值表示没有发生错误，非 <code>nil</code> 值表示存在错误。</strong> 在我们的例子中，我们在第 10 行检查错误是否为 <code>nil</code>。如果不是 <code>nil</code>，我们只需打印错误并从主函数返回。</p><p>运行该程序将输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">open /test.txt: No such file or directory</code></pre></div><p>完美 😃。我们得到了一个错误，指出文件不存在。</p><h3 id="错误类型的表示"><a href="#错误类型的表示" class="headerlink" title="错误类型的表示"></a>错误类型的表示</h3><p>让我们深入一点，看看内置的 <code>error</code> 类型是如何定义的。<code>error</code> 是一个<a href="../%E3%80%90GolangBot%E3%80%9118-%E6%8E%A5%E5%8F%A3-I">接口</a>类型，其定义如下：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> <span class="hljs-type">error</span> <span class="hljs-keyword">interface</span> &#123;    Error() <span class="hljs-type">string</span>&#125;</code></pre></div><p>它包含一个签名 <code>Error() string</code> 的方法。任何实现此接口的类型都可以用作错误。此方法提供了错误的描述。</p><p>当打印错误时，<code>fmt.Println</code> 函数内部调用 <code>Error() string</code> 方法来获取错误的描述。这就是上面的<a href="../%E3%80%90GolangBot%E3%80%9130-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/#%E7%A4%BA%E4%BE%8B">示例程序</a>中第 11 行打印错误描述的方式。</p><h3 id="从错误中提取更多信息的不同方式"><a href="#从错误中提取更多信息的不同方式" class="headerlink" title="从错误中提取更多信息的不同方式"></a>从错误中提取更多信息的不同方式</h3><p>既然我们知道 <code>error</code> 是一个接口类型，让我们看看如何从错误中提取更多信息。</p><p>在上面看到的<a href="../%E3%80%90GolangBot%E3%80%9130-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/#%E7%A4%BA%E4%BE%8B">示例</a>中，我们只是打印了错误的描述。如果我们想要导致错误的文件的实际路径怎么办？一种可能的方法是解析错误字符串。这是我们程序的输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">open /test.txt: No such file or directory</code></pre></div><p><em>我们可以解析此错误消息并获取导致错误的文件路径“&#x2F;test.txt”，但这是一个不太优雅的方式。错误描述可能会在 Go 的新版本中随时更改，我们的代码将会崩溃。</em></p><p>有没有更好的方法来获取文件名 🤔？答案是肯定的，可以通过 Go 标准库提供的不同方式来实现。让我们逐一看看。</p><h4 id="1-将错误转换为底层类型并从结构体字段中检索更多信息"><a href="#1-将错误转换为底层类型并从结构体字段中检索更多信息" class="headerlink" title="1. 将错误转换为底层类型并从结构体字段中检索更多信息"></a>1. 将错误转换为底层类型并从结构体字段中检索更多信息</h4><p>如果你仔细阅读 <a href="https://pkg.go.dev/os#Open">Open</a> 函数的文档，你会发现它返回一个 <code>*PathError</code> 类型的错误。<a href="https://pkg.go.dev/os#PathError">PathError</a> 是一个<a href="../%E3%80%90GolangBot%E3%80%9116-%E7%BB%93%E6%9E%84%E4%BD%93">结构体</a>类型，其标准库中的实现如下：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> PathError <span class="hljs-keyword">struct</span> &#123;    Op   <span class="hljs-type">string</span>    Path <span class="hljs-type">string</span>    Err  <span class="hljs-type">error</span>&#125;  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *PathError)</span></span> Error() <span class="hljs-type">string</span> &#123; <span class="hljs-keyword">return</span> e.Op + <span class="hljs-string">&quot; &quot;</span> + e.Path + <span class="hljs-string">&quot;: &quot;</span> + e.Err.Error() &#125;</code></pre></div><p>如果你有兴趣了解上述源代码的位置，可以在这里找到：<a href="https://cs.opensource.google/go/go/+/refs/tags/go1.19:src/io/fs/fs.go;l=250">https://cs.opensource.google/go/go/+/refs/tags/go1.19:src/io/fs/fs.go;l=250</a></p><p>从上面的代码中，你可以理解 <code>*PathError</code> 通过声明 <code>Error() string</code> 方法实现了 <code>error</code> 接口。此方法将操作、路径和实际错误连接起来并返回。因此我们得到了错误消息：</p><div class="code-wrapper"><pre><code class="hljs fallback">open /test.txt: No such file or directory</code></pre></div><p><code>PathError</code> 结构体的 <code>Path</code> 字段包含导致错误的文件路径。</p><p>我们可以使用 <code>errors</code> 包中的 <a href="https://pkg.go.dev/errors#As">As</a> 函数将错误转换为其底层类型。<code>As</code> 函数的描述提到了错误链。现在请忽略它。我们将在<a href="../%E3%80%90GolangBot%E3%80%9132-%E9%94%99%E8%AF%AF%E5%8C%85%E8%A3%85">单独的教程</a>中了解错误链和包装的工作原理。<code>As</code> 的简单描述是，它尝试将错误转换为错误类型，并返回 <code>true</code> 或 <code>false</code>，指示转换是否成功。</p><p>一个程序会让事情更清楚。让我们修改上面编写的程序，并使用 <code>As</code> 函数打印路径。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;errors&quot;</span><span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;os&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;f, err := os.Open(<span class="hljs-string">&quot;test.txt&quot;</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">var</span> pErr *os.PathError<span class="hljs-keyword">if</span> errors.As(err, &amp;pErr) &#123;fmt.Println(<span class="hljs-string">&quot;Failed to open file at path&quot;</span>, pErr.Path)<span class="hljs-keyword">return</span>&#125;fmt.Println(<span class="hljs-string">&quot;Generic error&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;fmt.Println(f.Name(), <span class="hljs-string">&quot;opened successfully&quot;</span>)&#125;</code></pre></div><p><a href="https://go.dev/play/p/znhBV-QC7Nk">在 Playground 中运行</a></p><p>在上面的程序中，我们首先在第 11 行检查错误是否为 <code>nil</code>，然后在第 13 行使用 <code>As</code> 函数将 <code>err</code> 转换为 <code>*os.PathError</code>。如果转换成功，<code>As</code> 将返回 <code>true</code>。然后我们在第 14 行使用 <code>pErr.Path</code> 打印路径。</p><p>如果你想知道为什么 <code>pErr</code> 是一个指针，原因是 <code>error</code> 接口由 <code>PathError</code> 的指针实现，因此 <code>pErr</code> 是一个指针。以下代码显示 <code>*PathError</code> 实现了 <code>error</code> 接口。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *PathError)</span></span> Error() <span class="hljs-type">string</span> &#123; <span class="hljs-keyword">return</span> e.Op + <span class="hljs-string">&quot; &quot;</span> + e.Path + <span class="hljs-string">&quot;: &quot;</span> + e.Err.Error() &#125;</code></pre></div><p><code>As</code> 函数要求第二个参数是指向实现 <code>error</code> 的类型的指针。因此我们传递 <code>&amp;pErr</code>。</p><p>该程序输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">Failed to open file at path test.txt</code></pre></div><p>如果底层错误不是 <code>*os.PathError</code> 类型，控制将到达第 17 行，并打印一个通用错误消息。</p><p>太棒了 😃。我们成功地使用 <code>As</code> 函数从错误中获取了文件路径。</p><h4 id="2-使用方法检索更多信息"><a href="#2-使用方法检索更多信息" class="headerlink" title="2. 使用方法检索更多信息"></a>2. 使用方法检索更多信息</h4><p>从错误中获取更多信息的第二种方法是找出底层类型，并通过调用<a href="../%E3%80%90GolangBot%E3%80%9116-%E7%BB%93%E6%9E%84%E4%BD%93">结构体</a>类型的<a href="../%E3%80%90GolangBot%E3%80%9117-%E6%96%B9%E6%B3%95">方法</a>来获取更多信息。</p><p>让我们通过一个例子更好地理解这一点。</p><p>标准库中的 <em><a href="https://golang.org/pkg/net/#DNSError">DNSError</a></em> 结构体类型定义如下：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> DNSError <span class="hljs-keyword">struct</span> &#123;    ...&#125;  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *DNSError)</span></span> Error() <span class="hljs-type">string</span> &#123;    ...&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *DNSError)</span></span> Timeout() <span class="hljs-type">bool</span> &#123;     ... &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *DNSError)</span></span> Temporary() <span class="hljs-type">bool</span> &#123;     ... &#125;</code></pre></div><p><code>DNSError</code> 结构体有两个方法 <code>Timeout() bool</code> 和 <code>Temporary() bool</code>，它们返回一个布尔值，指示错误是否是由于超时或是否是临时错误。</p><p>让我们编写一个程序，将错误转换为 <code>*DNSError</code> 类型，并调用上述方法来确定错误是临时的还是由于超时。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;errors&quot;</span><span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;net&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;addr, err := net.LookupHost(<span class="hljs-string">&quot;golangbot123.com&quot;</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">var</span> dnsErr *net.DNSError<span class="hljs-keyword">if</span> errors.As(err, &amp;dnsErr) &#123;<span class="hljs-keyword">if</span> dnsErr.Timeout() &#123;fmt.Println(<span class="hljs-string">&quot;operation timed out&quot;</span>)<span class="hljs-keyword">return</span>&#125;<span class="hljs-keyword">if</span> dnsErr.Temporary() &#123;fmt.Println(<span class="hljs-string">&quot;temporary error&quot;</span>)<span class="hljs-keyword">return</span>&#125;fmt.Println(<span class="hljs-string">&quot;Generic DNS error&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;fmt.Println(<span class="hljs-string">&quot;Generic error&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;fmt.Println(addr)&#125;</code></pre></div><p><em>注意：DNS 查找在 Playground 中不起作用。请在本地机器上运行此程序。</em></p><p>在上面的程序中，我们在第 9 行尝试获取无效域名 <code>golangbot123.com</code> 的 IP 地址。在第 13 行，我们使用 <code>As</code> 函数获取错误的底层值，并将其转换为 <code>*net.DNSError</code>。然后我们在第 14 行和第 18 行分别检查错误是否是由于超时或临时错误。</p><p>在我们的例子中，错误既不是<em>临时</em>的，也不是由于<em>超时</em>，因此程序将打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">Generic DNS error lookup golangbot123.com: no such host</code></pre></div><p>如果错误是临时的或由于超时，则相应的 <code>if</code> 语句将执行，我们可以适当地处理它。</p><h4 id="3-直接比较"><a href="#3-直接比较" class="headerlink" title="3. 直接比较"></a>3. 直接比较</h4><p>从错误中获取更多详细信息的第三种方法是直接与 <code>error</code> 类型的变量进行比较。让我们通过一个例子来理解这一点。</p><p><code>filepath</code> 包的 <a href="https://golang.org/pkg/path/filepath/#Glob">Glob</a> 函数用于返回与模式匹配的所有文件的名称。当模式格式错误时，此函数返回错误 <code>ErrBadPattern</code>。</p><p><em>ErrBadPattern</em> 在 <code>filepath</code> 包中定义为一个全局变量。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ErrBadPattern = errors.New(<span class="hljs-string">&quot;syntax error in pattern&quot;</span>)</code></pre></div><p><code>errors.New()</code> 用于创建一个新的错误。我们将在<a href="../%E3%80%90GolangBot%E3%80%9132-%E9%94%99%E8%AF%AF%E5%8C%85%E8%A3%85">下一个教程</a>中详细讨论这一点。</p><p>当模式格式错误时，<code>Glob</code> 函数返回 <em>ErrBadPattern</em>。</p><p>让我们编写一个小程序来检查此错误。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;errors&quot;</span><span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;path/filepath&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;files, err := filepath.Glob(<span class="hljs-string">&quot;[&quot;</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">if</span> errors.Is(err, filepath.ErrBadPattern) &#123;fmt.Println(<span class="hljs-string">&quot;Bad pattern error:&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;fmt.Println(<span class="hljs-string">&quot;Generic error:&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;fmt.Println(<span class="hljs-string">&quot;matched files&quot;</span>, files)&#125;</code></pre></div><p><a href="https://go.dev/play/p/_JLFsjIPBuw">在 Playground 中运行</a></p><p>在上面的程序中，我们搜索模式为 <code>[</code> 的文件，这是一个格式错误的模式。我们检查错误是否为 <code>nil</code>。为了获取有关错误的更多信息，我们使用 <a href="https://pkg.go.dev/errors#Is">Is</a> 函数在第 11 行直接将其与 <code>filepath.ErrBadPattern</code> 进行比较。与 <code>As</code> 类似，<code>Is</code> 函数在错误链上工作。我们将在<a href="https://golangbot.com/custom-errors/">下一个教程</a>中了解更多信息。在本教程中，可以将 <code>Is</code> 函数视为在两个错误相同时返回 <code>true</code>。</p><p>由于错误是由于格式错误的模式引起的，<code>Is</code> 在第 12 行返回 <code>true</code>。该程序将打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">Bad pattern error: syntax error in pattern</code></pre></div><p>标准库使用上述任何一种方式来提供有关错误的更多信息。我们将在下一个教程中使用这些方式来创建我们自己的<a href="https://golangbot.com/custom-errors/">自定义错误</a>。</p><h3 id="不要忽略错误"><a href="#不要忽略错误" class="headerlink" title="不要忽略错误"></a>不要忽略错误</h3><p>永远不要忽略错误。忽略错误是在自找麻烦。让我重写<a href="https://go.dev/play/p/_JLFsjIPBuw">示例</a>，该示例列出了与模式匹配的所有文件的名称，同时忽略错误。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;path/filepath&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;files, _ := filepath.Glob(<span class="hljs-string">&quot;[&quot;</span>)fmt.Println(<span class="hljs-string">&quot;matched files&quot;</span>, files)&#125;</code></pre></div><p><a href="https://play.golang.org/p/2k8r_Qg_lc">在 Playground 中运行</a></p><p>我们从<a href="https://play.golang.org/p/KqhxmlLVFT6">上一个示例</a>中知道模式是无效的。我在第 9 行使用 <code>_</code> 空白标识符忽略了 <code>Glob</code> 函数返回的错误。我只是在第 10 行打印匹配的文件。该程序将打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">matched files []</code></pre></div><p>由于我们忽略了错误，输出看起来好像没有文件匹配模式，但实际上模式本身是格式错误的。所以永远不要忽略错误。</p><p>本教程到此结束。</p><p>在本教程中，我们讨论了如何处理程序中发生的错误，以及如何检查错误以从中获取更多信息。以下是我们在本教程中讨论的内容的快速回顾：</p><ul><li>什么是错误？</li><li>错误的表示</li><li>从错误中提取更多信息的不同方式</li><li>不要忽略错误</li></ul><p>在<a href="../%E3%80%90GolangBot%E3%80%9131-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF">下一个教程</a>中，我们将创建自己的自定义错误，并为我们的自定义错误添加上下文。</p><p><strong>下一个教程 - <a href="../%E3%80%90GolangBot%E3%80%9131-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF">自定义错误</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GolangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】29-Defer</title>
    <link href="/%E3%80%90GolangBot%E3%80%9129-Defer/"/>
    <url>/%E3%80%90GolangBot%E3%80%9129-Defer/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到 <a href="../golangbot/">Golang 教程系列</a> 的第 29 个教程。</p><h3 id="什么是-Defer？"><a href="#什么是-Defer？" class="headerlink" title="什么是 Defer？"></a>什么是 Defer？</h3><p><strong>Defer 语句用于在包含它的函数返回之前执行一个<a href="../%E3%80%90GolangBot%E3%80%916-%E5%87%BD%E6%95%B0">函数</a>调用。</strong> 这个定义可能看起来有些复杂，但通过一个例子会很容易理解。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">totalTime</span><span class="hljs-params">(start time.Time)</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;Total time taken %f seconds&quot;</span>, time.Since(start).Seconds())&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> &#123;start := time.Now()<span class="hljs-keyword">defer</span> totalTime(start)time.Sleep(<span class="hljs-number">2</span> * time.Second)fmt.Println(<span class="hljs-string">&quot;Sleep complete&quot;</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;test()&#125;</code></pre></div><p><a href="https://go.dev/play/p/5RgaRZ1Cj_h">在 Playground 中运行</a></p><p>上面的程序是一个简单的示例，展示了 <code>defer</code> 的用法。在这个程序中，<code>defer</code> 用于计算 <code>test()</code> 函数的执行时间。<code>test()</code> 函数的开始时间作为参数传递给 <code>defer totalTime(start)</code>（第 14 行）。这个 <code>defer</code> 调用会在 <code>test()</code> 返回之前执行。<code>totalTime</code> 函数使用 <code>time.Since</code> 计算 <code>start</code> 和当前时间的差值并打印（第 9 行）。为了模拟 <code>test()</code> 中的一些计算操作，我们在第 15 行添加了一个 2 秒的 <code>sleep</code>。</p><p>运行该程序会输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">Sleep completeTotal time taken 2.000000 seconds</code></pre></div><p>输出结果与 2 秒的 <code>sleep</code> 相符。在 <code>test()</code> 函数返回之前，<code>totalTime</code> 被调用并打印了 <code>test()</code> 执行的总时间。</p><h3 id="参数评估"><a href="#参数评估" class="headerlink" title="参数评估"></a>参数评估</h3><p>延迟函数的参数在 <code>defer</code> 语句执行时评估，而不是在实际函数调用时评估。</p><p>让我们通过一个例子来理解这一点。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">displayValue</span><span class="hljs-params">(a <span class="hljs-type">int</span>)</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;value of a in deferred function&quot;</span>, a)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := <span class="hljs-number">5</span><span class="hljs-keyword">defer</span> displayValue(a)a = <span class="hljs-number">10</span>fmt.Println(<span class="hljs-string">&quot;value of a before deferred function call&quot;</span>, a)&#125;</code></pre></div><p><a href="https://go.dev/play/p/K5UMFy1FAxg">在 Playground 中运行</a></p><p>在上面的程序中，<code>a</code> 的初始值为 <code>5</code>（第 11 行）。当 <code>defer</code> 语句在第 12 行执行时，<code>a</code> 的值为 <code>5</code>，因此这将是传递给 <code>displayValue</code> 函数的参数。我们在第 13 行将 <code>a</code> 的值更改为 <code>10</code>。下一行打印 <code>a</code> 的值。该程序输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">value of a before deferred function call 10value of a in deferred function 5</code></pre></div><p>从上面的输出可以看出，尽管 <code>a</code> 的值在 <code>defer</code> 语句执行后变为 <code>10</code>，但实际的延迟函数调用 <code>displayValue(a)</code> 仍然打印 <code>5</code>。</p><h3 id="延迟方法"><a href="#延迟方法" class="headerlink" title="延迟方法"></a>延迟方法</h3><p><code>defer</code> 不仅限于<a href="../%E3%80%90GolangBot%E3%80%916-%E5%87%BD%E6%95%B0">函数</a>，也可以用于延迟<a href="../%E3%80%90GolangBot%E3%80%9117-%E6%96%B9%E6%B3%95">方法</a>调用。让我们编写一个小程序来测试这一点。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> person <span class="hljs-keyword">struct</span> &#123;firstName <span class="hljs-type">string</span>lastName  <span class="hljs-type">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p person)</span></span> fullName() &#123;fmt.Printf(<span class="hljs-string">&quot;%s %s&quot;</span>, p.firstName, p.lastName)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;p := person&#123;firstName: <span class="hljs-string">&quot;John&quot;</span>,lastName:  <span class="hljs-string">&quot;Smith&quot;</span>,&#125;<span class="hljs-keyword">defer</span> p.fullName()fmt.Printf(<span class="hljs-string">&quot;Welcome &quot;</span>)&#125;</code></pre></div><p><a href="https://go.dev/play/p/0rTbGqe0p4l">在 Playground 中运行</a></p><p>在上面的程序中，我们在第 21 行延迟了一个方法调用。程序的其余部分不言自明。该程序输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">Welcome John Smith</code></pre></div><h3 id="多个-Defer-调用按栈顺序执行"><a href="#多个-Defer-调用按栈顺序执行" class="headerlink" title="多个 Defer 调用按栈顺序执行"></a>多个 Defer 调用按栈顺序执行</h3><p>当一个函数有多个 <code>defer</code> 调用时，它们会被推入一个栈中，并按后进先出（LIFO）的顺序执行。</p><p>我们将编写一个小程序，使用 <code>defer</code> 栈来逆序打印字符串。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;str := <span class="hljs-string">&quot;Gopher&quot;</span>fmt.Printf(<span class="hljs-string">&quot;Original String: %s\n&quot;</span>, <span class="hljs-type">string</span>(str))fmt.Printf(<span class="hljs-string">&quot;Reversed String: &quot;</span>)<span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> str &#123;<span class="hljs-keyword">defer</span> fmt.Printf(<span class="hljs-string">&quot;%c&quot;</span>, v)&#125;&#125;</code></pre></div><p><a href="https://go.dev/play/p/E28utiyg7Oj">在 Playground 中运行</a></p><p>在上面的程序中，第 11 行的 <code>for range</code> 循环遍历字符串，并在第 12 行调用 <code>defer fmt.Printf(&quot;%c&quot;, v)</code>。这些延迟调用将被添加到一个栈中。</p><p><img src="https://golangbot.com/content/defer/stack-of-defers.png" alt="stack of defers"></p><p>上面的图像表示 <code>defer</code> 调用被添加到栈后的内容。<a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)">栈</a>是一种后进先出的数据结构。最后推入栈的 <code>defer</code> 调用将首先被弹出并执行。在这种情况下，<code>defer fmt.Printf(&quot;%c&quot;, &#39;n&#39;)</code> 将首先执行，因此字符串将逆序打印。</p><p>该程序将输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">Original String: GopherReversed String: rehpoG</code></pre></div><h3 id="Defer-的实际用途"><a href="#Defer-的实际用途" class="headerlink" title="Defer 的实际用途"></a>Defer 的实际用途</h3><p>在本节中，我们将探讨 <code>defer</code> 的一些实际用途。</p><p><code>defer</code> 用于在代码流中无论发生什么情况都应执行函数调用的地方。让我们通过一个使用 <a href="../%E3%80%90GolangBot%E3%80%9123-%E7%BC%93%E5%86%B2%E9%80%9A%E9%81%93%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%B1%A0/#waitgroup">WaitGroup</a> 的程序来理解这一点。我们首先编写一个不使用 <code>defer</code> 的程序，然后修改它以使用 <code>defer</code>，并理解 <code>defer</code> 的实用性。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;sync&quot;</span>)<span class="hljs-keyword">type</span> rect <span class="hljs-keyword">struct</span> &#123;length <span class="hljs-type">int</span>width  <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r rect)</span></span> area(wg *sync.WaitGroup) &#123;<span class="hljs-keyword">if</span> r.length &lt; <span class="hljs-number">0</span> &#123;fmt.Printf(<span class="hljs-string">&quot;rect %v&#x27;s length should be greater than zero\n&quot;</span>, r)wg.Done()<span class="hljs-keyword">return</span>&#125;<span class="hljs-keyword">if</span> r.width &lt; <span class="hljs-number">0</span> &#123;fmt.Printf(<span class="hljs-string">&quot;rect %v&#x27;s width should be greater than zero\n&quot;</span>, r)wg.Done()<span class="hljs-keyword">return</span>&#125;area := r.length * r.widthfmt.Printf(<span class="hljs-string">&quot;rect %v&#x27;s area %d\n&quot;</span>, r, area)wg.Done()&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> wg sync.WaitGroupr1 := rect&#123;<span class="hljs-number">-67</span>, <span class="hljs-number">89</span>&#125;r2 := rect&#123;<span class="hljs-number">5</span>, <span class="hljs-number">-67</span>&#125;r3 := rect&#123;<span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;rects := []rect&#123;r1, r2, r3&#125;<span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> rects &#123;wg.Add(<span class="hljs-number">1</span>)<span class="hljs-keyword">go</span> v.area(&amp;wg)&#125;wg.Wait()fmt.Println(<span class="hljs-string">&quot;All go routines finished executing&quot;</span>)&#125;</code></pre></div><p><a href="https://go.dev/play/p/1Wg8k__JcUy">在 Playground 中运行</a></p><p>在上面的程序中，我们在第 8 行创建了一个 <code>rect</code> 结构体，并在第 13 行定义了一个 <code>area</code> 方法，用于计算矩形的面积。该方法检查矩形的长度和宽度是否小于零。如果是，则打印相应的错误消息，否则打印矩形的面积。</p><p><code>main</code> 函数创建了三个 <code>rect</code> 类型的变量 <code>r1</code>、<code>r2</code> 和 <code>r3</code>。它们在第 34 行被添加到 <code>rects</code> 切片中。然后使用 <code>for range</code> 循环遍历该切片，并在第 37 行将 <code>area</code> 方法作为并发 <a href="../%E3%80%90GolangBot%E3%80%9121-Goroutines">Goroutine</a> 调用。<a href="../%E3%80%90GolangBot%E3%80%9123-%E7%BC%93%E5%86%B2%E9%80%9A%E9%81%93%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%B1%A0/#waitgroup">WaitGroup</a> <code>wg</code> 用于确保主函数等待所有 Goroutine 执行完毕。这个 WaitGroup 作为参数传递给 <code>area</code> 方法，<code>area</code> 方法在第 16、21 和 26 行调用 <code>wg.Done()</code>，以通知主函数 Goroutine 已完成其工作。<em>如果你仔细观察，你会发现这些调用发生在 <code>area</code> 方法返回之前。无论代码流采取什么路径，<code>wg.Done()</code> 都应在方法返回之前调用，因此这些调用可以有效地替换为单个 <code>defer</code> 调用。</em></p><p>让我们使用 <code>defer</code> 重写上面的程序。</p><p>在下面的程序中，我们删除了上面程序中的三个 <code>wg.Done()</code> 调用，并在第 14 行替换为单个 <code>defer wg.Done()</code> 调用。这使得代码更简洁和易读。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;sync&quot;</span>)<span class="hljs-keyword">type</span> rect <span class="hljs-keyword">struct</span> &#123;length <span class="hljs-type">int</span>width  <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r rect)</span></span> area(wg *sync.WaitGroup) &#123;<span class="hljs-keyword">defer</span> wg.Done()<span class="hljs-keyword">if</span> r.length &lt; <span class="hljs-number">0</span> &#123;fmt.Printf(<span class="hljs-string">&quot;rect %v&#x27;s length should be greater than zero\n&quot;</span>, r)<span class="hljs-keyword">return</span>&#125;<span class="hljs-keyword">if</span> r.width &lt; <span class="hljs-number">0</span> &#123;fmt.Printf(<span class="hljs-string">&quot;rect %v&#x27;s width should be greater than zero\n&quot;</span>, r)<span class="hljs-keyword">return</span>&#125;area := r.length * r.widthfmt.Printf(<span class="hljs-string">&quot;rect %v&#x27;s area %d\n&quot;</span>, r, area)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> wg sync.WaitGroupr1 := rect&#123;<span class="hljs-number">-67</span>, <span class="hljs-number">89</span>&#125;r2 := rect&#123;<span class="hljs-number">5</span>, <span class="hljs-number">-67</span>&#125;r3 := rect&#123;<span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;rects := []rect&#123;r1, r2, r3&#125;<span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> rects &#123;wg.Add(<span class="hljs-number">1</span>)<span class="hljs-keyword">go</span> v.area(&amp;wg)&#125;wg.Wait()fmt.Println(<span class="hljs-string">&quot;All go routines finished executing&quot;</span>)&#125;</code></pre></div><p><a href="https://go.dev/play/p/xU4rYMHCPZl">在 Playground 中运行</a></p><p>该程序输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">rect &#123;8 9&#125;&#x27;s area 72rect &#123;-67 89&#125;&#x27;s length should be greater than zerorect &#123;5 -67&#125;&#x27;s width should be greater than zeroAll go routines finished executing</code></pre></div><p>在上面的程序中使用 <code>defer</code> 还有一个好处。假设我们使用一个新的 <code>if</code> 条件向 <code>area</code> 方法添加另一个返回路径。如果 <code>wg.Done()</code> 的调用没有延迟，我们必须小心确保在这个新的返回路径中调用 <code>wg.Done()</code>。但由于 <code>wg.Done()</code> 的调用被延迟了，我们不需要担心向该方法添加新的返回路径。</p><p><strong>下一个教程 - <a href="../%E3%80%90GolangBot%E3%80%9130-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">错误处理</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GolangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】28-多态</title>
    <link href="/%E3%80%90GolangBot%E3%80%9128-%E5%A4%9A%E6%80%81/"/>
    <url>/%E3%80%90GolangBot%E3%80%9128-%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到 <a href="../golangbot/">Golang 教程系列</a> 的第 28 个教程。</p><p>Go 中的多态性是通过<a href="../%E3%80%90GolangBot%E3%80%9118-%E6%8E%A5%E5%8F%A3-I">接口</a>实现的。正如我们已经讨论过的，接口在 Go 中是隐式实现的。如果一个类型为接口中声明的所有<a href="../%E3%80%90GolangBot%E3%80%9117-%E6%96%B9%E6%B3%95">方法</a>提供了定义，那么它就实现了该接口。让我们通过一个例子来看看如何在 Go 中利用接口实现多态性。</p><h3 id="使用接口实现多态性"><a href="#使用接口实现多态性" class="headerlink" title="使用接口实现多态性"></a>使用接口实现多态性</h3><p>任何为接口的所有方法提供定义的类型都被称为隐式实现了该接口。当我们讨论多态性的例子时，这一点会更加清楚。</p><p><strong>接口类型的变量可以保存任何实现了该接口的值。接口的这一特性用于在 Go 中实现多态性。</strong></p><p>让我们通过一个计算组织净收入的程序来理解 Go 中的多态性。为了简单起见，假设这个虚构的组织有两种项目的收入，即<strong>固定账单</strong>和<strong>时间和材料</strong>。组织的净收入是通过这些项目的收入总和来计算的。为了保持本教程的简单性，我们假设货币是美元，并且我们不处理美分。它将用 <code>int</code> 表示。（我建议阅读 <a href="https://forum.golangbridge.org/t/what-is-the-proper-golang-equivalent-to-decimal-when-dealing-with-money/413">https://forum.golangbridge.org/t/what-is-the-proper-golang-equivalent-to-decimal-when-dealing-with-money/413</a> 以了解如何表示美分。感谢评论部分的 <em>Andreas Matuschek</em> 指出这一点。）</p><p>首先，我们定义一个接口 <code>Income</code>。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Income <span class="hljs-keyword">interface</span> &#123;calculate() <span class="hljs-type">int</span>source() <span class="hljs-type">string</span>&#125;</code></pre></div><p>上面定义的 <code>Income</code> 接口包含两个方法：<code>calculate()</code> 用于计算并返回收入来源的收入，<code>source()</code> 用于返回收入来源的名称。</p><p>接下来，我们为 <code>FixedBilling</code> 项目类型定义一个结构体。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> FixedBilling <span class="hljs-keyword">struct</span> &#123;projectName  <span class="hljs-type">string</span>biddedAmount <span class="hljs-type">int</span>&#125;</code></pre></div><p><code>FixedBilling</code> 项目有两个字段：<code>projectName</code> 表示项目的名称，<code>biddedAmount</code> 是组织为该项目投标的金额。</p><p><code>TimeAndMaterial</code> 结构体将表示时间和材料类型的项目。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TimeAndMaterial <span class="hljs-keyword">struct</span> &#123;projectName <span class="hljs-type">string</span>noOfHours   <span class="hljs-type">int</span>hourlyRate  <span class="hljs-type">int</span>&#125;</code></pre></div><p><code>TimeAndMaterial</code> 结构体有三个字段：<code>projectName</code>、<code>noOfHours</code> 和 <code>hourlyRate</code>。</p><p>下一步是为这些结构体类型定义方法，计算并返回实际收入和收入来源。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(fb FixedBilling)</span></span> calculate() <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> fb.biddedAmount&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(fb FixedBilling)</span></span> source() <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">return</span> fb.projectName&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tm TimeAndMaterial)</span></span> calculate() <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> tm.noOfHours * tm.hourlyRate&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tm TimeAndMaterial)</span></span> source() <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">return</span> tm.projectName&#125;</code></pre></div><p>对于 <code>FixedBilling</code> 项目，收入就是为项目投标的金额。因此，我们从 <code>FixedBilling</code> 类型的 <code>calculate()</code> 方法中返回该值。</p><p>对于 <code>TimeAndMaterial</code> 项目，收入是 <code>noOfHours</code> 和 <code>hourlyRate</code> 的乘积。该值从 <code>TimeAndMaterial</code> 类型的 <code>calculate()</code> 方法中返回。</p><p>我们从 <code>source()</code> 方法中返回项目的名称作为收入来源。</p><p>由于 <code>FixedBilling</code> 和 <code>TimeAndMaterial</code> 结构体都为 <code>Income</code> 接口的 <code>calculate()</code> 和 <code>source()</code> 方法提供了定义，因此这两个结构体都实现了 <code>Income</code> 接口。</p><p>让我们声明 <code>calculateNetIncome</code> 函数，它将计算并打印总收入。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calculateNetIncome</span><span class="hljs-params">(ic []Income)</span></span> &#123;<span class="hljs-keyword">var</span> netincome <span class="hljs-type">int</span> = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> _, income := <span class="hljs-keyword">range</span> ic &#123;fmt.Printf(<span class="hljs-string">&quot;Income From %s = $%d\n&quot;</span>, income.source(), income.calculate())netincome += income.calculate()&#125;fmt.Printf(<span class="hljs-string">&quot;Net income of organization = $%d&quot;</span>, netincome)&#125;</code></pre></div><p>上面的 <code>calculateNetIncome</code> <a href="../%E3%80%90GolangBot%E3%80%916-%E5%87%BD%E6%95%B0">函数</a>接受一个 <code>Income</code> 接口的<a href="../%E3%80%90GolangBot%E3%80%9111-%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/#%E5%88%87%E7%89%87">切片</a>作为参数。它通过遍历切片并对每个项目调用 <code>calculate()</code> 方法来计算总收入。它还通过调用 <code>source()</code> 方法来显示收入来源。根据 <code>Income</code> 接口的具体类型，将调用不同的 <code>calculate()</code> 和 <code>source()</code> 方法。因此，我们在 <code>calculateNetIncome</code> 函数中实现了多态性。</p><p>将来，如果组织添加了新的收入来源，该函数仍然可以正确计算总收入，而无需更改任何代码 :)。</p><p>程序中唯一剩下的部分是 <code>main</code> 函数。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;project1 := FixedBilling&#123;projectName: <span class="hljs-string">&quot;Project 1&quot;</span>, biddedAmount: <span class="hljs-number">5000</span>&#125;project2 := FixedBilling&#123;projectName: <span class="hljs-string">&quot;Project 2&quot;</span>, biddedAmount: <span class="hljs-number">10000</span>&#125;project3 := TimeAndMaterial&#123;projectName: <span class="hljs-string">&quot;Project 3&quot;</span>, noOfHours: <span class="hljs-number">160</span>, hourlyRate: <span class="hljs-number">25</span>&#125;incomeStreams := []Income&#123;project1, project2, project3&#125;calculateNetIncome(incomeStreams)&#125;</code></pre></div><p>在上面的 <code>main</code> 函数中，我们创建了三个项目，其中两个是 <code>FixedBilling</code> 类型，一个是 <code>TimeAndMaterial</code> 类型。接下来，我们使用这三个项目创建一个 <code>Income</code> 类型的切片。由于每个项目都实现了 <code>Income</code> 接口，因此可以将所有三个项目添加到 <code>Income</code> 类型的切片中。最后，我们调用 <code>calculateNetIncome</code> 函数并将此切片作为参数传递。它将显示各种收入来源及其收入。</p><p>以下是完整的程序供您参考。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> Income <span class="hljs-keyword">interface</span> &#123;calculate() <span class="hljs-type">int</span>source() <span class="hljs-type">string</span>&#125;<span class="hljs-keyword">type</span> FixedBilling <span class="hljs-keyword">struct</span> &#123;projectName  <span class="hljs-type">string</span>biddedAmount <span class="hljs-type">int</span>&#125;<span class="hljs-keyword">type</span> TimeAndMaterial <span class="hljs-keyword">struct</span> &#123;projectName <span class="hljs-type">string</span>noOfHours   <span class="hljs-type">int</span>hourlyRate  <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(fb FixedBilling)</span></span> calculate() <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> fb.biddedAmount&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(fb FixedBilling)</span></span> source() <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">return</span> fb.projectName&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tm TimeAndMaterial)</span></span> calculate() <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> tm.noOfHours * tm.hourlyRate&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tm TimeAndMaterial)</span></span> source() <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">return</span> tm.projectName&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calculateNetIncome</span><span class="hljs-params">(ic []Income)</span></span> &#123;<span class="hljs-keyword">var</span> netincome <span class="hljs-type">int</span> = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> _, income := <span class="hljs-keyword">range</span> ic &#123;fmt.Printf(<span class="hljs-string">&quot;Income From %s = $%d\n&quot;</span>, income.source(), income.calculate())netincome += income.calculate()&#125;fmt.Printf(<span class="hljs-string">&quot;Net income of organization = $%d&quot;</span>, netincome)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;project1 := FixedBilling&#123;projectName: <span class="hljs-string">&quot;Project 1&quot;</span>, biddedAmount: <span class="hljs-number">5000</span>&#125;project2 := FixedBilling&#123;projectName: <span class="hljs-string">&quot;Project 2&quot;</span>, biddedAmount: <span class="hljs-number">10000</span>&#125;project3 := TimeAndMaterial&#123;projectName: <span class="hljs-string">&quot;Project 3&quot;</span>, noOfHours: <span class="hljs-number">160</span>, hourlyRate: <span class="hljs-number">25</span>&#125;incomeStreams := []Income&#123;project1, project2, project3&#125;calculateNetIncome(incomeStreams)&#125;</code></pre></div><p><a href="https://play.golang.org/p/uexie1DCcvh">在 Playground 中运行</a></p><p>该程序将输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">Income From Project 1 = $5000Income From Project 2 = $10000Income From Project 3 = $4000Net income of organization = $19000</code></pre></div><h3 id="向上述程序添加新的收入流"><a href="#向上述程序添加新的收入流" class="headerlink" title="向上述程序添加新的收入流"></a>向上述程序添加新的收入流</h3><p>假设组织通过广告找到了一种新的收入流。让我们看看在不更改 <code>calculateNetIncome</code> 函数的情况下，添加这个新的收入流并计算总收入是多么简单。这得益于多态性。</p><p>首先，我们定义 <code>Advertisement</code> 类型以及 <code>Advertisement</code> 类型的 <code>calculate()</code> 和 <code>source()</code> 方法。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Advertisement <span class="hljs-keyword">struct</span> &#123;adName     <span class="hljs-type">string</span>CPC        <span class="hljs-type">int</span>noOfClicks <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a Advertisement)</span></span> calculate() <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> a.CPC * a.noOfClicks&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a Advertisement)</span></span> source() <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">return</span> a.adName&#125;</code></pre></div><p><code>Advertisement</code> 类型有三个字段：<code>adName</code>、<code>CPC</code>（每次点击成本）和 <code>noOfClicks</code>（点击次数）。广告的总收入是 <code>CPC</code> 和 <code>noOfClicks</code> 的乘积。</p><p>让我们稍微修改一下 <code>main</code> 函数以包含这个新的收入流。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;project1 := FixedBilling&#123;projectName: <span class="hljs-string">&quot;Project 1&quot;</span>, biddedAmount: <span class="hljs-number">5000</span>&#125;project2 := FixedBilling&#123;projectName: <span class="hljs-string">&quot;Project 2&quot;</span>, biddedAmount: <span class="hljs-number">10000</span>&#125;project3 := TimeAndMaterial&#123;projectName: <span class="hljs-string">&quot;Project 3&quot;</span>, noOfHours: <span class="hljs-number">160</span>, hourlyRate: <span class="hljs-number">25</span>&#125;bannerAd := Advertisement&#123;adName: <span class="hljs-string">&quot;Banner Ad&quot;</span>, CPC: <span class="hljs-number">2</span>, noOfClicks: <span class="hljs-number">500</span>&#125;popupAd := Advertisement&#123;adName: <span class="hljs-string">&quot;Popup Ad&quot;</span>, CPC: <span class="hljs-number">5</span>, noOfClicks: <span class="hljs-number">750</span>&#125;incomeStreams := []Income&#123;project1, project2, project3, bannerAd, popupAd&#125;calculateNetIncome(incomeStreams)&#125;</code></pre></div><p>我们创建了两个广告，分别是 <code>bannerAd</code> 和 <code>popupAd</code>。<code>incomeStreams</code> 切片包括我们刚刚创建的两个广告。</p><p>以下是添加 <code>Advertisement</code> 后的完整程序。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> Income <span class="hljs-keyword">interface</span> &#123;calculate() <span class="hljs-type">int</span>source() <span class="hljs-type">string</span>&#125;<span class="hljs-keyword">type</span> FixedBilling <span class="hljs-keyword">struct</span> &#123;projectName  <span class="hljs-type">string</span>biddedAmount <span class="hljs-type">int</span>&#125;<span class="hljs-keyword">type</span> TimeAndMaterial <span class="hljs-keyword">struct</span> &#123;projectName <span class="hljs-type">string</span>noOfHours   <span class="hljs-type">int</span>hourlyRate  <span class="hljs-type">int</span>&#125;<span class="hljs-keyword">type</span> Advertisement <span class="hljs-keyword">struct</span> &#123;adName     <span class="hljs-type">string</span>CPC        <span class="hljs-type">int</span>noOfClicks <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(fb FixedBilling)</span></span> calculate() <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> fb.biddedAmount&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(fb FixedBilling)</span></span> source() <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">return</span> fb.projectName&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tm TimeAndMaterial)</span></span> calculate() <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> tm.noOfHours * tm.hourlyRate&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tm TimeAndMaterial)</span></span> source() <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">return</span> tm.projectName&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a Advertisement)</span></span> calculate() <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> a.CPC * a.noOfClicks&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a Advertisement)</span></span> source() <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">return</span> a.adName&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calculateNetIncome</span><span class="hljs-params">(ic []Income)</span></span> &#123;<span class="hljs-keyword">var</span> netincome <span class="hljs-type">int</span> = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> _, income := <span class="hljs-keyword">range</span> ic &#123;fmt.Printf(<span class="hljs-string">&quot;Income From %s = $%d\n&quot;</span>, income.source(), income.calculate())netincome += income.calculate()&#125;fmt.Printf(<span class="hljs-string">&quot;Net income of organization = $%d&quot;</span>, netincome)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;project1 := FixedBilling&#123;projectName: <span class="hljs-string">&quot;Project 1&quot;</span>, biddedAmount: <span class="hljs-number">5000</span>&#125;project2 := FixedBilling&#123;projectName: <span class="hljs-string">&quot;Project 2&quot;</span>, biddedAmount: <span class="hljs-number">10000</span>&#125;project3 := TimeAndMaterial&#123;projectName: <span class="hljs-string">&quot;Project 3&quot;</span>, noOfHours: <span class="hljs-number">160</span>, hourlyRate: <span class="hljs-number">25</span>&#125;bannerAd := Advertisement&#123;adName: <span class="hljs-string">&quot;Banner Ad&quot;</span>, CPC: <span class="hljs-number">2</span>, noOfClicks: <span class="hljs-number">500</span>&#125;popupAd := Advertisement&#123;adName: <span class="hljs-string">&quot;Popup Ad&quot;</span>, CPC: <span class="hljs-number">5</span>, noOfClicks: <span class="hljs-number">750</span>&#125;incomeStreams := []Income&#123;project1, project2, project3, bannerAd, popupAd&#125;calculateNetIncome(incomeStreams)&#125;</code></pre></div><p><a href="https://play.golang.org/p/HF1P9tNt2H_6">在 Playground 中运行</a></p><p>上面的程序将输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">Income From Project 1 = $5000Income From Project 2 = $10000Income From Project 3 = $4000Income From Banner Ad = $1000Income From Popup Ad = $3750Net income of organization = $23750</code></pre></div><p>你会注意到，尽管我们添加了新的收入流，但我们没有对 <code>calculateNetIncome</code> 函数进行任何更改。由于多态性，它仍然可以正常工作。由于新的 <code>Advertisement</code> 类型也实现了 <code>Income</code> 接口，我们能够将其添加到 <code>incomeStreams</code> 切片中。<code>calculateNetIncome</code> 函数也无需更改即可正常工作，因为它能够调用 <code>Advertisement</code> 类型的 <code>calculate()</code> 和 <code>source()</code> 方法。</p><p><strong>下一个教程 - <a href="../%E3%80%90GolangBot%E3%80%9129-Defer">Defer</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GolangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】27-组合而不是继承</title>
    <link href="/%E3%80%90GolangBot%E3%80%9127-%E7%BB%84%E5%90%88%E8%80%8C%E4%B8%8D%E6%98%AF%E7%BB%A7%E6%89%BF/"/>
    <url>/%E3%80%90GolangBot%E3%80%9127-%E7%BB%84%E5%90%88%E8%80%8C%E4%B8%8D%E6%98%AF%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到 <a href="../golangbot/">Golang 教程系列</a> 的第 27 个教程。</p><p>Go 不支持继承，但它支持组合。组合的通用定义是“组合在一起”。一个组合的例子是<strong>汽车</strong>。汽车由轮子、发动机和其他各种部件组成。</p><h3 id="通过嵌入结构体实现组合"><a href="#通过嵌入结构体实现组合" class="headerlink" title="通过嵌入结构体实现组合"></a>通过嵌入结构体实现组合</h3><p>在 Go 中，可以通过将一个<a href="../%E3%80%90GolangBot%E3%80%9116-%E7%BB%93%E6%9E%84%E4%BD%93/">结构体</a>类型嵌入到另一个结构体来实现组合。</p><p>博客文章是组合的一个完美例子。每篇博客文章都有标题、内容和作者信息。这可以通过组合完美地表示。在本教程的后续步骤中，我们将学习如何实现这一点。</p><p>让我们首先创建 <code>author</code> 结构体。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> author <span class="hljs-keyword">struct</span> &#123;firstName <span class="hljs-type">string</span>lastName  <span class="hljs-type">string</span>bio       <span class="hljs-type">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a author)</span></span> fullName() <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%s %s&quot;</span>, a.firstName, a.lastName)&#125;</code></pre></div><p>在上面的代码片段中，我们创建了一个 <code>author</code> 结构体，包含字段 <code>firstName</code>、<code>lastName</code> 和 <code>bio</code>。我们还添加了一个 <code>fullName()</code> 方法，该方法以 <code>author</code> 作为接收者类型，并返回作者的全名。</p><p>下一步是创建 <code>blogPost</code> 结构体。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> blogPost <span class="hljs-keyword">struct</span> &#123;title   <span class="hljs-type">string</span>content <span class="hljs-type">string</span>author&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b blogPost)</span></span> details() &#123;fmt.Println(<span class="hljs-string">&quot;Title: &quot;</span>, b.title)fmt.Println(<span class="hljs-string">&quot;Content: &quot;</span>, b.content)fmt.Println(<span class="hljs-string">&quot;Author: &quot;</span>, b.author.fullName())fmt.Println(<span class="hljs-string">&quot;Bio: &quot;</span>, b.author.bio)&#125;</code></pre></div><p><code>blogPost</code> 结构体包含字段 <code>title</code> 和 <code>content</code>。它还有一个嵌入的<a href="../%E3%80%90GolangBot%E3%80%9116-%E7%BB%93%E6%9E%84%E4%BD%93/#%E5%8C%BF%E5%90%8D%E5%AD%97%E6%AE%B5">匿名</a>字段 <code>author</code>。该字段表示 <code>blogPost</code> 结构体由 <code>author</code> 组成。现在，<code>blogPost</code> 结构体可以访问 <code>author</code> 结构体的所有字段和方法。我们还向 <code>blogPost</code> 结构体添加了 <code>details()</code> 方法，用于打印标题、内容、作者的全名和简介。</p><p>当一个结构体字段嵌入到另一个结构体时，Go 允许我们像访问外部结构体的字段一样访问嵌入的字段。这意味着上面代码中第 11 行的 <code>p.author.fullName()</code> 可以替换为 <code>p.fullName()</code>。因此，<code>details()</code> 方法可以重写如下：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p blogPost)</span></span> details() &#123;fmt.Println(<span class="hljs-string">&quot;Title: &quot;</span>, p.title)fmt.Println(<span class="hljs-string">&quot;Content: &quot;</span>, p.content)fmt.Println(<span class="hljs-string">&quot;Author: &quot;</span>, p.fullName())fmt.Println(<span class="hljs-string">&quot;Bio: &quot;</span>, p.bio)&#125;</code></pre></div><p>现在我们已经准备好了 <code>author</code> 和 <code>blogPost</code> 结构体，让我们通过创建一篇博客文章来完成这个程序。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> author <span class="hljs-keyword">struct</span> &#123;firstName <span class="hljs-type">string</span>lastName  <span class="hljs-type">string</span>bio       <span class="hljs-type">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a author)</span></span> fullName() <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%s %s&quot;</span>, a.firstName, a.lastName)&#125;<span class="hljs-keyword">type</span> blogPost <span class="hljs-keyword">struct</span> &#123;title   <span class="hljs-type">string</span>content <span class="hljs-type">string</span>author&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b blogPost)</span></span> details() &#123;fmt.Println(<span class="hljs-string">&quot;Title: &quot;</span>, b.title)fmt.Println(<span class="hljs-string">&quot;Content: &quot;</span>, b.content)fmt.Println(<span class="hljs-string">&quot;Author: &quot;</span>, b.fullName())fmt.Println(<span class="hljs-string">&quot;Bio: &quot;</span>, b.bio)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;author1 := author&#123;<span class="hljs-string">&quot;Naveen&quot;</span>,<span class="hljs-string">&quot;Ramanathan&quot;</span>,<span class="hljs-string">&quot;Golang Enthusiast&quot;</span>,&#125;blogPost1 := blogPost&#123;<span class="hljs-string">&quot;Inheritance in Go&quot;</span>,<span class="hljs-string">&quot;Go supports composition instead of inheritance&quot;</span>,author1,&#125;blogPost1.details()&#125;</code></pre></div><p><a href="https://play.golang.org/p/fmF-2oJwbCP">在 Playground 中运行</a></p><p>上述程序的 <code>main</code> 函数在第 31 行创建了一个新作者。在第 36 行，通过嵌入 <code>author1</code> 创建了一篇新文章。该程序输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">Title:  Inheritance in GoContent:  Go supports composition instead of inheritanceAuthor:  Naveen RamanathanBio:  Golang Enthusiast</code></pre></div><h3 id="嵌入结构体切片"><a href="#嵌入结构体切片" class="headerlink" title="嵌入结构体切片"></a>嵌入结构体切片</h3><p>我们可以进一步扩展这个例子，使用博客文章的<a href="../%E3%80%90GolangBot%E3%80%9111-%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87">切片</a>创建一个网站 :)。</p><p>让我们首先定义 <code>website</code> 结构体。请将以下代码添加到现有程序的 <code>main</code> 函数之前并运行它。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> website <span class="hljs-keyword">struct</span> &#123;[]blogPost&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w website)</span></span> contents() &#123;fmt.Println(<span class="hljs-string">&quot;Contents of Website\n&quot;</span>)<span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> w.blogPosts &#123;v.details()fmt.Println()&#125;&#125;</code></pre></div><p>当你在添加上述代码后运行程序时，编译器会报以下错误：</p><div class="code-wrapper"><pre><code class="hljs fallback">main.go:31:9: syntax error: unexpected [, expecting field name or embedded type</code></pre></div><p>此错误指向嵌入的结构体切片 <code>[]blogPost</code>。原因是无法匿名嵌入切片。需要一个字段名称。因此，让我们修复此错误并使编译器满意。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> website <span class="hljs-keyword">struct</span> &#123;blogPosts []blogPost&#125;</code></pre></div><p>我添加了字段 <code>blogPosts</code>，它是一个 <code>[]blogPost</code> 切片。</p><p>现在让我们修改 <code>main</code> 函数，为我们的新网站创建几篇文章。</p><p>修改后的完整程序如下：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> author <span class="hljs-keyword">struct</span> &#123;firstName <span class="hljs-type">string</span>lastName  <span class="hljs-type">string</span>bio       <span class="hljs-type">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a author)</span></span> fullName() <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%s %s&quot;</span>, a.firstName, a.lastName)&#125;<span class="hljs-keyword">type</span> blogPost <span class="hljs-keyword">struct</span> &#123;title   <span class="hljs-type">string</span>content <span class="hljs-type">string</span>author&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p blogPost)</span></span> details() &#123;fmt.Println(<span class="hljs-string">&quot;Title: &quot;</span>, p.title)fmt.Println(<span class="hljs-string">&quot;Content: &quot;</span>, p.content)fmt.Println(<span class="hljs-string">&quot;Author: &quot;</span>, p.fullName())fmt.Println(<span class="hljs-string">&quot;Bio: &quot;</span>, p.bio)&#125;<span class="hljs-keyword">type</span> website <span class="hljs-keyword">struct</span> &#123;blogPosts []blogPost&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w website)</span></span> contents() &#123;fmt.Println(<span class="hljs-string">&quot;Contents of Website\n&quot;</span>)<span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> w.blogPosts &#123;v.details()fmt.Println()&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;author1 := author&#123;<span class="hljs-string">&quot;Naveen&quot;</span>,<span class="hljs-string">&quot;Ramanathan&quot;</span>,<span class="hljs-string">&quot;Golang Enthusiast&quot;</span>,&#125;blogPost1 := blogPost&#123;<span class="hljs-string">&quot;Inheritance in Go&quot;</span>,<span class="hljs-string">&quot;Go supports composition instead of inheritance&quot;</span>,author1,&#125;blogPost2 := blogPost&#123;<span class="hljs-string">&quot;Struct instead of Classes in Go&quot;</span>,<span class="hljs-string">&quot;Go does not support classes but methods can be added to structs&quot;</span>,author1,&#125;blogPost3 := blogPost&#123;<span class="hljs-string">&quot;Concurrency&quot;</span>,<span class="hljs-string">&quot;Go is a concurrent language and not a parallel one&quot;</span>,author1,&#125;w := website&#123;blogPosts: []blogPost&#123;blogPost1, blogPost2, blogPost3&#125;,&#125;w.contents()&#125;</code></pre></div><p><a href="https://play.golang.org/p/dv2gdcptwgS">在 Playground 中运行</a></p><p>在上面的 <code>main</code> 函数中，我们创建了一个作者 <code>author1</code> 和三篇文章 <code>post1</code>、<code>post2</code> 和 <code>post3</code>。最后，我们在第 62 行通过嵌入这 3 篇文章创建了网站 <code>w</code>，并在下一行显示了内容。</p><p>该程序将输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">Contents of WebsiteTitle:  Inheritance in GoContent:  Go supports composition instead of inheritanceAuthor:  Naveen RamanathanBio:  Golang EnthusiastTitle:  Struct instead of Classes in GoContent:  Go does not support classes but methods can be added to structsAuthor:  Naveen RamanathanBio:  Golang EnthusiastTitle:  ConcurrencyContent:  Go is a concurrent language and not a parallel oneAuthor:  Naveen RamanathanBio:  Golang Enthusiast</code></pre></div><p><strong>下一个教程 - <a href="../%E3%80%90GolangBot%E3%80%9128-%E5%A4%9A%E6%80%81">多态</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GolangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】26-结构体代替类</title>
    <link href="/%E3%80%90GolangBot%E3%80%9126-%E7%BB%93%E6%9E%84%E4%BD%93%E4%BB%A3%E6%9B%BF%E7%B1%BB/"/>
    <url>/%E3%80%90GolangBot%E3%80%9126-%E7%BB%93%E6%9E%84%E4%BD%93%E4%BB%A3%E6%9B%BF%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到 <a href="../golangbot/">Golang 教程系列</a> 的第 26 个教程。</p><h3 id="Go-是面向对象的吗？"><a href="#Go-是面向对象的吗？" class="headerlink" title="Go 是面向对象的吗？"></a>Go 是面向对象的吗？</h3><p>Go 不是纯粹的面向对象编程语言。以下摘录自 Go 的 <a href="https://go.dev/doc/faq#Is_Go_an_object-oriented_language">FAQ</a>，回答了 Go 是否是面向对象的问题。</p><div class="code-wrapper"><pre><code class="hljs fallback">Yes and no. Although Go has types and methods and allows an object-oriented style of programming, there is no type hierarchy. The concept of “interface” in Go provides a different approach that we believe is easy to use and in some ways more general. There are also ways to embed types in other types to provide something analogous—but not identical—to subclassing. Moreover, methods in Go are more general than in C++ or Java: they can be defined for any sort of data, even built-in types such as plain, &quot;unboxed&quot; integers. They are not restricted to structs (classes).是，也不是。尽管 Go 具有类型和方法，并支持面向对象的编程风格，但它没有类型层次结构。Go 中的“接口”概念提供了一种不同的方式，我们认为这种方式易于使用，并且在某些方面更加通用。Go 还可以通过将一种类型嵌入到另一种类型中，提供类似（但不完全相同于）子类化的功能。此外，Go 中的方法比 C++ 或 Java 更加通用：它们可以为任何类型的数据定义，甚至包括内置类型，例如普通的“非装箱”整数。它们并不限于 struct（类）。</code></pre></div><p>在接下来的教程中，我们将讨论如何使用 Go 实现面向对象编程的概念。其中一些实现与其他面向对象语言（如 Java）相比有很大的不同。</p><h3 id="使用结构体代替类"><a href="#使用结构体代替类" class="headerlink" title="使用结构体代替类"></a>使用结构体代替类</h3><p>Go 不提供类，但它提供 <a href="../%E3%80%90GolangBot%E3%80%9116-%E7%BB%93%E6%9E%84%E4%BD%93">结构体</a>。可以在结构体上添加 <a href="../%E3%80%90GolangBot%E3%80%9117-%E6%96%B9%E6%B3%95">方法</a>。这提供了将数据和方法捆绑在一起的行为，类似于类。</p><p>为了更好地理解，让我们直接从一个例子开始。</p><p>在这个例子中，我们将创建一个自定义的 <a href="../GolangBot%E3%80%917-%E5%8C%85">包</a>，因为它有助于更好地理解结构体如何有效地替代类。</p><p>在 <code>~/Documents/</code> 中创建一个子文件夹，并将其命名为 <code>oop</code>。</p><p>让我们初始化一个名为 <code>oop</code> 的 Go 模块。在 <code>oop</code> 目录中键入以下命令以创建一个名为 <code>oop</code> 的 go mod。</p><div class="code-wrapper"><pre><code class="hljs fallback">go mod init oop</code></pre></div><p>在 <code>oop</code> 中创建一个子文件夹 <code>employee</code>。在 <code>employee</code> 文件夹中，创建一个名为 <code>employee.go</code> 的文件。</p><p>文件夹结构如下：</p><div class="code-wrapper"><pre><code class="hljs fallback">├── Documents│   └── oop│       ├── employee│       │   └── employee.go│       └── go.mod</code></pre></div><p>请将 <code>employee.go</code> 的内容替换为以下内容：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> employee<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> Employee <span class="hljs-keyword">struct</span> &#123;      FirstName   <span class="hljs-type">string</span>    LastName    <span class="hljs-type">string</span>    TotalLeaves <span class="hljs-type">int</span>    LeavesTaken <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e Employee)</span></span> LeavesRemaining() &#123;      fmt.Printf(<span class="hljs-string">&quot;%s %s has %d leaves remaining\n&quot;</span>, e.FirstName, e.LastName, (e.TotalLeaves - e.LeavesTaken))&#125;</code></pre></div><p>在上面的程序中，第 1 行指定此文件属于 <code>employee</code> 包。第 7 行声明了一个 <code>Employee</code> 结构体。第 14 行向 <code>Employee</code> 结构体添加了一个名为 <code>LeavesRemaining</code> 的方法。该方法计算并显示员工剩余的假期天数。现在我们有了一个结构体和一个操作结构体的方法，类似于类。</p><p>在 <code>oop</code> 文件夹中创建一个名为 <code>main.go</code> 的文件。</p><p>现在文件夹结构如下：</p><div class="code-wrapper"><pre><code class="hljs fallback">├── Documents│   └── oop│       ├── employee│       │   └── employee.go│       ├── go.mod│       └── main.go</code></pre></div><p><code>main.go</code> 的内容如下：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;oop/employee&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;e := employee.Employee &#123;FirstName: <span class="hljs-string">&quot;Sam&quot;</span>,LastName: <span class="hljs-string">&quot;Adolf&quot;</span>,TotalLeaves: <span class="hljs-number">30</span>,LeavesTaken: <span class="hljs-number">20</span>,&#125;e.LeavesRemaining()&#125;</code></pre></div><p>我们在第 3 行导入了 <code>employee</code> 包。第 12 行在 <code>main()</code> 中调用了 <code>Employee</code> 结构体的 <code>LeavesRemaining()</code> 方法。</p><p>由于此程序包含自定义包，因此无法在 playground 上运行。如果您在本地运行此程序，通过执行 <code>go install</code> 命令，然后执行 <code>oop</code>，程序将输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">Sam Adolf has 10 leaves remaining</code></pre></div><p>如果您不确定如何运行此程序，请访问 <a href="../%E3%80%90GolangBot%E3%80%912-Hello-World">&#x2F;hello-world-gomod&#x2F;</a> 了解更多信息。</p><h3 id="使用-New-函数代替构造函数"><a href="#使用-New-函数代替构造函数" class="headerlink" title="使用 New() 函数代替构造函数"></a>使用 New() 函数代替构造函数</h3><p>我们上面编写的程序看起来不错，但其中存在一个微妙的问题。让我们看看当我们用零值定义 employee 结构体时会发生什么。将 <code>main.go</code> 的内容替换为以下代码：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;oop/employee&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> e employee.Employeee.LeavesRemaining()&#125;</code></pre></div><p>我们唯一做的更改是在第 6 行创建了一个零值的 <code>Employee</code>。此程序将输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">has 0 leaves remaining</code></pre></div><p>如您所见，使用 <code>Employee</code> 的零值创建的变量是不可用的。它没有有效的名字、姓氏，也没有有效的假期详细信息。</p><p>在其他 OOP 语言（如 Java）中，可以通过使用构造函数来解决此问题。可以通过使用参数化构造函数来创建有效的对象。</p><p>Go 不支持构造函数。如果类型的零值不可用，程序员的工作是取消导出该类型以防止从其他包访问，并提供一个名为 <code>NewT(parameters)</code> 的 <a href="../%E3%80%90GolangBot%E3%80%916-%E5%87%BD%E6%95%B0">函数</a>，该函数使用所需的值初始化类型 <code>T</code>。在 Go 中，命名一个创建类型 <code>T</code> 的值的函数为 <code>NewT(parameters)</code> 是一种约定。这将充当构造函数。如果包只定义了一个类型，那么在 Go 中约定将此函数命名为 <code>New(parameters)</code> 而不是 <code>NewT(parameters)</code>。</p><p>让我们对我们编写的程序进行更改，以便每次创建 employee 时，它都是可用的。</p><p>第一步是取消导出 <code>Employee</code> 结构体并创建一个 <code>New()</code> 函数，该函数将创建一个新的 <code>Employee</code>。将 <code>employee.go</code> 中的代码替换为以下内容：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> employee<span class="hljs-keyword">import</span> (      <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> employee <span class="hljs-keyword">struct</span> &#123;      firstName   <span class="hljs-type">string</span>    lastName    <span class="hljs-type">string</span>    totalLeaves <span class="hljs-type">int</span>    leavesTaken <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(firstName <span class="hljs-type">string</span>, lastName <span class="hljs-type">string</span>, totalLeave <span class="hljs-type">int</span>, leavesTaken <span class="hljs-type">int</span>)</span></span> employee &#123;e := employee &#123;firstName, lastName, totalLeave, leavesTaken&#125;<span class="hljs-keyword">return</span> e&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e employee)</span></span> LeavesRemaining() &#123;      fmt.Printf(<span class="hljs-string">&quot;%s %s has %d leaves remaining\n&quot;</span>, e.firstName, e.lastName, (e.totalLeaves - e.leavesTaken))&#125;</code></pre></div><p>我们在这里做了一些重要的更改。我们将第 7 行的 <code>Employee</code> 结构体的首字母 <code>e</code> 改为小写，即将 <code>type Employee struct</code> 更改为 <code>type employee struct</code>。通过这样做，我们成功地取消了 <code>employee</code> 结构体的导出，并防止了其他包的访问。除非有特定的需要导出字段，否则最好将所有未导出结构体的字段也取消导出。由于我们不需要在 <code>employee</code> 包之外的任何地方访问 <code>employee</code> 结构体的字段，因此我们也取消了所有字段的导出。</p><p>我们在 <code>LeavesRemaining()</code> 方法中相应地更改了字段名称。</p><p>现在，由于 <code>employee</code> 是未导出的，因此无法从其他包创建类型为 <code>Employee</code> 的值。因此，我们在第 14 行提供了一个导出的 <code>New</code> 函数，该函数接受所需的参数作为输入并返回一个新创建的 employee。</p><p>此程序仍然需要进行更改才能使其工作，但让我们运行此程序以了解到目前为止更改的效果。如果运行此程序，它将失败并出现以下编译错误：</p><div class="code-wrapper"><pre><code class="hljs fallback"># oop./main.go:6:8: undefined: employee.Employee</code></pre></div><p>这是因为我们在 <code>employee</code> 包中有一个未导出的 <code>employee</code>，并且无法从 <code>main</code> 包访问它。因此，编译器会抛出错误，指出此类型在 <code>main.go</code> 中未定义。完美。这正是我们想要的。现在，其他包将无法创建零值的 <code>employee</code>。我们成功地防止了创建不可用的 employee 结构体值。现在创建 employee 的唯一方法是使用 <code>New</code> 函数。</p><p>将 <code>main.go</code> 的内容替换为以下内容：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main  <span class="hljs-keyword">import</span> <span class="hljs-string">&quot;oop/employee&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;      e := employee.New(<span class="hljs-string">&quot;Sam&quot;</span>, <span class="hljs-string">&quot;Adolf&quot;</span>, <span class="hljs-number">30</span>, <span class="hljs-number">20</span>)    e.LeavesRemaining()&#125;</code></pre></div><p>此文件的唯一更改是在第 6 行。我们通过将所需的参数传递给 <code>New</code> 函数来创建一个新的 employee。</p><p>以下是进行所需更改后两个文件的内容。</p><p>employee.go</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> employee<span class="hljs-keyword">import</span> (      <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> employee <span class="hljs-keyword">struct</span> &#123;      firstName   <span class="hljs-type">string</span>    lastName    <span class="hljs-type">string</span>    totalLeaves <span class="hljs-type">int</span>    leavesTaken <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(firstName <span class="hljs-type">string</span>, lastName <span class="hljs-type">string</span>, totalLeave <span class="hljs-type">int</span>, leavesTaken <span class="hljs-type">int</span>)</span></span> employee &#123;      e := employee &#123;firstName, lastName, totalLeave, leavesTaken&#125;    <span class="hljs-keyword">return</span> e&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e employee)</span></span> LeavesRemaining() &#123;      fmt.Printf(<span class="hljs-string">&quot;%s %s has %d leaves remaining\n&quot;</span>, e.firstName, e.lastName, (e.totalLeaves - e.leavesTaken))&#125;</code></pre></div><p>main.go</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main  <span class="hljs-keyword">import</span> <span class="hljs-string">&quot;oop/employee&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;      e := employee.New(<span class="hljs-string">&quot;Sam&quot;</span>, <span class="hljs-string">&quot;Adolf&quot;</span>, <span class="hljs-number">30</span>, <span class="hljs-number">20</span>)    e.LeavesRemaining()&#125;</code></pre></div><p>运行此程序将输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">Sam Adolf has 10 leaves remaining</code></pre></div><p>因此，您可以理解，尽管 Go 不支持类，但结构体可以有效地替代类，并且签名 <code>New(parameters)</code> 的方法可以替代构造函数。</p><p>这就是 Go 中的类和构造函数。</p><p><strong>下一个教程 - <a href="../%E3%80%90GolangBot%E3%80%9127-%E7%BB%84%E5%90%88%E8%80%8C%E4%B8%8D%E6%98%AF%E7%BB%A7%E6%89%BF.md">组合代替继承</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GolangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】25-互斥锁</title>
    <link href="/%E3%80%90GolangBot%E3%80%9125-%E4%BA%92%E6%96%A5%E9%94%81/"/>
    <url>/%E3%80%90GolangBot%E3%80%9125-%E4%BA%92%E6%96%A5%E9%94%81/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到 <a href="../golangbot/">Golang系列教程</a> 的第25篇教程。</p><p>在本教程中，我们将学习互斥锁（mutexes）。我们还将学习如何使用互斥锁和<a href="../%E3%80%90GolangBot%E3%80%9122-Channels">通道</a>来解决竞态条件。</p><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>在开始学习互斥锁之前，理解并发编程中<a href="https://en.wikipedia.org/wiki/Critical_section">临界区</a>的概念很重要。当程序并发运行时，修改共享资源的代码部分不应该同时被多个 <a href="../%E3%80%90GolangBot%E3%80%9122-Channels">Goroutines</a> 访问。这段修改共享资源的代码被称为临界区。例如，假设我们有一段将变量 x 加 1 的代码。</p><div class="code-wrapper"><pre><code class="hljs fallback">x = x + 1</code></pre></div><p>只要上面这段代码被单个 Goroutine 访问，就不会有任何问题。</p><p>让我们看看当有多个 Goroutine 并发运行时，为什么这段代码会失败。为了简单起见，让我们假设有 2 个 Goroutine 并发运行上面的代码。</p><p>在内部，系统将按以下步骤执行上述代码（还有更多涉及寄存器、加法工作原理等技术细节，但为了本教程的目的，让我们假设这是三个步骤）：</p><ol><li>获取 x 的当前值</li><li>计算 x + 1</li><li>将步骤 2 中计算的值赋给 x</li></ol><p>当这三个步骤只由一个 Goroutine 执行时，一切正常。</p><p>让我们讨论当 2 个 Goroutine 并发运行这段代码时会发生什么。下图描述了当两个 Goroutine 并发访问代码 <code>x = x + 1</code> 时可能发生的一种情况。</p><p><img src="https://golangbot.com/content/images/2017/08/cs5.png" alt="critical-section"></p><p>我们假设 x 的初始值为 0。<em>Goroutine 1</em> 获取 x 的初始值，计算 x + 1，但在它能将计算的值赋给 x 之前，系统上下文切换到了 <code>Goroutine 2</code>。现在 <code>Goroutine 2</code> 获取 <code>x</code> 的初始值（仍然是 <code>0</code>），计算 <code>x + 1</code>。之后，系统再次上下文切换到 <em>Goroutine 1</em>。现在 <em>Goroutine 1</em> 将其计算的值 <em>1</em> 赋给 <em>x</em>，因此 x 变成了 1。然后 <em>Goroutine 2</em> 再次开始执行，将其计算的值（同样是 <code>1</code>）赋给 <code>x</code>，因此在两个 Goroutine 执行后 <code>x</code> 的值是 <code>1</code>。</p><p>现在让我们看看可能发生的另一种情况。</p><p><img src="https://golangbot.com/content/images/2017/08/cs-6.png" alt="critical-section"></p><p>在上面的情况中，<code>Goroutine 1</code> 开始执行并完成其所有三个步骤，因此 x 的值变成 <code>1</code>。然后 <code>Goroutine 2</code> 开始执行。现在 x 的值是 1，当 <code>Goroutine 2</code> 完成执行时，x 的值是 <code>2</code>。</p><p>从这两种情况可以看出，x 的最终值是 <code>1</code> 或 <code>2</code>，这取决于上下文切换是如何发生的。这种程序输出依赖于 Goroutine 执行顺序的不良情况称为**<a href="https://en.wikipedia.org/wiki/Race_condition">竞态条件</a>**。</p><p>在上述情况下，如果在任何时候只允许一个 Goroutine 访问代码的临界区，就可以避免竞态条件。这可以通过使用互斥锁来实现。</p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>互斥锁用于提供一种锁定机制，以确保在任何时候只有一个 Goroutine 在运行代码的临界区，从而防止竞态条件的发生。</p><p>互斥锁在 <a href="https://golang.org/pkg/sync/">sync</a> 包中提供。<a href="https://tip.golang.org/pkg/sync/#Mutex">Mutex</a> 上定义了两个方法，即 <a href="https://tip.golang.org/pkg/sync/#Mutex.Lock">Lock</a> 和 <a href="https://tip.golang.org/pkg/sync/#Mutex.Unlock">Unlock</a>。位于 <code>Lock</code> 和 <code>Unlock</code> 调用之间的任何代码将只能由一个 Goroutine 执行，从而避免竞态条件。</p><div class="code-wrapper"><pre><code class="hljs fallback">mutex.Lock()x = x + 1mutex.Unlock()</code></pre></div><p>在上面的代码中，<code>x = x + 1</code> 在任何时候都只能由一个 Goroutine 执行，从而防止竞态条件。</p><p><strong>如果一个 Goroutine 已经持有锁，而新的 Goroutine 试图获取锁，新的 Goroutine 将被阻塞，直到互斥锁被解锁。</strong></p><h3 id="存在竞态条件的程序"><a href="#存在竞态条件的程序" class="headerlink" title="存在竞态条件的程序"></a>存在竞态条件的程序</h3><p>在本节中，我们将编写一个存在竞态条件的程序，在接下来的章节中，我们将修复这个竞态条件。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;sync&quot;</span>)<span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increment</span><span class="hljs-params">(wg *sync.WaitGroup)</span></span> &#123;    x = x + <span class="hljs-number">1</span>    wg.Done()&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">var</span> w sync.WaitGroup    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;        w.Add(<span class="hljs-number">1</span>)                <span class="hljs-keyword">go</span> increment(&amp;w)    &#125;    w.Wait()    fmt.Println(<span class="hljs-string">&quot;final value of x&quot;</span>, x)&#125;</code></pre></div><p>在上面的程序中，<code>increment</code> 函数将 x 的值加 1，然后在 <a href="../%E3%80%90GolangBot%E3%80%9123-%E7%BC%93%E5%86%B2%E9%80%9A%E9%81%93%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%B1%A0/#waitgroup">WaitGroup</a> 上调用 <code>Done()</code> 来通知其完成。</p><p>我们在程序中生成了 1000 个 <code>increment</code> Goroutine。所有这些 Goroutine 都并发运行，当多个 Goroutine 试图同时访问 x 的值时，就会出现竞态条件。</p><p><em>请在本地运行此程序，因为 playground 是确定性的，竞态条件不会在 playground 中出现。</em> 在本地机器上多次运行此程序，你会看到由于竞态条件，每次的输出都会不同。我遇到的一些输出是 <code>final value of x 941</code>、<code>final value of x 928</code>、<code>final value of x 922</code> 等。</p><h3 id="使用互斥锁解决竞态条件"><a href="#使用互斥锁解决竞态条件" class="headerlink" title="使用互斥锁解决竞态条件"></a>使用互斥锁解决竞态条件</h3><p>在上面的程序中，我们生成了 1000 个 Goroutine。如果每个都将 x 的值加 1，x 的最终期望值应该是 1000。在本节中，我们将使用互斥锁修复上面程序中的竞态条件。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;sync&quot;</span>)<span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increment</span><span class="hljs-params">(wg *sync.WaitGroup, m *sync.Mutex)</span></span> &#123;    m.Lock()    x = x + <span class="hljs-number">1</span>    m.Unlock()    wg.Done()    &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">var</span> w sync.WaitGroup    <span class="hljs-keyword">var</span> m sync.Mutex    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;        w.Add(<span class="hljs-number">1</span>)                <span class="hljs-keyword">go</span> increment(&amp;w, &amp;m)    &#125;    w.Wait()    fmt.Println(<span class="hljs-string">&quot;final value of x&quot;</span>, x)&#125;</code></pre></div><p><a href="https://play.golang.org/p/VX9dwGhR62">在 playground 中运行</a></p><p><a href="https://golang.org/pkg/sync/#Mutex">Mutex</a> 是一个结构体类型，我们创建了一个零值变量 <code>m</code>，类型为 Mutex。在上面的程序中，我们修改了 <code>increment</code> 函数，使得递增 x 的代码 <code>x = x + 1</code> 位于 <code>m.Lock()</code> 和 <code>m.Unlock()</code> 之间。现在这段代码没有任何竞态条件，因为在任何时候只允许一个 Goroutine 执行这段代码。</p><p>现在运行这个程序，它将输出</p><div class="code-wrapper"><pre><code class="hljs fallback">final value of x 1000</code></pre></div><p>重要的是要传递互斥锁的地址。如果互斥锁通过值传递而不是传递地址，每个 Goroutine 将有其自己的互斥锁副本，竞态条件仍然会发生。</p><h3 id="使用通道解决竞态条件"><a href="#使用通道解决竞态条件" class="headerlink" title="使用通道解决竞态条件"></a>使用通道解决竞态条件</h3><p>我们也可以使用通道来解决竞态条件。让我们看看如何实现。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;sync&quot;</span>)<span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increment</span><span class="hljs-params">(wg *sync.WaitGroup, ch <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)</span></span> &#123;    ch &lt;- <span class="hljs-literal">true</span>    x = x + <span class="hljs-number">1</span>    &lt;- ch    wg.Done()    &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">var</span> w sync.WaitGroup    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>, <span class="hljs-number">1</span>)    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;        w.Add(<span class="hljs-number">1</span>)                <span class="hljs-keyword">go</span> increment(&amp;w, ch)    &#125;    w.Wait()    fmt.Println(<span class="hljs-string">&quot;final value of x&quot;</span>, x)&#125;</code></pre></div><p><a href="https://play.golang.org/p/M1fPEK9lYz">在 playground 中运行</a></p><p>在上面的程序中，我们创建了一个容量为 <code>1</code> 的<a href="../%E3%80%90GolangBot%E3%80%9123-%E7%BC%93%E5%86%B2%E9%80%9A%E9%81%93%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%B1%A0">缓冲通道</a>，并将其传递给 <code>increment</code> Goroutine。这个缓冲通道用于确保只有一个 Goroutine 访问增加 x 的临界区代码。这是通过在增加 x 之前向缓冲通道传递 <code>true</code> 来实现的。由于缓冲通道的容量为 <code>1</code>，所有其他试图向该通道写入的 Goroutine 都会被阻塞，直到在增加 x 后从该通道读取值。这有效地只允许一个 Goroutine 访问临界区。</p><p>这个程序也会打印</p><div class="code-wrapper"><pre><code class="hljs fallback">final value of x 1000</code></pre></div><h3 id="互斥锁-vs-通道"><a href="#互斥锁-vs-通道" class="headerlink" title="互斥锁 vs 通道"></a>互斥锁 vs 通道</h3><p>我们已经使用互斥锁和通道解决了竞态条件问题。那么我们如何决定在什么时候使用什么呢？答案在于你试图解决的问题。如果你要解决的问题更适合使用互斥锁，那就使用互斥锁。如果需要的话，不要犹豫使用互斥锁。如果问题似乎更适合使用通道，那就使用它 :)。</p><p>大多数 Go 新手试图使用通道来解决每个并发问题，因为这是语言的一个很酷的特性。这是错误的。语言给了我们使用互斥锁或通道的选择，选择任何一个都没有错。</p><p>一般来说，当 Goroutine 需要相互通信时使用通道，当只有一个 Goroutine 需要访问代码的临界区时使用互斥锁。</p><p>对于我们上面解决的问题，我更倾向于使用互斥锁，因为这个问题不需要 goroutine 之间的任何通信。因此互斥锁会是一个自然的选择。</p><p>我的建议是为问题选择合适的工具，而不是试图让问题适应工具 :)</p><p><strong>下一篇教程 - <a href="../%E3%80%90GolangBot%E3%80%9126-%E7%BB%93%E6%9E%84%E4%BD%93%E4%BB%A3%E6%9B%BF%E7%B1%BB.md">Structs Instead of Classes</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GolangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】24-Select</title>
    <link href="/%E3%80%90GolangBot%E3%80%9124-Select/"/>
    <url>/%E3%80%90GolangBot%E3%80%9124-Select/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到 <a href="../golangbot/">Golang系列教程</a> 的第24篇教程。</p><h3 id="什么是-select？"><a href="#什么是-select？" class="headerlink" title="什么是 select？"></a>什么是 <em>select</em>？</h3><p><code>select</code> 语句用于在多个发送&#x2F;接收通道操作中进行选择。select 语句会阻塞，直到其中一个发送&#x2F;接收操作就绪。如果多个操作同时就绪，则会随机选择其中一个。其语法类似于 <code>switch</code>，只是每个 case 语句都将是一个通道操作。让我们直接通过一些代码来更好地理解。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">server1</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;time.Sleep(<span class="hljs-number">6</span> * time.Second)ch &lt;- <span class="hljs-string">&quot;from server1&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">server2</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;time.Sleep(<span class="hljs-number">3</span> * time.Second)ch &lt;- <span class="hljs-string">&quot;from server2&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;output1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)output2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<span class="hljs-keyword">go</span> server1(output1)<span class="hljs-keyword">go</span> server2(output2)<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> s1 := &lt;-output1:fmt.Println(s1)<span class="hljs-keyword">case</span> s2 := &lt;-output2:fmt.Println(s2)&#125;&#125;</code></pre></div><p><a href="https://play.golang.org/p/3_yaJSoSpG">在 playground 中运行</a></p><p>在上面的程序中，第8行的 <code>server1</code> 函数休眠6秒，然后将文本 <em>from server1</em> 写入通道 <code>ch</code>。第12行的 <code>server2</code> 函数休眠3秒，然后将 <em>from server2</em> 写入通道 <code>ch</code>。</p><p>main 函数在第20行和第21行分别调用 <code>server1</code> 和 <code>server2</code> Goroutine。</p><p>在第22行，控制流到达 <code>select</code> 语句。select 语句会阻塞，直到其中一个 case 就绪。在我们的程序中，server1 Goroutine 在6秒后写入 <code>output1</code> 通道，而 server2 在3秒后写入 <code>output2</code> 通道。因此，select 语句将阻塞3秒，等待 server2 Goroutine 写入 <code>output2</code> 通道。3秒后，程序打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">from server2</code></pre></div><p>然后终止。</p><h3 id="select-的实际用途"><a href="#select-的实际用途" class="headerlink" title="select 的实际用途"></a>select 的实际用途</h3><p>将上述程序中的函数命名为 <code>server1</code> 和 <code>server2</code> 的原因是为了说明 <em>select</em> 的实际用途。</p><p>假设我们有一个关键任务应用程序，需要尽快向用户返回输出。该应用程序的数据库已复制并存储在世界各地的不同服务器中。假设函数 <code>server1</code> 和 <code>server2</code> 实际上是在与两个这样的服务器通信。每个服务器的响应时间取决于各自的负载和网络延迟。我们向两个服务器发送请求，然后使用 <code>select</code> 语句在相应的通道上等待响应。select 会选择最先响应的服务器，而忽略另一个响应。这样，我们就可以向多个服务器发送相同的请求，并向用户返回最快的响应 :)。</p><h3 id="默认分支"><a href="#默认分支" class="headerlink" title="默认分支"></a>默认分支</h3><p>select 语句中的默认分支在没有其他 case 就绪时执行。这通常用于防止 select 语句阻塞。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">process</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;time.Sleep(<span class="hljs-number">10500</span> * time.Millisecond)ch &lt;- <span class="hljs-string">&quot;process successful&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<span class="hljs-keyword">go</span> process(ch)<span class="hljs-keyword">for</span> &#123;time.Sleep(<span class="hljs-number">1000</span> * time.Millisecond)<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> v := &lt;-ch:fmt.Println(<span class="hljs-string">&quot;received value: &quot;</span>, v)<span class="hljs-keyword">return</span><span class="hljs-keyword">default</span>:fmt.Println(<span class="hljs-string">&quot;no value received&quot;</span>)&#125;&#125;&#125;</code></pre></div><p><a href="https://play.golang.org/p/8xS5r9g1Uy">在 playground 中运行</a></p><p>在上面的程序中，第8行的 <code>process</code> 函数休眠10500毫秒（10.5秒），然后将 <code>process successful</code> 写入 <code>ch</code> 通道。这个函数在程序的第15行被并发调用。</p><p>在并发调用 process Goroutine 后，main Goroutine 中启动了一个无限 for 循环。无限循环在每次迭代开始时休眠1000毫秒（1秒），然后执行 select 操作。在前10500毫秒期间，select 语句的第一个 case（即 <code>case v := &lt;-ch:</code>）不会就绪，因为 process Goroutine 只会在10500毫秒后才向 ch 通道写入。因此，在此期间将执行 <code>default</code> 分支，程序将打印10次 <code>no value received</code>。</p><p>10.5秒后，process Goroutine 在第10行将 <code>process successful</code> 写入 ch。现在 select 语句的第一个 case 将被执行，程序将打印 <code>received value: process successful</code>，然后终止。这个程序的输出将是：</p><div class="code-wrapper"><pre><code class="hljs fallback">no value receivedno value receivedno value receivedno value receivedno value receivedno value receivedno value receivedno value receivedno value receivedno value receivedreceived value:  process successful</code></pre></div><h3 id="死锁和默认分支"><a href="#死锁和默认分支" class="headerlink" title="死锁和默认分支"></a>死锁和默认分支</h3><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> &lt;-ch:&#125;&#125;</code></pre></div><p><a href="https://play.golang.org/p/za0GZ4o7HH">在 playground 中运行</a></p><p>在上面的程序中，我们在第4行创建了一个通道 <code>ch</code>。我们尝试在第6行的 select 中从这个通道读取。由于没有其他 Goroutine 向这个通道写入，select 语句将永远阻塞，因此会导致死锁。这个程序将在运行时出现 panic，并显示以下消息：</p><div class="code-wrapper"><pre><code class="hljs fallback">fatal error: all goroutines are asleep - deadlock!goroutine 1 [chan receive]:main.main()/tmp/sandbox627739431/prog.go:6 +0x4d</code></pre></div><p>如果存在默认分支，则不会发生这种死锁，因为当没有其他 case 就绪时将执行默认分支。下面是添加了默认分支的程序重写版本。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> &lt;-ch:<span class="hljs-keyword">default</span>:fmt.Println(<span class="hljs-string">&quot;default case executed&quot;</span>)&#125;&#125;</code></pre></div><p><a href="https://play.golang.org/p/Pxsh_KlFUw">在 playground 中运行</a></p><p>上面的程序将打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">default case executed</code></pre></div><p>同样，即使 select 只有 <code>nil</code> 通道，默认分支也会被执行。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> ch <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span><span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> v := &lt;-ch:fmt.Println(<span class="hljs-string">&quot;received value&quot;</span>, v)<span class="hljs-keyword">default</span>:fmt.Println(<span class="hljs-string">&quot;default case executed&quot;</span>)&#125;&#125;</code></pre></div><p><a href="https://play.golang.org/p/IKmGpN61m1">在 playground 中运行</a></p><p>在上面的程序中，<code>ch</code> 是 <code>nil</code>，我们试图在第8行的 select 中从 <code>ch</code> 读取。如果没有 <code>default</code> 分支，<code>select</code> 将永远阻塞并导致死锁。由于我们在 select 中有默认分支，它将被执行，程序将打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">default case executed</code></pre></div><h3 id="随机选择"><a href="#随机选择" class="headerlink" title="随机选择"></a>随机选择</h3><p>当 <code>select</code> 语句中有多个 case 就绪时，将随机执行其中一个。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">server1</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;ch &lt;- <span class="hljs-string">&quot;from server1&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">server2</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;ch &lt;- <span class="hljs-string">&quot;from server2&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;output1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)output2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<span class="hljs-keyword">go</span> server1(output1)<span class="hljs-keyword">go</span> server2(output2)time.Sleep(<span class="hljs-number">1</span> * time.Second)<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> s1 := &lt;-output1:fmt.Println(s1)<span class="hljs-keyword">case</span> s2 := &lt;-output2:fmt.Println(s2)&#125;&#125;</code></pre></div><p><a href="https://play.golang.org/p/vJ6VhVl9YY">在 playground 中运行</a></p><p>在上面的程序中，server1 和 server2 goroutine 分别在第18行和第19行被调用。然后 main 程序在第20行休眠1秒。当控制流到达第21行的 select 语句时，server1 已经将 <code>from server1</code> 写入 <code>output1</code> 通道，server2 已经将 <code>from server2</code> 写入 <code>output2</code> 通道，因此 select 语句的两个 case 都准备就绪可以执行。如果多次运行这个程序，输出将在 <code>from server1</code> 和 <code>from server2</code> 之间随机变化，具体取决于随机选择的 case。</p><p>请在本地系统中运行此程序以获得这种随机性。如果在 playground 中运行此程序，它将打印相同的输出，因为 playground 是确定性的。</p><h3 id="注意事项-空-select"><a href="#注意事项-空-select" class="headerlink" title="注意事项 - 空 select"></a>注意事项 - 空 select</h3><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">select</span> &#123;&#125;&#125;</code></pre></div><p><a href="https://play.golang.org/p/u8hErIxgxs">在 playground 中运行</a></p><p>你认为上面程序的输出会是什么？</p><p>我们知道 select 语句将阻塞，直到其中一个 case 被执行。在这种情况下，select 语句没有任何 case，因此它将永远阻塞，导致死锁。这个程序将出现 panic，输出如下：</p><div class="code-wrapper"><pre><code class="hljs fallback">fatal error: all goroutines are asleep - deadlock!goroutine 1 [select (no cases)]:main.main()/tmp/sandbox246983342/prog.go:4 +0x25</code></pre></div><p><strong>下一篇教程 - <a href="https://golangbot.com/mutex/">Mutex</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GolangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】23-缓冲通道与工作池</title>
    <link href="/%E3%80%90GolangBot%E3%80%9123-%E7%BC%93%E5%86%B2%E9%80%9A%E9%81%93%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%B1%A0/"/>
    <url>/%E3%80%90GolangBot%E3%80%9123-%E7%BC%93%E5%86%B2%E9%80%9A%E9%81%93%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到<a href="../golangbot/">Golang系列教程</a>的第23讲。</p><h2 id="什么是缓冲通道？"><a href="#什么是缓冲通道？" class="headerlink" title="什么是缓冲通道？"></a>什么是缓冲通道？</h2><p>我们在<a href="../%E3%80%90GolangBot%E3%80%9122-Channels">上一篇教程</a>中讨论的所有通道基本上都是无缓冲的。正如我们在<a href="../%E3%80%90GolangBot%E3%80%9122-Channels">channels教程</a>中详细讨论的那样，对无缓冲通道的发送和接收都是阻塞的。</p><p>可以创建一个带缓冲的通道。只有当缓冲区已满时，向缓冲通道发送数据才会被阻塞。同样，只有当缓冲区为空时，从缓冲通道接收数据才会被阻塞。</p><p>通过向<code>make</code>函数传递一个额外的容量参数来创建缓冲通道，该参数指定了缓冲区的大小。</p><div class="code-wrapper"><pre><code class="hljs fallback">ch := make(chan type, capacity)</code></pre></div><p>上述语法中的<em>capacity</em>必须大于0才能使通道具有缓冲区。无缓冲通道的容量默认为0，因此我们在<a href="../%E3%80%90GolangBot%E3%80%9122-Channels">上一教程</a>中创建通道时省略了容量参数。</p><p>让我们编写一些代码并创建一个缓冲通道。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, <span class="hljs-number">2</span>)    ch &lt;- <span class="hljs-string">&quot;naveen&quot;</span>    ch &lt;- <span class="hljs-string">&quot;paul&quot;</span>    fmt.Println(&lt;- ch)    fmt.Println(&lt;- ch)&#125;</code></pre></div><p><a href="https://play.golang.org/p/It-em11etK">Run program in playground</a></p><p>在上面的程序中，第9行我们创建了一个容量为2的缓冲通道。由于通道的容量为2，所以可以向通道写入2个字符串而不会被阻塞。我们在第10行和第11行向通道写入2个字符串，通道不会阻塞。我们分别在第12行和第13行读取写入的2个字符串。这个程序打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">naveenpaul</code></pre></div><h3 id="另一个示例"><a href="#另一个示例" class="headerlink" title="另一个示例"></a>另一个示例</h3><p>让我们看一个缓冲通道的另一个示例，其中值是在并发Goroutine中写入通道，并从main Goroutine中读取。这个示例将帮助我们更好地理解向缓冲通道写入时何时会阻塞。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (      <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">write</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;      <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;        ch &lt;- i        fmt.Println(<span class="hljs-string">&quot;successfully wrote&quot;</span>, i, <span class="hljs-string">&quot;to ch&quot;</span>)    &#125;    <span class="hljs-built_in">close</span>(ch)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;      ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">2</span>)    <span class="hljs-keyword">go</span> write(ch)    time.Sleep(<span class="hljs-number">2</span> * time.Second)    <span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> ch &#123;        fmt.Println(<span class="hljs-string">&quot;read value&quot;</span>, v,<span class="hljs-string">&quot;from ch&quot;</span>)        time.Sleep(<span class="hljs-number">2</span> * time.Second)    &#125;&#125;</code></pre></div><p><a href="https://play.golang.org/p/bKe5GdgMK9">Run program in playground</a></p><p>在上面的程序中，在main Goroutine的第16行创建了一个容量为<code>2</code>的缓冲通道<code>ch</code>，并在第17行传递给write Goroutine。然后main Goroutine休眠2秒。在此期间，write Goroutine并发运行。write Goroutine有一个<code>for</code>循环，将数字0到4写入<code>ch</code>通道。这个缓冲通道的容量是<code>2</code>，因此write <code>Goroutine</code>将能够立即将值<code>0</code>和<code>1</code>写入<code>ch</code>通道，然后它会阻塞，直到至少从<code>ch</code>通道读取一个值。所以这个程序会立即打印以下2行。</p><div class="code-wrapper"><pre><code class="hljs fallback">successfully wrote 0 to chsuccessfully wrote 1 to ch</code></pre></div><p>打印完上面两行后，write Goroutine中向<code>ch</code>通道的写入会被阻塞，直到有人从<code>ch</code>通道读取。由于main Goroutine在开始从通道读取之前休眠2秒，所以程序在接下来的2秒内不会打印任何内容。main Goroutine在2秒后醒来，并开始使用第19行的<code>for range</code>循环从<code>ch</code>通道读取，打印读取的值，然后再次休眠2秒，这个循环继续，直到<code>ch</code>被关闭。所以程序会在2秒后打印以下行：</p><div class="code-wrapper"><pre><code class="hljs fallback">read value 0 from chsuccessfully wrote 2 to ch</code></pre></div><p>这将持续到所有值都写入通道并在write Goroutine中关闭。最终输出将是：</p><div class="code-wrapper"><pre><code class="hljs fallback">successfully wrote 0 to chsuccessfully wrote 1 to chread value 0 from chsuccessfully wrote 2 to chread value 1 from chsuccessfully wrote 3 to chread value 2 from chsuccessfully wrote 4 to chread value 3 from chread value 4 from ch</code></pre></div><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, <span class="hljs-number">2</span>)    ch &lt;- <span class="hljs-string">&quot;naveen&quot;</span>    ch &lt;- <span class="hljs-string">&quot;paul&quot;</span>    ch &lt;- <span class="hljs-string">&quot;steve&quot;</span>    fmt.Println(&lt;-ch)    fmt.Println(&lt;-ch)&#125;</code></pre></div><p><a href="https://play.golang.org/p/FW-LHeH7oD">Run program in playground</a></p><p>在上面的程序中，我们向一个容量为2的缓冲通道写入3个字符串。当控制到达第11行的第三次写入时，写入被阻塞，因为通道已超出其容量。现在必须有某个Goroutine从通道读取，写入才能继续进行，但在这种情况下，没有并发的例程从这个通道读取。因此会出现<strong>死锁</strong>，程序会在运行时出现panic，并显示以下消息：</p><div class="code-wrapper"><pre><code class="hljs fallback">fatal error: all goroutines are asleep - deadlock!goroutine 1 [chan send]:main.main()/tmp/sandbox091448810/prog.go:11 +0x8d</code></pre></div><h3 id="关闭缓冲通道"><a href="#关闭缓冲通道" class="headerlink" title="关闭缓冲通道"></a>关闭缓冲通道</h3><p>我们已经在<a href="../%E3%80%90GolangBot%E3%80%9123-%E7%BC%93%E5%86%B2%E9%80%9A%E9%81%93%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%B1%A0/#%E5%85%B3%E9%97%AD%E7%BC%93%E5%86%B2%E9%80%9A%E9%81%93">上一教程</a>中讨论了关闭通道。除了我们在上一教程中学到的内容外，关闭缓冲通道时还有一个需要考虑的细节。</p><p>可以从已关闭的缓冲通道读取数据。通道将返回已写入通道的数据，一旦所有数据都被读取，它将返回通道的零值。</p><p>让我们编写一个程序来理解这一点。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">5</span>)    ch &lt;- <span class="hljs-number">5</span>    ch &lt;- <span class="hljs-number">6</span>    <span class="hljs-built_in">close</span>(ch)    n, open := &lt;-ch     fmt.Printf(<span class="hljs-string">&quot;Received: %d, open: %t\n&quot;</span>, n, open)    n, open = &lt;-ch     fmt.Printf(<span class="hljs-string">&quot;Received: %d, open: %t\n&quot;</span>, n, open)    n, open = &lt;-ch     fmt.Printf(<span class="hljs-string">&quot;Received: %d, open: %t\n&quot;</span>, n, open)&#125;</code></pre></div><p><a href="https://play.golang.org/p/19cZrsy2X4v">Run program in playground</a></p><p>在上面的程序中，我们在第8行创建了一个容量为<code>5</code>的缓冲通道。然后我们向通道写入<code>5</code>和<code>6</code>。通道在第11行之后关闭。即使通道已关闭，我们仍然可以读取已写入通道的值。这是在第12行和第14行完成的。在第12行，<code>n</code>的值将是<code>5</code>，open将是<code>true</code>。在第14行，<code>n</code>的值将是<code>6</code>，open再次为<code>true</code>。我们现在已经读取了通道中的<code>5</code>和<code>6</code>，没有更多的数据可读。现在当在第16行再次读取通道时，<code>n</code>的值将是<code>0</code>，这是<code>int</code>的零值，<code>open</code>将是<code>false</code>，表示通道已关闭。</p><p>这个程序将打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">Received: 5, open: trueReceived: 6, open: trueReceived: 0, open: false</code></pre></div><p>同样的程序也可以使用for range循环来编写。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">5</span>)ch &lt;- <span class="hljs-number">5</span>ch &lt;- <span class="hljs-number">6</span><span class="hljs-built_in">close</span>(ch)<span class="hljs-keyword">for</span> n := <span class="hljs-keyword">range</span> ch &#123;fmt.Println(<span class="hljs-string">&quot;Received:&quot;</span>, n)&#125;&#125;</code></pre></div><p><a href="https://play.golang.org/p/xVgkn64Jado">Run program in playground</a></p><p>上面程序第12行的<code>for range</code>循环将读取写入通道的所有值，并在没有更多值可读时退出，因为通道已经关闭。</p><p>这个程序将打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">Received: 5Received: 6</code></pre></div><h3 id="长度与容量"><a href="#长度与容量" class="headerlink" title="长度与容量"></a>长度与容量</h3><p>缓冲通道的容量是通道可以容纳的值的数量。这是我们使用<code>make</code>函数创建缓冲通道时指定的值。</p><p>缓冲通道的长度是当前队列中的元素数量。</p><p>一个程序可以让事情变得清晰 😀</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, <span class="hljs-number">3</span>)    ch &lt;- <span class="hljs-string">&quot;naveen&quot;</span>    ch &lt;- <span class="hljs-string">&quot;paul&quot;</span>    fmt.Println(<span class="hljs-string">&quot;capacity is&quot;</span>, <span class="hljs-built_in">cap</span>(ch))    fmt.Println(<span class="hljs-string">&quot;length is&quot;</span>, <span class="hljs-built_in">len</span>(ch))    fmt.Println(<span class="hljs-string">&quot;read value&quot;</span>, &lt;-ch)    fmt.Println(<span class="hljs-string">&quot;new length is&quot;</span>, <span class="hljs-built_in">len</span>(ch))&#125;</code></pre></div><p><a href="https://play.golang.org/p/2ggC64yyvr">Run program in playground</a></p><p>在上面的程序中，通道创建时的容量为<code>3</code>，也就是说它可以容纳3个字符串。然后我们在第9行和第10行分别向通道写入2个字符串。现在通道中有2个字符串排队，因此其长度为<code>2</code>。在第13行，我们从通道读取一个字符串。现在通道中只有一个字符串排队，因此其长度变为<code>1</code>。这个程序将打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">capacity is 3length is 2read value naveennew length is 1</code></pre></div><h3 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h3><p>本教程的下一节是关于<em>Worker Pools</em>。为了理解worker pools，我们首先需要了解<code>WaitGroup</code>，因为它将在Worker pool的实现中使用。</p><p>WaitGroup用于等待一组Goroutines完成执行。控制会被阻塞，直到所有Goroutines完成执行。假设我们有3个从<code>main</code> Goroutine生成的并发执行的Goroutines。<code>main</code> Goroutines需要等待其他3个Goroutines完成才能终止。这可以使用WaitGroup来实现。</p><p>让我们停止理论，直接开始编写代码 😀</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;sync&quot;</span><span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">process</span><span class="hljs-params">(i <span class="hljs-type">int</span>, wg *sync.WaitGroup)</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;started Goroutine &quot;</span>, i)time.Sleep(<span class="hljs-number">2</span> * time.Second)fmt.Printf(<span class="hljs-string">&quot;Goroutine %d ended\n&quot;</span>, i)wg.Done()&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;no := <span class="hljs-number">3</span><span class="hljs-keyword">var</span> wg sync.WaitGroup<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; no; i++ &#123;wg.Add(<span class="hljs-number">1</span>)<span class="hljs-keyword">go</span> process(i, &amp;wg)&#125;wg.Wait()fmt.Println(<span class="hljs-string">&quot;All go routines finished executing&quot;</span>)&#125;</code></pre></div><p><a href="https://play.golang.org/p/CZNtu8ktQh">Run in playground</a></p><p><a href="https://golang.org/pkg/sync/#WaitGroup">WaitGroup</a>是一个结构类型，我们在第18行创建了一个WaitGroup类型的零值变量。WaitGroup的工作方式是通过使用计数器。当我们对WaitGroup调用<code>Add</code>并传递一个<code>int</code>时，WaitGroup的计数器会增加传递给<code>Add</code>的值。减少计数器的方法是在WaitGroup上调用<code>Done()</code>方法。<code>Wait()</code>方法会阻塞调用它的<code>Goroutine</code>，直到计数器变为零。</p><p>在上面的程序中，我们在第20行的<code>for</code>循环内调用<code>wg.Add(1)</code>，循环迭代3次。所以计数器现在变成3。<code>for</code>循环还生成了3个<code>process</code> Goroutines，然后在第23行调用的<code>wg.Wait()</code>使<code>main</code> Goroutine等待，直到计数器变为零。计数器通过在<code>process</code> Goroutine中第13行调用<code>wg.Done</code>来递减。一旦所有3个生成的Goroutines完成执行，也就是<code>wg.Done()</code>被调用三次，计数器将变为零，main Goroutine将被解除阻塞。</p><p><strong>在第21行传递<code>wg</code>的指针很重要。如果不传递指针，那么每个Goroutine将有自己的WaitGroup副本，并且main不会在它们完成执行时得到通知。</strong></p><p>这个程序输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">started Goroutine  2started Goroutine  0started Goroutine  1Goroutine 0 endedGoroutine 2 endedGoroutine 1 endedAll go routines finished executing</code></pre></div><p>你的输出可能与我的不同，因为Goroutines的执行顺序可能会有所不同 :)。</p><h3 id="Worker-Pool-实现"><a href="#Worker-Pool-实现" class="headerlink" title="Worker Pool 实现"></a>Worker Pool 实现</h3><p>缓冲通道的一个重要用途是实现<a href="https://en.wikipedia.org/wiki/Thread_pool">worker pool</a>。</p><p>一般来说，worker pool是等待分配任务的线程集合。一旦他们完成分配的任务，就会再次变得可用于下一个任务。</p><p>我们将使用缓冲通道来实现worker pool。我们的worker pool将执行找出输入数字的各位数字之和的任务。例如，如果传入234，输出将是9（2 + 3 + 4）。worker pool的输入将是一个伪随机整数列表。</p><p>以下是我们worker pool的核心功能：</p><ul><li>创建一个监听输入缓冲通道的Goroutine池，等待分配任务</li><li>向输入缓冲通道添加任务</li><li>任务完成后将结果写入输出缓冲通道</li><li>从输出缓冲通道读取并打印结果</li></ul><p>我们将逐步编写这个程序，以使其更容易理解。</p><p>第一步将是创建表示任务和结果的结构体。</p><div class="code-wrapper"><pre><code class="hljs fallback">type Job struct &#123;    id       int    randomno int&#125;type Result struct &#123;    job         Job    sumofdigits int&#125;</code></pre></div><p>每个<code>Job</code>结构体都有一个<code>id</code>和一个需要计算各位数字之和的<code>randomno</code>。</p><p><code>Result</code>结构体有一个<code>job</code>字段，它是持有结果（各位数字之和）的任务，结果存储在<code>sumofdigits</code>字段中。</p><p>下一步是创建用于接收任务和写入输出的缓冲通道。</p><div class="code-wrapper"><pre><code class="hljs fallback">var jobs = make(chan Job, 10)var results = make(chan Result, 10)</code></pre></div><p>Worker Goroutines监听<code>jobs</code>缓冲通道等待新任务。一旦任务完成，结果就会写入<code>results</code>缓冲通道。</p><p>下面的<code>digits</code>函数实际执行找出整数各位数字之和并返回的任务。我们将在这个函数中添加2秒的休眠，只是为了模拟这个函数需要一些时间来计算结果。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">digits</span><span class="hljs-params">(number <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    sum := <span class="hljs-number">0</span>    no := number    <span class="hljs-keyword">for</span> no != <span class="hljs-number">0</span> &#123;        digit := no % <span class="hljs-number">10</span>        sum += digit        no /= <span class="hljs-number">10</span>    &#125;    time.Sleep(<span class="hljs-number">2</span> * time.Second)    <span class="hljs-keyword">return</span> sum&#125;</code></pre></div><p>接下来，我们将编写一个创建worker Goroutine的函数。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">(wg *sync.WaitGroup)</span></span> &#123;    <span class="hljs-keyword">for</span> job := <span class="hljs-keyword">range</span> jobs &#123;        output := Result&#123;job, digits(job.randomno)&#125;        results &lt;- output    &#125;    wg.Done()&#125;</code></pre></div><p>上面的函数创建一个worker，它从<code>jobs</code>通道读取，使用当前的<code>job</code>和<code>digits</code>函数的返回值创建一个<code>Result</code>结构体，然后将结果写入<code>results</code>缓冲通道。这个函数接受一个WaitGroup <code>wg</code>作为参数，当所有<code>jobs</code>完成时，它将在该参数上调用<code>Done()</code>方法。</p><p><code>createWorkerPool</code>函数将创建一个worker Goroutine池。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createWorkerPool</span><span class="hljs-params">(noOfWorkers <span class="hljs-type">int</span>)</span></span> &#123;    <span class="hljs-keyword">var</span> wg sync.WaitGroup    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; noOfWorkers; i++ &#123;        wg.Add(<span class="hljs-number">1</span>)        <span class="hljs-keyword">go</span> worker(&amp;wg)    &#125;    wg.Wait()    <span class="hljs-built_in">close</span>(results)&#125;</code></pre></div><p>上面的函数接受要创建的workers数量作为参数。在创建Goroutine之前调用<code>wg.Add(1)</code>来增加WaitGroup计数器。然后通过将WaitGroup <code>wg</code>的指针传递给<code>worker</code>函数来创建worker Goroutines。创建完所需的worker Goroutines后，它通过调用<code>wg.Wait()</code>等待所有Goroutines完成执行。在所有Goroutines完成执行后，它关闭<code>results</code>通道，因为所有Goroutines都已完成执行，没有人会进一步写入<code>results</code>通道。</p><p>现在我们已经准备好worker pool，让我们继续编写将任务分配给workers的函数。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">allocate</span><span class="hljs-params">(noOfJobs <span class="hljs-type">int</span>)</span></span> &#123;    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; noOfJobs; i++ &#123;        randomno := rand.Intn(<span class="hljs-number">999</span>)        job := Job&#123;i, randomno&#125;        jobs &lt;- job    &#125;    <span class="hljs-built_in">close</span>(jobs)&#125;</code></pre></div><p>上面的<code>allocate</code>函数接受要创建的任务数量作为输入参数，生成最大值为<code>998</code>的伪随机数，使用随机数和for循环计数器<code>i</code>作为id创建<code>Job</code>结构体，然后将它们写入<code>jobs</code>通道。写入所有任务后关闭<code>jobs</code>通道。</p><p>下一步将是创建读取<code>results</code>通道并打印输出的函数。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">result</span><span class="hljs-params">(done <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)</span></span> &#123;    <span class="hljs-keyword">for</span> result := <span class="hljs-keyword">range</span> results &#123;        fmt.Printf(<span class="hljs-string">&quot;Job id %d, input random no %d , sum of digits %d\n&quot;</span>, result.job.id, result.job.randomno, result.sumofdigits)    &#125;    done &lt;- <span class="hljs-literal">true</span>&#125;</code></pre></div><p><code>result</code>函数读取<code>results</code>通道并打印任务id、输入随机数和随机数的各位数字之和。result函数还接受一个<code>done</code>通道作为参数，一旦打印完所有结果就向该通道写入。</p><p>现在我们已经准备就绪。让我们继续最后一步，从<code>main()</code>函数调用所有这些函数。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    startTime := time.Now()    noOfJobs := <span class="hljs-number">100</span>    <span class="hljs-keyword">go</span> allocate(noOfJobs)    done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)    <span class="hljs-keyword">go</span> result(done)    noOfWorkers := <span class="hljs-number">10</span>    createWorkerPool(noOfWorkers)    &lt;-done    endTime := time.Now()    diff := endTime.Sub(startTime)    fmt.Println(<span class="hljs-string">&quot;total time taken &quot;</span>, diff.Seconds(), <span class="hljs-string">&quot;seconds&quot;</span>)&#125;</code></pre></div><p>我们首先在main函数的第2行存储程序的执行开始时间，在最后一行（第12行）我们计算endTime和startTime之间的时间差，并显示程序运行所需的总时间。这是必需的，因为我们将通过改变Goroutines的数量来做一些基准测试。</p><p><code>noOfJobs</code>设置为100，然后调用<code>allocate</code>向<code>jobs</code>通道添加任务。</p><p>然后创建<code>done</code>通道并传递给<code>result</code> Goroutine，这样它就可以开始打印输出并在一切都打印完成时通知。</p><p>最后通过调用<code>createWorkerPool</code>函数创建一个包含<code>10</code>个worker Goroutines的池，然后main在<code>done</code>通道上等待所有结果打印完成。</p><p>这是完整的程序供你参考。我也导入了必要的包。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;math/rand&quot;</span>    <span class="hljs-string">&quot;sync&quot;</span>    <span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-keyword">type</span> Job <span class="hljs-keyword">struct</span> &#123;    id       <span class="hljs-type">int</span>    randomno <span class="hljs-type">int</span>&#125;<span class="hljs-keyword">type</span> Result <span class="hljs-keyword">struct</span> &#123;    job         Job    sumofdigits <span class="hljs-type">int</span>&#125;<span class="hljs-keyword">var</span> jobs = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Job, <span class="hljs-number">10</span>)<span class="hljs-keyword">var</span> results = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Result, <span class="hljs-number">10</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">digits</span><span class="hljs-params">(number <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    sum := <span class="hljs-number">0</span>    no := number    <span class="hljs-keyword">for</span> no != <span class="hljs-number">0</span> &#123;        digit := no % <span class="hljs-number">10</span>        sum += digit        no /= <span class="hljs-number">10</span>    &#125;    time.Sleep(<span class="hljs-number">2</span> * time.Second)    <span class="hljs-keyword">return</span> sum&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">(wg *sync.WaitGroup)</span></span> &#123;    <span class="hljs-keyword">for</span> job := <span class="hljs-keyword">range</span> jobs &#123;        output := Result&#123;job, digits(job.randomno)&#125;        results &lt;- output    &#125;    wg.Done()&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createWorkerPool</span><span class="hljs-params">(noOfWorkers <span class="hljs-type">int</span>)</span></span> &#123;    <span class="hljs-keyword">var</span> wg sync.WaitGroup    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; noOfWorkers; i++ &#123;        wg.Add(<span class="hljs-number">1</span>)        <span class="hljs-keyword">go</span> worker(&amp;wg)    &#125;    wg.Wait()    <span class="hljs-built_in">close</span>(results)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">allocate</span><span class="hljs-params">(noOfJobs <span class="hljs-type">int</span>)</span></span> &#123;    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; noOfJobs; i++ &#123;        randomno := rand.Intn(<span class="hljs-number">999</span>)        job := Job&#123;i, randomno&#125;        jobs &lt;- job    &#125;    <span class="hljs-built_in">close</span>(jobs)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">result</span><span class="hljs-params">(done <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)</span></span> &#123;    <span class="hljs-keyword">for</span> result := <span class="hljs-keyword">range</span> results &#123;        fmt.Printf(<span class="hljs-string">&quot;Job id %d, input random no %d , sum of digits %d\n&quot;</span>, result.job.id, result.job.randomno, result.sumofdigits)    &#125;    done &lt;- <span class="hljs-literal">true</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    startTime := time.Now()    noOfJobs := <span class="hljs-number">100</span>    <span class="hljs-keyword">go</span> allocate(noOfJobs)    done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)    <span class="hljs-keyword">go</span> result(done)    noOfWorkers := <span class="hljs-number">10</span>    createWorkerPool(noOfWorkers)    &lt;-done    endTime := time.Now()    diff := endTime.Sub(startTime)    fmt.Println(<span class="hljs-string">&quot;total time taken &quot;</span>, diff.Seconds(), <span class="hljs-string">&quot;seconds&quot;</span>)&#125;</code></pre></div><p><a href="https://play.golang.org/p/au5islUIbx">Run in playground</a></p><p>请在本地机器上运行此程序以获得更准确的总时间计算。</p><p>这个程序将打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">Job id 1, input random no 636, sum of digits 15Job id 0, input random no 878, sum of digits 23Job id 9, input random no 150, sum of digits 6...total time taken  20.01081009 seconds</code></pre></div><p>将打印总共100行，对应100个任务，然后最后一行打印程序运行的总时间。你的输出会与我的不同，因为Goroutines可以以任何顺序运行，总时间也会根据硬件而变化。在我的情况下，程序完成大约需要20秒。</p><p>现在让我们将<code>main</code>函数中的<code>noOfWorkers</code>增加到<code>20</code>。我们已经将workers的数量翻倍了。由于worker Goroutines增加了（准确地说是翻倍），程序完成所需的总时间应该减少（准确地说是减半）。在我的情况下，它变成了10.004364685秒，程序打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">...total time taken  10.004364685 seconds</code></pre></div><p>现在我们可以理解，随着worker Goroutines数量的增加，完成任务所需的总时间会减少。我把它作为一个练习留给你，在<code>main</code>函数中将<code>noOfJobs</code>和<code>noOfWorkers</code>设置为不同的值并分析结果。</p><p><strong>下一教程 - <a href="../%E3%80%90GolangBot%E3%80%9124-Select">Select</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GolangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】22-Channels</title>
    <link href="/%E3%80%90GolangBot%E3%80%9122-Channels/"/>
    <url>/%E3%80%90GolangBot%E3%80%9122-Channels/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到 <a href="../golangbot">Golang系列教程</a> 的第22篇教程。</p><p>在<a href="../%E3%80%90GolangBot%E3%80%9121-Goroutines">上一篇教程</a>中，我们讨论了如何使用 Goroutines 在 Go 中实现并发。在本教程中，我们将讨论 channels 以及 Goroutines 如何通过 channels 进行通信。</p><h3 id="什么是-channels"><a href="#什么是-channels" class="headerlink" title="什么是 channels"></a>什么是 channels</h3><p>Channels 可以被视为 Goroutines 通过它进行通信的管道。就像水在管道中从一端流向另一端一样，数据可以通过 channels 从一端发送并从另一端接收。</p><h3 id="声明-channels"><a href="#声明-channels" class="headerlink" title="声明 channels"></a>声明 channels</h3><p>每个 channel 都有一个与之关联的类型。这个类型就是该 channel 允许传输的数据类型。不允许使用该 channel 传输其他类型的数据。</p><p><em>chan T</em> 是一个类型为 <code>T</code> 的 channel</p><p>Channel 的零值是 <code>nil</code>。<code>nil</code> channels 没有任何用处，因此必须使用 <code>make</code> 来定义 channel，这与 <a href="../%E3%80%90GolangBot%E3%80%9113-Maps">maps</a> 和 <a href="../%E3%80%90GolangBot%E3%80%9111-%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87">slices</a> 类似。</p><p>让我们编写一些声明 channel 的代码。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">var</span> a <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>    <span class="hljs-keyword">if</span> a == <span class="hljs-literal">nil</span> &#123;        fmt.Println(<span class="hljs-string">&quot;channel a is nil, going to define it&quot;</span>)        a = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)        fmt.Printf(<span class="hljs-string">&quot;Type of a is %T&quot;</span>, a)    &#125;&#125;</code></pre></div><p><a href="https://play.golang.org/p/QDtf6mvymD">在 playground 中运行程序</a></p><p>第 6 行声明的 channel <code>a</code> 是 <code>nil</code>，因为 channel 的零值是 <code>nil</code>。因此 if 条件内的语句被执行，并定义了该 channel。在上面的程序中，<code>a</code> 是一个 int 类型的 channel。该程序将输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">channel a is nil, going to define itType of a is chan int</code></pre></div><p>像往常一样，使用简短声明也是定义 channel 的一种有效且简洁的方式。</p><div class="code-wrapper"><pre><code class="hljs fallback">a := make(chan int)</code></pre></div><p>上面的代码行同样定义了一个 int 类型的 channel <code>a</code>。</p><h3 id="通过-channel-发送和接收数据"><a href="#通过-channel-发送和接收数据" class="headerlink" title="通过 channel 发送和接收数据"></a>通过 channel 发送和接收数据</h3><p>从 channel 发送和接收数据的语法如下：</p><div class="code-wrapper"><pre><code class="hljs fallback">data := &lt;- a // 从 channel a 中读取数据a &lt;- data // 向 channel a 写入数据</code></pre></div><p>箭头相对于 channel 的方向指定了数据是被发送还是被接收。</p><p>在第一行中，箭头指向远离 <code>a</code> 的方向，因此我们是从 channel <code>a</code> 读取数据并将值存储到变量 data 中。</p><p>在第二行中，箭头指向 <code>a</code>，因此我们是向 channel <code>a</code> 写入数据。</p><h3 id="发送和接收默认是阻塞的"><a href="#发送和接收默认是阻塞的" class="headerlink" title="发送和接收默认是阻塞的"></a>发送和接收默认是阻塞的</h3><p>向 channel 发送和接收数据默认是阻塞的。这是什么意思？当数据被发送到一个 channel 时，发送语句会被阻塞，直到其他 Goroutine 从该 channel 中读取数据。同样，当从一个 channel 中读取数据时，读取操作会被阻塞，直到某个 Goroutine 向该 channel 写入数据。</p><p>channels 的这个特性使得 Goroutines 能够有效地通信，而无需使用在其他编程语言中常见的显式锁或条件变量。</p><p>如果现在这些还不太理解也没关系。接下来的章节将更清楚地说明 channels 是如何默认阻塞的。</p><h3 id="Channel-示例程序"><a href="#Channel-示例程序" class="headerlink" title="Channel 示例程序"></a>Channel 示例程序</h3><p>理论说够了 :)。让我们编写一个程序来理解 Goroutines 是如何使用 channels 进行通信的。</p><p>我们实际上将重写我们在学习 <a href="../GolangBot%E3%80%9121-Goroutines">Goroutines</a> 时编写的程序。</p><p>让我从上一个教程中引用这个程序。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (      <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> &#123;      fmt.Println(<span class="hljs-string">&quot;Hello world goroutine&quot;</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;      <span class="hljs-keyword">go</span> hello()    time.Sleep(<span class="hljs-number">1</span> * time.Second)    fmt.Println(<span class="hljs-string">&quot;main function&quot;</span>)&#125;</code></pre></div><p><a href="https://play.golang.org/p/U9ZZuSql8-">在 playground 中运行程序</a></p><p>这是上一个教程中的程序。我们在这里使用 sleep 来让 main Goroutine 等待 hello Goroutine 完成。如果这对你来说没有意义，我建议阅读关于 <a href="../GolangBot%E3%80%9121-Goroutines">Goroutines</a> 的教程。</p><p>我们将使用 channels 重写上面的程序。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(done <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)</span></span> &#123;    fmt.Println(<span class="hljs-string">&quot;Hello world goroutine&quot;</span>)    done &lt;- <span class="hljs-literal">true</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)    <span class="hljs-keyword">go</span> hello(done)    &lt;-done    fmt.Println(<span class="hljs-string">&quot;main function&quot;</span>)&#125;</code></pre></div><p><a href="https://play.golang.org/p/I8goKv6ZMF">在 playground 中运行程序</a></p><p>在上面的程序中，我们在第 12 行创建了一个 <code>done</code> bool channel，并将其作为参数传递给 <code>hello</code> Goroutine。在第 14 行，我们正在从 <code>done</code> channel 接收数据。这行代码是阻塞的，这意味着在某个 Goroutine 向 <code>done</code> channel 写入数据之前，控制不会移动到下一行代码。因此，这就消除了在原始程序中使用 <code>time.Sleep</code> 来防止 main Goroutine 退出的需求。</p><p>代码行 <code>&lt;-done</code> 从 done channel 接收数据，但不使用或存储该数据到任何变量中。这是完全合法的。</p><p>现在我们的 <code>main</code> Goroutine 被阻塞，等待 done channel 上的数据。<code>hello</code> Goroutine 将这个 channel 作为参数接收，打印 <code>Hello world goroutine</code>，然后向 <code>done</code> channel 写入数据。当这个写入完成时，main Goroutine 从 done channel 接收数据，它被解除阻塞，然后打印文本 <em>main function</em>。</p><p>这个程序输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">Hello world goroutinemain function</code></pre></div><p>让我们通过在 <code>hello</code> Goroutine 中引入一个 sleep 来修改这个程序，以更好地理解这个阻塞概念。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(done <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)</span></span> &#123;    fmt.Println(<span class="hljs-string">&quot;hello go routine is going to sleep&quot;</span>)    time.Sleep(<span class="hljs-number">4</span> * time.Second)    fmt.Println(<span class="hljs-string">&quot;hello go routine awake and going to write to done&quot;</span>)    done &lt;- <span class="hljs-literal">true</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)    fmt.Println(<span class="hljs-string">&quot;Main going to call hello go goroutine&quot;</span>)    <span class="hljs-keyword">go</span> hello(done)    &lt;-done    fmt.Println(<span class="hljs-string">&quot;Main received data&quot;</span>)&#125;</code></pre></div><p><a href="https://play.golang.org/p/EejiO-yjUQ">在 playground 中运行</a></p><p>在上面的程序中，我们在第 10 行为 <code>hello</code> 函数添加了 4 秒钟的睡眠时间。</p><p>这个程序首先会打印 <code>Main going to call hello go goroutine</code>。然后 hello Goroutine 将启动并打印 <code>hello go routine is going to sleep</code>。打印完这个后，<code>hello</code> Goroutine 将睡眠 4 秒钟，在此期间 <code>main</code> Goroutine 将被阻塞，因为它在第 18 行 <code>&lt;-done</code> 等待来自 done channel 的数据。4 秒后，将打印 <code>hello go routine awake and going to write to done</code>，然后是 <code>Main received data</code>。</p><h3 id="Channel-的另一个示例"><a href="#Channel-的另一个示例" class="headerlink" title="Channel 的另一个示例"></a>Channel 的另一个示例</h3><p>让我们再写一个程序来更好地理解 channels。这个程序将打印一个数字的各个数字的平方和与立方和。</p><p>例如，如果输入是 123，那么这个程序将计算输出为：</p><p>平方和 &#x3D; (1 * 1) + (2 * 2) + (3 * 3)<br>立方和 &#x3D; (1 * 1 * 1) + (2 * 2 * 2) + (3 * 3 * 3)<br>输出 &#x3D; 平方和 + 立方和 &#x3D; 50</p><p>我们将这样组织程序：在一个单独的 Goroutine 中计算平方和，在另一个 Goroutine 中计算立方和，最后的求和在 main Goroutine 中进行。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (      <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calcSquares</span><span class="hljs-params">(number <span class="hljs-type">int</span>, squareop <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;      sum := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> number != <span class="hljs-number">0</span> &#123;        digit := number % <span class="hljs-number">10</span>        sum += digit * digit        number /= <span class="hljs-number">10</span>    &#125;    squareop &lt;- sum&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calcCubes</span><span class="hljs-params">(number <span class="hljs-type">int</span>, cubeop <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;      sum := <span class="hljs-number">0</span>     <span class="hljs-keyword">for</span> number != <span class="hljs-number">0</span> &#123;        digit := number % <span class="hljs-number">10</span>        sum += digit * digit * digit        number /= <span class="hljs-number">10</span>    &#125;    cubeop &lt;- sum&#125; <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;      number := <span class="hljs-number">589</span>    sqrch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)    cubech := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)    <span class="hljs-keyword">go</span> calcSquares(number, sqrch)    <span class="hljs-keyword">go</span> calcCubes(number, cubech)    squares, cubes := &lt;-sqrch, &lt;-cubech    fmt.Println(<span class="hljs-string">&quot;Final output&quot;</span>, squares + cubes)&#125;</code></pre></div><p><a href="https://play.golang.org/p/4RKr7_YO_B">在 playground 中运行程序</a></p><p>第 7 行的 <code>calcSquares</code> 函数计算数字各个位的平方和，并将结果发送到 <code>squareop</code> channel。类似地，第 17 行的 <code>calcCubes</code> 函数计算数字各个位的立方和，并将结果发送到 <code>cubeop</code> channel。</p><p>这两个函数在第 31 和 32 行作为单独的 Goroutines 运行，每个都传递了一个用于写入的 channel 作为参数。main Goroutine 在第 33 行等待这两个 channels 的数据。一旦从两个 channels 接收到数据，它们就被存储在 <code>squares</code> 和 <code>cubes</code> 变量中，最终输出被计算并打印。这个程序将打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">Final output 1536</code></pre></div><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>使用 channels 时要考虑的一个重要因素是死锁。如果一个 Goroutine 正在向一个 channel 发送数据，就期望其他一些 Goroutine 应该接收数据。如果这种情况没有发生，程序将在运行时出现 <code>Deadlock</code> panic。</p><p>同样，如果一个 Goroutine 正在等待从一个 channel 接收数据，那么就期望其他一些 Goroutine 会向该 channel 写入数据，否则程序将出现panic。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)    ch &lt;- <span class="hljs-number">5</span>&#125;</code></pre></div><p><a href="https://play.golang.org/p/q1O5sNx4aW">在 playground 中运行程序</a></p><p>在上面的程序中，创建了一个 channel <code>ch</code>，我们在第 6 行 <code>ch &lt;- 5</code> 向该 channel 发送 5。在这个程序中，没有其他 Goroutine 从 channel <code>ch</code> 接收数据。因此这个程序会出现以下运行时错误的panic：</p><div class="code-wrapper"><pre><code class="hljs fallback">fatal error: all goroutines are asleep - deadlock!goroutine 1 [chan send]:main.main()    /tmp/sandbox046150166/prog.go:6 +0x50</code></pre></div><hr><p>下面是我自己补充的内容，非原作者内容：</p><p>关于死锁，我自己补充一点，考虑清楚以下几个问题就基本能捋顺了。首先搞清楚一个概念，在触发死锁panic时，提示为<code>fatal error: all goroutines are asleep - deadlock!</code>。也就是说，当包括main Goroutine在内的所有Goroutine都阻塞的时候，程序才会触发死锁。那么来看下面的程序，</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(done <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;Hello world goroutine&quot;</span>)done &lt;- <span class="hljs-literal">true</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>, <span class="hljs-number">0</span>)<span class="hljs-keyword">go</span> hello(done)time.Sleep(<span class="hljs-number">10</span> * time.Second)fmt.Println(<span class="hljs-string">&quot;main function&quot;</span>)&#125;</code></pre></div><blockquote><p>使用 channels 时要考虑的一个重要因素是死锁。如果一个 Goroutine 正在向一个 channel 发送数据，就期望其他一些 Goroutine 应该接收数据。如果这种情况没有发生，程序将在运行时出现 <code>Deadlock</code> panic。</p></blockquote><p>基于作者的观点，我抛出一个疑问：为什么<code>done</code>这个channel只在<code>hello</code>中发送，没有被读取，程序却不会死锁呢？原因在于，<code>done &lt;- true</code>，done只发送数据，却没有接收，因此<code>hello</code>函数进入阻塞，而这个时候，main这个Goroutine还在正常进行，而当<code>main function</code>被打印后，main Goroutine结束，<code>hello</code>也就跟着一起结束了。这时阻塞是1&#x2F;2。</p><p>而将程序作如下修改：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(done <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;Hello world goroutine&quot;</span>)done &lt;- <span class="hljs-literal">true</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>, <span class="hljs-number">0</span>)<span class="hljs-keyword">go</span> hello(done)time.Sleep(<span class="hljs-number">10</span> * time.Second)fmt.Println(<span class="hljs-string">&quot;main function&quot;</span>)<span class="hljs-keyword">select</span> &#123;&#125;&#125;</code></pre></div><p>17行，我们添加了一个<code>select&#123;&#125;</code>，这会使得main Goroutine进入无尽的阻塞，这个时候的阻塞率是2&#x2F;2。因此会触发死锁。</p><p>观点结束，继续原文</p><hr><h3 id="单向-channels"><a href="#单向-channels" class="headerlink" title="单向 channels"></a>单向 channels</h3><p>到目前为止，我们讨论的所有 channels 都是双向的，也就是说数据可以在它们上面发送和接收。也可以创建单向 channels，即只能发送或接收数据的 channels。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sendData</span><span class="hljs-params">(sendch <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>)</span></span> &#123;    sendch &lt;- <span class="hljs-number">10</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    sendch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>)    <span class="hljs-keyword">go</span> sendData(sendch)    fmt.Println(&lt;-sendch)&#125;</code></pre></div><p><a href="https://play.golang.org/p/PRKHxM-iRK">在 playground 中运行程序</a></p><p>在上面的程序中，我们在第 10 行创建了一个只发送的 channel <code>sendch</code>。<code>chan&lt;- int</code> 表示一个只发送的 channel，因为箭头指向 <code>chan</code>。我们试图在第 12 行从一个只发送的 channel 接收数据。这是不允许的，当程序运行时，编译器会抱怨说：</p><p><em>.&#x2F;prog.go:12:14: invalid operation: &lt;-sendch (receive from send-only type chan&lt;- int)</em></p><p><strong>一切都很好，但是如果不能从只发送的 channel 读取，那写入它有什么意义呢！</strong></p><p><strong>这就是 channel 转换发挥作用的地方。可以将双向 channel 转换为只发送或只接收 channel，但反过来是不可能的。</strong></p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sendData</span><span class="hljs-params">(sendch <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>)</span></span> &#123;    sendch &lt;- <span class="hljs-number">10</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    chnl := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)    <span class="hljs-keyword">go</span> sendData(chnl)    fmt.Println(&lt;-chnl)&#125;</code></pre></div><p><a href="https://play.golang.org/p/aqi_rJ1U8j">在 playground 中运行程序</a></p><p>在上面程序的第 10 行，创建了一个双向 channel <code>chnl</code>。在第 11 行将其作为参数传递给 <code>sendData</code> Goroutine。<code>sendData</code> 函数在第 5 行的参数 <code>sendch chan&lt;- int</code> 中将此 channel 转换为只发送的 channel。所以现在该 channel 在 <code>sendData</code> Goroutine 中是只发送的，但在 main Goroutine 中是双向的。这个程序将输出 <code>10</code>。</p><h3 id="关闭-channels-和在-channels-上使用-for-range-循环"><a href="#关闭-channels-和在-channels-上使用-for-range-循环" class="headerlink" title="关闭 channels 和在 channels 上使用 for range 循环"></a>关闭 channels 和在 channels 上使用 for range 循环</h3><p>发送者可以关闭 channel 以通知接收者不会再向该 channel 发送任何数据。</p><p>接收者可以在从 channel 接收数据时使用额外的变量来检查 channel 是否已关闭。</p><div class="code-wrapper"><pre><code class="hljs fallback">v, ok := &lt;- ch</code></pre></div><p>在上面的语句中，如果值是通过向 channel 成功发送操作而接收的，则 <code>ok</code> 为 true。如果 <code>ok</code> 为 false，则意味着我们正在从一个已关闭的 channel 读取。从已关闭的 channel 读取的值将是该 channel 类型的零值。例如，如果 channel 是一个 <code>int</code> channel，那么从已关闭的 channel 接收到的值将是 <code>0</code>。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">producer</span><span class="hljs-params">(chnl <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;        chnl &lt;- i    &#125;    <span class="hljs-built_in">close</span>(chnl)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)    <span class="hljs-keyword">go</span> producer(ch)    <span class="hljs-keyword">for</span> &#123;        v, ok := &lt;-ch        <span class="hljs-keyword">if</span> ok == <span class="hljs-literal">false</span> &#123;            <span class="hljs-keyword">break</span>        &#125;        fmt.Println(<span class="hljs-string">&quot;Received &quot;</span>, v, ok)    &#125;&#125;</code></pre></div><p><a href="https://play.golang.org/p/XWmUKDA2Ri">在 playground 中运行程序</a></p><p>在上面的程序中，<code>producer</code> Goroutine 向 <code>chnl</code> channel 写入 0 到 9，然后关闭该 channel。main 函数在第 16 行有一个无限 <code>for</code> 循环，该循环使用变量 <code>ok</code> 在第 18 行检查 channel 是否已关闭。如果 <code>ok</code> 为 false，则表示 channel 已关闭，因此循环被打破。否则，打印接收到的值和 <code>ok</code> 的值。此程序打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">Received  0 trueReceived  1 trueReceived  2 trueReceived  3 trueReceived  4 trueReceived  5 trueReceived  6 trueReceived  7 trueReceived  8 trueReceived  9 true</code></pre></div><p>for 循环的 <strong>for range</strong> 形式可以用于从 channel 接收值，直到它关闭为止。</p><p>让我们使用 for range 循环重写上面的程序。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">producer</span><span class="hljs-params">(chnl <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;        chnl &lt;- i    &#125;    <span class="hljs-built_in">close</span>(chnl)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)    <span class="hljs-keyword">go</span> producer(ch)    <span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> ch &#123;        fmt.Println(<span class="hljs-string">&quot;Received &quot;</span>,v)    &#125;&#125;</code></pre></div><p><a href="https://play.golang.org/p/JJ3Ida1r_6">在 playground 中运行程序</a></p><p>第 16 行的 <code>for range</code> 循环从 <code>ch</code> channel 接收数据，直到它关闭为止。一旦 <code>ch</code> 关闭，循环会自动退出。该程序输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">Received  0Received  1Received  2Received  3Received  4Received  5Received  6Received  7Received  8Received  9</code></pre></div><p><a href="../%E3%80%90GolangBot%E3%80%9122-Channels/#channel-%E7%9A%84%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%A4%BA%E4%BE%8B">另一个 channel 示例</a>部分的程序可以使用 for range 循环重写，以获得更好的代码重用性。</p><p>如果仔细查看程序，你会注意到在 <code>calcSquares</code> 函数和 <code>calcCubes</code> 函数中都重复了寻找数字各个位的代码。我们将把该代码移到它自己的函数中，并并发调用它。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">digits</span><span class="hljs-params">(number <span class="hljs-type">int</span>, dchnl <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;    <span class="hljs-keyword">for</span> number != <span class="hljs-number">0</span> &#123;        digit := number % <span class="hljs-number">10</span>        dchnl &lt;- digit        number /= <span class="hljs-number">10</span>    &#125;    <span class="hljs-built_in">close</span>(dchnl)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calcSquares</span><span class="hljs-params">(number <span class="hljs-type">int</span>, squareop <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;    sum := <span class="hljs-number">0</span>    dch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)    <span class="hljs-keyword">go</span> digits(number, dch)    <span class="hljs-keyword">for</span> digit := <span class="hljs-keyword">range</span> dch &#123;        sum += digit * digit    &#125;    squareop &lt;- sum&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calcCubes</span><span class="hljs-params">(number <span class="hljs-type">int</span>, cubeop <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;    sum := <span class="hljs-number">0</span>    dch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)    <span class="hljs-keyword">go</span> digits(number, dch)    <span class="hljs-keyword">for</span> digit := <span class="hljs-keyword">range</span> dch &#123;        sum += digit * digit * digit    &#125;    cubeop &lt;- sum&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    number := <span class="hljs-number">589</span>    sqrch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)    cubech := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)    <span class="hljs-keyword">go</span> calcSquares(number, sqrch)    <span class="hljs-keyword">go</span> calcCubes(number, cubech)    squares, cubes := &lt;-sqrch, &lt;-cubech    fmt.Println(<span class="hljs-string">&quot;Final output&quot;</span>, squares+cubes)&#125;</code></pre></div><p><a href="https://play.golang.org/p/oL86W9Ui03">在 playground 中运行程序</a></p><p>上面程序中的 <code>digits</code> 函数现在包含了从数字中获取各个位的逻辑，并被 <code>calcSquares</code> 和 <code>calcCubes</code> 函数并发调用。一旦数字中没有更多的位，channel 在第 13 行被关闭。<code>calcSquares</code> 和 <code>calcCubes</code> Goroutines 使用 <code>for range</code> 循环监听它们各自的 channels，直到它关闭。程序的其余部分相同。这个程序也将打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">Final output 1536</code></pre></div><p>这就是本教程的结尾了。channels 中还有一些概念，如<a href="../%E3%80%90GolangBot%E3%80%9123-%E7%BC%93%E5%86%B2%E9%80%9A%E9%81%93%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%B1%A0">缓冲 channels</a>、<a href="../%E3%80%90GolangBot%E3%80%9123-%E7%BC%93%E5%86%B2%E9%80%9A%E9%81%93%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%B1%A0">工作池</a>和<a href="../%E3%80%90GolangBot%E3%80%9124-Select">select</a>。我们将在单独的教程中讨论它们。感谢阅读。</p><p><strong>下一篇教程 - <a href="../%E3%80%90GolangBot%E3%80%9123-%E7%BC%93%E5%86%B2%E9%80%9A%E9%81%93%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%B1%A0">缓冲 Channels 和工作池</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GolangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】21-Goroutines</title>
    <link href="/%E3%80%90GolangBot%E3%80%9121-Goroutines/"/>
    <url>/%E3%80%90GolangBot%E3%80%9121-Goroutines/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到<a href="../golangbot/">Golang教程系列</a>的第21篇教程。</p><p>在<a href="../%E3%80%90GolangBot%E3%80%9120-%E5%B9%B6%E5%8F%91%E4%BB%8B%E7%BB%8D">上一篇教程</a>中，我们讨论了并发以及它与并行的区别。在本教程中，我们将讨论Go如何使用Goroutines实现并发。</p><h3 id="什么是Goroutines？"><a href="#什么是Goroutines？" class="headerlink" title="什么是Goroutines？"></a>什么是Goroutines？</h3><p>Goroutines是与其他<a href="../%E3%80%90GolangBot%E3%80%916-%E5%87%BD%E6%95%B0">函数</a>或<a href="../%E3%80%90GolangBot%E3%80%9117-%E6%96%B9%E6%B3%95">方法</a>并发运行的函数或方法。Goroutines可以被认为是轻量级线程。与线程相比，创建Goroutine的成本很小。因此，Go应用程序通常会有数千个Goroutines并发运行。</p><h3 id="Goroutines相对于线程的优势"><a href="#Goroutines相对于线程的优势" class="headerlink" title="Goroutines相对于线程的优势"></a>Goroutines相对于线程的优势</h3><ul><li>与线程相比，Goroutines非常轻量。它们的栈大小只有几kb，而且栈可以根据应用程序的需要增长和收缩，而线程的栈大小必须指定且是固定的。</li><li>Goroutines被多路复用到更少数量的OS线程上。一个程序中可能只有一个线程却有数千个Goroutines。如果该线程中的任何Goroutine阻塞（比如等待用户输入），则会创建另一个OS线程，并将剩余的Goroutines移动到新的OS线程。这些都由运行时处理，我们作为程序员不需要关心这些复杂的细节，而是得到了一个处理并发的清晰API。</li><li>Goroutines通过channels进行通信。channels的设计可以防止在使用Goroutines访问共享内存时发生竞态条件。channels可以被认为是Goroutines用来通信的管道。我们将在下一个教程中详细讨论channels。</li></ul><h3 id="如何启动Goroutine？"><a href="#如何启动Goroutine？" class="headerlink" title="如何启动Goroutine？"></a>如何启动Goroutine？</h3><p>在函数或方法调用前加上关键字<code>go</code>，你就会有一个新的并发运行的Goroutine。</p><p>让我们创建一个Goroutine :)</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> &#123;    fmt.Println(<span class="hljs-string">&quot;Hello world goroutine&quot;</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">go</span> hello()    fmt.Println(<span class="hljs-string">&quot;main function&quot;</span>)&#125;</code></pre></div><p><a href="https://play.golang.org/p/zC78_fc1Hn">在playground中运行程序</a></p><p>在第11行，<code>go hello()</code>启动了一个新的Goroutine。现在<code>hello()</code>函数将与<code>main()</code>函数并发运行。main函数在它自己的Goroutine中运行，它被称为<em>主Goroutine</em>。</p><p><em>运行这个程序，你会有一个惊喜！</em></p><p>这个程序只输出文本<code>main function</code>。我们启动的Goroutine怎么了？我们需要理解goroutines的两个主要特性来理解为什么会这样。</p><ul><li><strong>当启动一个新的Goroutine时，goroutine调用会立即返回。与函数不同，控制不会等待Goroutine执行完成。控制会立即返回到Goroutine调用后的下一行代码，而且会忽略Goroutine的任何返回值。</strong></li><li><strong>主Goroutine必须运行才能让其他Goroutines运行。如果主Goroutine终止，则程序将被终止，其他Goroutine也不会运行。</strong></li></ul><p>我想现在你应该能理解为什么我们的Goroutine没有运行了。在第11行调用<code>go hello()</code>之后，控制立即返回到下一行代码，没有等待hello goroutine完成就打印了<code>main function</code>。然后主Goroutine终止了，因为没有其他要执行的代码，因此<code>hello</code> Goroutine没有机会运行。</p><p>让我们现在来修复这个问题。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (      <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> &#123;      fmt.Println(<span class="hljs-string">&quot;Hello world goroutine&quot;</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;      <span class="hljs-keyword">go</span> hello()    time.Sleep(<span class="hljs-number">1</span> * time.Second)    fmt.Println(<span class="hljs-string">&quot;main function&quot;</span>)&#125;</code></pre></div><p><a href="https://play.golang.org/p/U9ZZuSql8-">在playground中运行程序</a></p><p>在上面程序的第13行，我们调用了<em>time</em>包的<a href="https://golang.org/pkg/time/#Sleep">Sleep</a>方法，它会使执行该方法的goroutine休眠。在这个例子中，主goroutine被置于休眠状态1秒。现在调用<code>go hello()</code>有足够的时间在主Goroutine终止之前执行。这个程序首先打印<code>Hello world goroutine</code>，等待1秒，然后打印<code>main function</code>。</p><p><em>在主Goroutine中使用sleep来等待其他Goroutines完成执行是一种hack方法，我们用它来理解Goroutines是如何工作的。channels可以用来阻塞主Goroutine直到所有其他Goroutines完成执行。我们将在下一个教程中讨论channels。</em></p><h3 id="启动多个Goroutines"><a href="#启动多个Goroutines" class="headerlink" title="启动多个Goroutines"></a>启动多个Goroutines</h3><p>让我们再写一个启动多个Goroutines的程序来更好地理解Goroutines。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (      <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numbers</span><span class="hljs-params">()</span></span> &#123;      <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++ &#123;        time.Sleep(<span class="hljs-number">250</span> * time.Millisecond)        fmt.Printf(<span class="hljs-string">&quot;%d &quot;</span>, i)    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">alphabets</span><span class="hljs-params">()</span></span> &#123;      <span class="hljs-keyword">for</span> i := <span class="hljs-string">&#x27;a&#x27;</span>; i &lt;= <span class="hljs-string">&#x27;e&#x27;</span>; i++ &#123;        time.Sleep(<span class="hljs-number">400</span> * time.Millisecond)        fmt.Printf(<span class="hljs-string">&quot;%c &quot;</span>, i)    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;      <span class="hljs-keyword">go</span> numbers()    <span class="hljs-keyword">go</span> alphabets()    time.Sleep(<span class="hljs-number">3000</span> * time.Millisecond)    fmt.Println(<span class="hljs-string">&quot;main terminated&quot;</span>)&#125;</code></pre></div><p><a href="https://play.golang.org/p/oltn5nw0w3">在playground中运行</a></p><p>上面的程序在第21行和第22行启动了两个Goroutines。这两个Goroutines现在并发运行。<code>numbers</code> Goroutine最初休眠250毫秒然后打印<code>1</code>，然后再次休眠并打印<code>2</code>，这个循环一直持续到打印5。同样，<code>alphabets</code> Goroutine打印从<code>a</code>到<code>e</code>的字母，休眠时间为400毫秒。主Goroutine启动<code>numbers</code>和<code>alphabets</code> Goroutines，休眠3000毫秒然后终止。</p><p>这个程序输出</p><div class="code-wrapper"><pre><code class="hljs fallback">1 a 2 3 b 4 c 5 d e main terminated</code></pre></div><p>下面的图片描述了这个程序是如何工作的。请在新标签页中打开图片以获得更好的可视性 :)</p><p><img src="https://golangbot.com/content/images/2017/07/Goroutines-explained.png" alt="img"></p><p>图片中蓝色部分代表<em>numbers Goroutine</em>，栗色部分代表<em>alphabets Goroutine</em>，绿色部分代表<em>main Goroutine</em>，最后的黑色部分合并了上面三个部分，展示了程序如何工作。每个框顶部的字符串如<em>0 ms, 250 ms</em>代表毫秒时间，输出显示在每个框的底部，如<em>1, 2, 3</em>等。蓝色框告诉我们<code>1</code>在<code>250 ms</code>后打印，<code>2</code>在<code>500 ms</code>后打印，以此类推。最后黑色框的底部有值<code>1 a 2 3 b 4 c 5 d e main terminated</code>，这也是程序的输出。这张图片很好理解，你能够理解程序是如何工作的。</p><p><strong>下一篇教程 - <a href="../%E3%80%90GolangBot%E3%80%9122-Channels">Channels</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GolangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】20-并发介绍</title>
    <link href="/%E3%80%90GolangBot%E3%80%9120-%E5%B9%B6%E5%8F%91%E4%BB%8B%E7%BB%8D/"/>
    <url>/%E3%80%90GolangBot%E3%80%9120-%E5%B9%B6%E5%8F%91%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到<a href="../golangbot/">Golang系列教程</a>第20讲。</p><p><strong>Go是一门并发语言而不是并行语言</strong>。在讨论Go如何处理并发之前，我们必须首先理解什么是并发，以及它与并行有什么不同。</p><h3 id="什么是并发？"><a href="#什么是并发？" class="headerlink" title="什么是并发？"></a>什么是并发？</h3><p>并发是同时处理多件事情的能力。用一个例子来解释最好。</p><p>让我们考虑一个人在跑步。在他晨跑时，假设他的鞋带松开了。这时这个人停止跑步，系好鞋带，然后继续跑步。这是并发的一个经典例子。这个人能够同时处理跑步和系鞋带这两件事，也就是说这个人能够同时处理多件事情 :)</p><h3 id="什么是并行？它与并发有什么不同？"><a href="#什么是并行？它与并发有什么不同？" class="headerlink" title="什么是并行？它与并发有什么不同？"></a>什么是并行？它与并发有什么不同？</h3><p>并行是同时做多件事情。这听起来可能与并发类似，但实际上是不同的。</p><p>让我们用同样的跑步例子来更好地理解这一点。在这种情况下，让我们假设这个人在跑步的同时也在用iPod听音乐。在这种情况下，这个人同时在跑步和听音乐，也就是说他同时在做多件事情。这就叫做并行。</p><h3 id="并发和并行-技术角度的观点"><a href="#并发和并行-技术角度的观点" class="headerlink" title="并发和并行 - 技术角度的观点"></a>并发和并行 - 技术角度的观点</h3><p>我们通过现实世界的例子理解了什么是并发以及它与并行的区别。现在让我们从更技术的角度来看它们，因为我们是极客 :)。</p><p>假设我们正在编程一个网页浏览器。这个网页浏览器有多个组件。其中两个是网页渲染区域和用于从互联网下载文件的下载器。让我们假设我们已经把浏览器的代码结构化，使得每个组件都可以独立执行（在Java等语言中这是通过线程实现的，而在Go中我们可以使用<a href="../%E3%80%90GolangBot%E3%80%9121-Goroutines">Goroutines</a>来实现，稍后会详细介绍）。当这个浏览器在单核处理器上运行时，处理器会在浏览器的两个组件之间进行上下文切换。它可能会下载文件一段时间，然后切换到渲染用户请求的网页的html。这就是所谓的并发。并发进程在不同的时间点开始，它们的执行周期重叠。在这种情况下，下载和渲染在不同的时间点开始，它们的执行是重叠的。</p><p>假设同样的浏览器在多核处理器上运行。在这种情况下，文件下载组件和HTML渲染组件可能在不同的核心上同时运行。这就是所谓的并行。</p><p><img src="https://golangbot.com/content/images/2017/06/concurrency-parallelism-copy.png" alt="concurrency-parallelism-go"></p><p>并行并不总是会导致更快的执行时间。这是因为并行运行的组件可能需要相互通信。例如，在我们的浏览器中，当文件下载完成时，需要通过弹窗等方式将此信息传达给用户。这种通信发生在负责下载的组件和负责渲染用户界面的组件之间。在并发系统中，这种通信开销很低。而在组件在多个核心上并行运行的情况下，这种通信开销很高。因此并行程序并不总是能带来更快的执行时间！</p><h3 id="Go对并发的支持"><a href="#Go对并发的支持" class="headerlink" title="Go对并发的支持"></a>Go对并发的支持</h3><p>并发是Go编程语言的固有部分。Go中的并发是通过<a href="../%E3%80%90GolangBot%E3%80%9121-Goroutines">Goroutines</a>和channels来处理的。我们将在接下来的教程中详细讨论它们。</p><p>关于并发的介绍就到这里。</p><p><strong>下一篇教程 - <a href="https://golangbot.com/goroutines/">Goroutines</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GolangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】19-接口 II</title>
    <link href="/%E3%80%90GolangBot%E3%80%9119-%E6%8E%A5%E5%8F%A3-II/"/>
    <url>/%E3%80%90GolangBot%E3%80%9119-%E6%8E%A5%E5%8F%A3-II/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到<a href="../golangbot/">Golang教程系列</a>的第19篇教程。这是接口教程的第二部分。如果你错过了第一部分，可以从<a href="../%E3%80%90GolangBot%E3%80%9118-%E6%8E%A5%E5%8F%A3-I/">这里</a>阅读</p><h3 id="使用指针接收器vs值接收器来实现接口"><a href="#使用指针接收器vs值接收器来实现接口" class="headerlink" title="使用指针接收器vs值接收器来实现接口"></a>使用指针接收器vs值接收器来实现接口</h3><p>我们在<a href="../%E3%80%90GolangBot%E3%80%9118-%E6%8E%A5%E5%8F%A3-I">第一部分</a>中讨论的所有示例接口都是使用值接收器实现的。使用指针接收器也可以实现接口。在使用指针接收器实现接口时需要注意一个细节。让我们通过以下程序来理解这一点。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">type</span> Describer <span class="hljs-keyword">interface</span> &#123;Describe()&#125;<span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;name <span class="hljs-type">string</span>age  <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> Describe() &#123; <span class="hljs-comment">//implemented using value receiver</span>fmt.Printf(<span class="hljs-string">&quot;%s is %d years old\n&quot;</span>, p.name, p.age)&#125;<span class="hljs-keyword">type</span> Address <span class="hljs-keyword">struct</span> &#123;state   <span class="hljs-type">string</span>country <span class="hljs-type">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *Address)</span></span> Describe() &#123; <span class="hljs-comment">//implemented using pointer receiver</span>fmt.Printf(<span class="hljs-string">&quot;State %s Country %s&quot;</span>, a.state, a.country)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> d1 Describerp1 := Person&#123;<span class="hljs-string">&quot;Sam&quot;</span>, <span class="hljs-number">25</span>&#125;d1 = p1d1.Describe()p2 := Person&#123;<span class="hljs-string">&quot;James&quot;</span>, <span class="hljs-number">32</span>&#125;d1 = &amp;p2d1.Describe()<span class="hljs-keyword">var</span> d2 Describera := Address&#123;<span class="hljs-string">&quot;Washington&quot;</span>, <span class="hljs-string">&quot;USA&quot;</span>&#125;<span class="hljs-comment">/* compilation error if the following line is</span><span class="hljs-comment">   uncommented</span><span class="hljs-comment">   cannot use a (type Address) as type Describer</span><span class="hljs-comment">   in assignment: Address does not implement</span><span class="hljs-comment">   Describer (Describe method has pointer</span><span class="hljs-comment">   receiver)</span><span class="hljs-comment">*/</span><span class="hljs-comment">//d2 = a</span>d2 = &amp;a <span class="hljs-comment">//This works since Describer interface</span><span class="hljs-comment">//is implemented by Address pointer in line 22</span>d2.Describe()&#125;</code></pre></div><p><a href="https://play.golang.org/p/IzspYiAQ82">在playground中运行</a></p><p>在上面的程序中，<code>Person</code>结构体在第13行使用值接收器实现了<code>Describer</code>接口。</p><p>正如我们在<a href="../%E3%80%90GolangBot%E3%80%9117-%E6%96%B9%E6%B3%95/#%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%E5%80%BC%E6%8E%A5%E6%94%B6%E8%80%85vs%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E5%80%BC%E5%8F%82%E6%95%B0">方法</a>的讨论中已经了解到的，具有值接收器的方法既接受指针接收器也接受值接收器。<em>对于任何值或可以解引用的值，调用值方法都是合法的。</em></p><p><em>p1</em>是<code>Person</code>类型的值，它在第29行被赋值给<code>d1</code>。<code>Person</code>实现了<code>Describer</code>接口，因此第30行将打印<code>Sam is 25 years old</code>。</p><p>同样，在第32行<code>d1</code>被赋值为<code>&amp;p2</code>，因此第33行将打印<code>James is 32 years old</code>。很棒:)。</p><p><code>Address</code>结构体在第22行使用指针接收器实现了<code>Describer</code>接口。</p><p>如果取消注释上面程序的第45行，我们将得到编译错误<strong>main.go:42: cannot use a (type Address) as type Describer in assignment: Address does not implement Describer (Describe method has pointer receiver)</strong>。这是因为，<code>Describer</code>接口在第22行使用Address指针接收器实现，而我们试图赋值<code>a</code>是一个值类型，它没有实现<code>Describer</code>接口。这肯定会让你感到惊讶，因为我们之前学到<a href="../%E3%80%90GolangBot%E3%80%9117-%E6%96%B9%E6%B3%95/#%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E8%80%85vs%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88%E5%8F%82%E6%95%B0">方法</a>中带有指针接收器的方法将同时接受指针和值接收器。那为什么第45行的代码不能工作呢？</p><p><strong>原因是只有在已经是指针或者可以获取地址的情况下，才可以合法地调用指针值方法。存储在接口中的具体值是不可寻址的，因此编译器无法自动获取第45行中<code>a</code>的地址，所以这段代码失败了。</strong></p><p>第47行可以工作，因为我们将<code>a</code>的地址<code>&amp;a</code>赋值给<code>d2</code>。</p><p>程序的其余部分是不言自明的。这个程序将打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">Sam is 25 years oldJames is 32 years oldState Washington Country USA</code></pre></div><h3 id="实现多个接口"><a href="#实现多个接口" class="headerlink" title="实现多个接口"></a>实现多个接口</h3><p>一个类型可以实现多个接口。让我们看看下面的程序是如何实现的。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> SalaryCalculator <span class="hljs-keyword">interface</span> &#123;DisplaySalary()&#125;<span class="hljs-keyword">type</span> LeaveCalculator <span class="hljs-keyword">interface</span> &#123;CalculateLeavesLeft() <span class="hljs-type">int</span>&#125;<span class="hljs-keyword">type</span> Employee <span class="hljs-keyword">struct</span> &#123;firstName <span class="hljs-type">string</span>lastName <span class="hljs-type">string</span>basicPay <span class="hljs-type">int</span>pf <span class="hljs-type">int</span>totalLeaves <span class="hljs-type">int</span>leavesTaken <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e Employee)</span></span> DisplaySalary() &#123;fmt.Printf(<span class="hljs-string">&quot;%s %s has salary $%d&quot;</span>, e.firstName, e.lastName, (e.basicPay + e.pf))&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e Employee)</span></span> CalculateLeavesLeft() <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> e.totalLeaves - e.leavesTaken&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;e := Employee &#123;firstName: <span class="hljs-string">&quot;Naveen&quot;</span>,lastName: <span class="hljs-string">&quot;Ramanathan&quot;</span>,basicPay: <span class="hljs-number">5000</span>,pf: <span class="hljs-number">200</span>,totalLeaves: <span class="hljs-number">30</span>,leavesTaken: <span class="hljs-number">5</span>,&#125;<span class="hljs-keyword">var</span> s SalaryCalculator = es.DisplaySalary()<span class="hljs-keyword">var</span> l LeaveCalculator = efmt.Println(<span class="hljs-string">&quot;\nLeaves left =&quot;</span>, l.CalculateLeavesLeft())&#125;</code></pre></div><p><a href="https://play.golang.org/p/DJxS5zxBcV">在playground中运行</a></p><p>上面的程序在第7行和第11行分别声明了两个接口<code>SalaryCalculator</code>和<code>LeaveCalculator</code>。</p><p><code>Employee</code>结构体在第15行定义，它在第24行提供了<code>SalaryCalculator</code>接口的<code>DisplaySalary</code>方法实现，在第28行提供了<code>LeaveCalculator</code>接口的<code>CalculateLeavesLeft</code>方法实现。现在<code>Employee</code>同时实现了<code>SalaryCalculator</code>和<code>LeaveCalculator</code>接口。</p><p>在第41行，我们将<code>e</code>赋值给<code>SalaryCalculator</code>接口类型的变量，在第43行，我们将相同的变量<code>e</code>赋值给<code>LeaveCalculator</code>类型的变量。这是可能的，因为类型为<code>Employee</code>的<code>e</code>同时实现了<code>SalaryCalculator</code>和<code>LeaveCalculator</code>接口。</p><p>这个程序输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">Naveen Ramanathan has salary $5200Leaves left = 25</code></pre></div><h3 id="嵌入接口"><a href="#嵌入接口" class="headerlink" title="嵌入接口"></a>嵌入接口</h3><p>虽然go不提供继承，但可以通过嵌入其他接口来创建新的接口。</p><p>让我们看看如何实现这一点。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (      <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> SalaryCalculator <span class="hljs-keyword">interface</span> &#123;      DisplaySalary()&#125;<span class="hljs-keyword">type</span> LeaveCalculator <span class="hljs-keyword">interface</span> &#123;      CalculateLeavesLeft() <span class="hljs-type">int</span>&#125;<span class="hljs-keyword">type</span> EmployeeOperations <span class="hljs-keyword">interface</span> &#123;SalaryCalculatorLeaveCalculator&#125;<span class="hljs-keyword">type</span> Employee <span class="hljs-keyword">struct</span> &#123;      firstName <span class="hljs-type">string</span>    lastName <span class="hljs-type">string</span>    basicPay <span class="hljs-type">int</span>    pf <span class="hljs-type">int</span>    totalLeaves <span class="hljs-type">int</span>    leavesTaken <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e Employee)</span></span> DisplaySalary() &#123;      fmt.Printf(<span class="hljs-string">&quot;%s %s has salary $%d&quot;</span>, e.firstName, e.lastName, (e.basicPay + e.pf))&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e Employee)</span></span> CalculateLeavesLeft() <span class="hljs-type">int</span> &#123;      <span class="hljs-keyword">return</span> e.totalLeaves - e.leavesTaken&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;      e := Employee &#123;        firstName: <span class="hljs-string">&quot;Naveen&quot;</span>,        lastName: <span class="hljs-string">&quot;Ramanathan&quot;</span>,        basicPay: <span class="hljs-number">5000</span>,        pf: <span class="hljs-number">200</span>,        totalLeaves: <span class="hljs-number">30</span>,        leavesTaken: <span class="hljs-number">5</span>,    &#125;    <span class="hljs-keyword">var</span> empOp EmployeeOperations = e    empOp.DisplaySalary()    fmt.Println(<span class="hljs-string">&quot;\nLeaves left =&quot;</span>, empOp.CalculateLeavesLeft())&#125;</code></pre></div><p><a href="https://play.golang.org/p/Hia7D-WbZp">在playground中运行</a></p><p>上面程序第15行的<em>EmployeeOperations</em>接口是通过嵌入<em>SalaryCalculator</em>和<em>LeaveCalculator</em>接口创建的。</p><p>如果一个类型为<em>SalaryCalculator</em>和<em>LeaveCalculator</em>接口中的方法提供了方法定义，那么就说这个类型实现了<code>EmployeeOperations</code>接口。</p><p><code>Employee</code>结构体实现了<code>EmployeeOperations</code>接口，因为它分别在第29行和第33行为<code>DisplaySalary</code>和<code>CalculateLeavesLeft</code>方法提供了定义。</p><p>在第46行，<code>Employee</code>类型的<code>e</code>被赋值给<code>EmployeeOperations</code>类型的<code>empOp</code>。在接下来的两行中，在<code>empOp</code>上调用了<code>DisplaySalary()</code>和<code>CalculateLeavesLeft()</code>方法。</p><p>这个程序将输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">Naveen Ramanathan has salary $5200Leaves left = 25</code></pre></div><h3 id="接口的零值"><a href="#接口的零值" class="headerlink" title="接口的零值"></a>接口的零值</h3><p>接口的零值是nil。一个nil接口的底层值和具体类型都是nil。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">type</span> Describer <span class="hljs-keyword">interface</span> &#123;Describe()&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> d1 Describer<span class="hljs-keyword">if</span> d1 == <span class="hljs-literal">nil</span> &#123;fmt.Printf(<span class="hljs-string">&quot;d1 is nil and has type %T value %v\n&quot;</span>, d1, d1)&#125;&#125;</code></pre></div><p><a href="https://play.golang.org/p/vwYHC6Y78H">在playground中运行</a></p><p>上面程序中的<em>d1</em>是<code>nil</code>，这个程序将输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">d1 is nil and has type &lt;nil&gt; value &lt;nil&gt;</code></pre></div><p>如果我们试图在<code>nil</code>接口上调用方法，程序将会panic，因为<code>nil</code>接口既没有底层值也没有具体类型。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">type</span> Describer <span class="hljs-keyword">interface</span> &#123;Describe()&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> d1 Describerd1.Describe()&#125;</code></pre></div><p><a href="https://play.golang.org/p/rM-rY0uGTI">在playground中运行</a></p><p>由于上面程序中的<code>d1</code>是<code>nil</code>，这个程序将会panic，运行时错误为<strong>panic: runtime error: invalid memory address or nil pointer dereference [signal SIGSEGV: segmentation violation code&#x3D;0xffffffff addr&#x3D;0x0 pc&#x3D;0xc8527]”</strong></p><p><strong>下一篇教程 - <a href="../%E3%80%90GolangBot%E3%80%9120-%E5%B9%B6%E5%8F%91%E4%BB%8B%E7%BB%8D/">并发简介</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GolangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】18-接口 I</title>
    <link href="/%E3%80%90GolangBot%E3%80%9118-%E6%8E%A5%E5%8F%A3-I/"/>
    <url>/%E3%80%90GolangBot%E3%80%9118-%E6%8E%A5%E5%8F%A3-I/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到 <a href="../golangbot/">Go 语言教程系列</a> 的第 18 讲。这是接口教程两个部分中的第一部分。</p><h3 id="什么是接口？"><a href="#什么是接口？" class="headerlink" title="什么是接口？"></a>什么是接口？</h3><p><strong>在 Go 中，接口是一组方法签名的集合。当一个类型为接口中的所有方法提供定义时，就称该类型实现了这个接口。</strong> 这与面向对象编程世界很相似。接口指定了一个类型应该有哪些<a href="https://golangbot.com/methods/">方法</a>，而类型决定如何实现这些方法。</p><p>例如 <em>WashingMachine</em> 可以是一个带有<a href="../%E3%80%90GolangBot%E3%80%9117-%E6%96%B9%E6%B3%95/">方法</a>签名 <em>Cleaning()</em> 和 <em>Drying()</em> 的接口。任何提供了 <em>Cleaning()</em> 和 <em>Drying()</em> 方法定义的类型都被认为实现了 <em>WashingMachine</em> 接口。</p><h3 id="声明和实现接口"><a href="#声明和实现接口" class="headerlink" title="声明和实现接口"></a>声明和实现接口</h3><p>让我们直接通过一个创建和实现接口的程序来学习。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-comment">//interface definition</span><span class="hljs-keyword">type</span> VowelsFinder <span class="hljs-keyword">interface</span> &#123;    FindVowels() []<span class="hljs-type">rune</span>&#125;<span class="hljs-keyword">type</span> MyString <span class="hljs-type">string</span><span class="hljs-comment">//MyString implements VowelsFinder</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ms MyString)</span></span> FindVowels() []<span class="hljs-type">rune</span> &#123;    <span class="hljs-keyword">var</span> vowels []<span class="hljs-type">rune</span>    <span class="hljs-keyword">for</span> _, <span class="hljs-type">rune</span> := <span class="hljs-keyword">range</span> ms &#123;        <span class="hljs-keyword">if</span> <span class="hljs-type">rune</span> == <span class="hljs-string">&#x27;a&#x27;</span> || <span class="hljs-type">rune</span> == <span class="hljs-string">&#x27;e&#x27;</span> || <span class="hljs-type">rune</span> == <span class="hljs-string">&#x27;i&#x27;</span> || <span class="hljs-type">rune</span> == <span class="hljs-string">&#x27;o&#x27;</span> || <span class="hljs-type">rune</span> == <span class="hljs-string">&#x27;u&#x27;</span> &#123;            vowels = <span class="hljs-built_in">append</span>(vowels, <span class="hljs-type">rune</span>)        &#125;    &#125;    <span class="hljs-keyword">return</span> vowels&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    name := MyString(<span class="hljs-string">&quot;Sam Anderson&quot;</span>)    <span class="hljs-keyword">var</span> v VowelsFinder    v = name <span class="hljs-comment">// possible since MyString implements VowelsFinder</span>    fmt.Printf(<span class="hljs-string">&quot;Vowels are %c&quot;</span>, v.FindVowels())&#125;</code></pre></div><p><a href="https://play.golang.org/p/F-T3S_wNNB">在 playground 中运行</a></p><p>上述程序第 8 行创建了一个名为 <code>VowelsFinder</code> 的接口类型，该接口有一个方法 <code>FindVowels() []rune</code>。</p><p>接下来一行创建了一个 <code>MyString</code> 类型。</p><p><strong>在第 15 行，我们为接收者类型 <code>MyString</code> 添加了方法 <code>FindVowels() []rune</code>。现在可以说 <code>MyString</code> 实现了接口 <code>VowelsFinder</code>。</strong> 这与其他语言（如 Java）有很大不同，在 Java 中，一个类必须使用 <code>implements</code> 关键字显式声明它实现了一个接口。<strong>在 Go 中不需要这样做，如果一个类型包含了接口声明的所有方法，那么这个类型就隐式地实现了该接口。</strong></p><p>在第 28 行，我们将 <code>MyString</code> 类型的 <code>name</code> 赋值给 VowelsFinder 类型的 v。这是可能的，因为 <code>MyString</code> 实现了 <code>VowelsFinder</code> 接口。下一行的 <code>v.FindVowels()</code> 调用了 <code>MyString</code> 类型的 FindVowels 方法，并打印出字符串 <code>Sam Anderson</code> 中的所有元音字母。该程序输出：</p><div class="code-wrapper"><pre><code class="hljs inform7">Vowels <span class="hljs-keyword">are</span> <span class="hljs-comment">[a e o]</span></code></pre></div><p>恭喜！你已经创建并实现了你的第一个接口。</p><h3 id="接口的实际应用"><a href="#接口的实际应用" class="headerlink" title="接口的实际应用"></a>接口的实际应用</h3><p>上面的例子教会了我们如何创建和实现接口，但它并没有真正展示接口的实际用途。在上面的程序中，如果我们使用 <code>name.FindVowels()</code> 而不是 <code>v.FindVowels()</code>，程序也能工作，接口就没有什么用了。</p><p>现在让我们看看接口的一个实际应用。</p><p>我们将编写一个简单的程序，根据员工的个人薪资计算公司的总支出。为了简单起见，我们假设所有费用都以美元计算。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> SalaryCalculator <span class="hljs-keyword">interface</span> &#123;    CalculateSalary() <span class="hljs-type">int</span>&#125;<span class="hljs-keyword">type</span> Permanent <span class="hljs-keyword">struct</span> &#123;    empId    <span class="hljs-type">int</span>    basicpay <span class="hljs-type">int</span>    pf       <span class="hljs-type">int</span>&#125;<span class="hljs-keyword">type</span> Contract <span class="hljs-keyword">struct</span> &#123;    empId    <span class="hljs-type">int</span>    basicpay <span class="hljs-type">int</span>&#125;<span class="hljs-comment">//salary of permanent employee is the sum of basic pay and pf</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Permanent)</span></span> CalculateSalary() <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">return</span> p.basicpay + p.pf&#125;<span class="hljs-comment">//salary of contract employee is the basic pay alone</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Contract)</span></span> CalculateSalary() <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">return</span> c.basicpay&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">total expense is calculated by iterating through the SalaryCalculator slice and summing</span><span class="hljs-comment">the salaries of the individual employees</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">totalExpense</span><span class="hljs-params">(s []SalaryCalculator)</span></span> &#123;    expense := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> s &#123;        expense = expense + v.CalculateSalary()    &#125;    fmt.Printf(<span class="hljs-string">&quot;Total Expense Per Month $%d&quot;</span>, expense)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    pemp1 := Permanent&#123;        empId:    <span class="hljs-number">1</span>,        basicpay: <span class="hljs-number">5000</span>,        pf:       <span class="hljs-number">20</span>,    &#125;    pemp2 := Permanent&#123;        empId:    <span class="hljs-number">2</span>,        basicpay: <span class="hljs-number">6000</span>,        pf:       <span class="hljs-number">30</span>,    &#125;    cemp1 := Contract&#123;        empId:    <span class="hljs-number">3</span>,        basicpay: <span class="hljs-number">3000</span>,    &#125;    employees := []SalaryCalculator&#123;pemp1, pemp2, cemp1&#125;    totalExpense(employees)&#125;</code></pre></div><p><a href="https://play.golang.org/p/3DZQH_Xh_Pl">在 playground 中运行</a></p><p>上述程序第 7 行声明了一个带有单个方法 <code>CalculateSalary() int</code> 的 <code>SalaryCalculator</code> 接口。</p><p>公司有两种类型的员工，<code>Permanent</code> 和 <code>Contract</code>，分别由第 11 行和第 17 行的<a href="../%E3%80%90GolangBot%E3%80%9116-%E7%BB%93%E6%9E%84%E4%BD%93/">结构体</a>定义。永久员工的薪资是 <code>basicpay</code> 和 <code>pf</code> 的总和，而合同员工的薪资只有 <code>basicpay</code>。这在第 23 行和第 28 行的相应 <code>CalculateSalary</code> 方法中得到了体现。通过声明这个方法，<code>Permanent</code> 和 <code>Contract</code> 结构体现在都实现了 <code>SalaryCalculator</code> 接口。</p><p>第 36 行声明的 <code>totalExpense</code> <a href="../%E3%80%90GolangBot%E3%80%916-%E5%87%BD%E6%95%B0/">函数</a>展现了接口的优雅之处。这个方法接受一个 SalaryCalculator 接口的<a href="../%E3%80%90GolangBot%E3%80%9111-%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/">切片</a> <code>[]SalaryCalculator</code> 作为参数。在第 59 行，我们向 <code>totalExpense</code> 函数传递了一个包含 <code>Permanent</code> 和 <code>Contract</code> 类型的切片。<code>totalExpense</code> 函数通过调用相应类型的 <code>CalculateSalary</code> 方法来计算支出。这在第 39 行完成。</p><p>程序输出：</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">Total</span> Expense Per Month <span class="hljs-variable">$14050</span></code></pre></div><p>这样做的最大优势是 <code>totalExpense</code> 可以扩展到任何新的员工类型，而无需任何代码更改。假设公司添加了一个具有不同薪资结构的新员工类型 <code>Freelancer</code>。这个 <code>Freelancer</code> 可以直接传入到 <code>totalExpense</code> 的切片参数中，而不需要对 <code>totalExpense</code> 函数进行任何代码更改。这个方法将按预期工作，因为 <code>Freelancer</code> 也将实现 <code>SalaryCalculator</code> 接口 :)。</p><p>让我们修改这个程序并添加新的 <code>Freelancer</code> 员工。自由职业者的薪资是每小时工资和工作总小时数的乘积。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> SalaryCalculator <span class="hljs-keyword">interface</span> &#123;    CalculateSalary() <span class="hljs-type">int</span>&#125;<span class="hljs-keyword">type</span> Permanent <span class="hljs-keyword">struct</span> &#123;    empId    <span class="hljs-type">int</span>    basicpay <span class="hljs-type">int</span>    pf       <span class="hljs-type">int</span>&#125;<span class="hljs-keyword">type</span> Contract <span class="hljs-keyword">struct</span> &#123;    empId    <span class="hljs-type">int</span>    basicpay <span class="hljs-type">int</span>&#125;<span class="hljs-keyword">type</span> Freelancer <span class="hljs-keyword">struct</span> &#123;    empId       <span class="hljs-type">int</span>    ratePerHour <span class="hljs-type">int</span>    totalHours  <span class="hljs-type">int</span>&#125;<span class="hljs-comment">//salary of permanent employee is sum of basic pay and pf</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Permanent)</span></span> CalculateSalary() <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">return</span> p.basicpay + p.pf&#125;<span class="hljs-comment">//salary of contract employee is the basic pay alone</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Contract)</span></span> CalculateSalary() <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">return</span> c.basicpay&#125;<span class="hljs-comment">//salary of freelancer</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f Freelancer)</span></span> CalculateSalary() <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">return</span> f.ratePerHour * f.totalHours&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">total expense is calculated by iterating through the SalaryCalculator slice and summing</span><span class="hljs-comment">the salaries of the individual employees</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">totalExpense</span><span class="hljs-params">(s []SalaryCalculator)</span></span> &#123;    expense := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> s &#123;        expense = expense + v.CalculateSalary()    &#125;    fmt.Printf(<span class="hljs-string">&quot;Total Expense Per Month $%d&quot;</span>, expense)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    pemp1 := Permanent&#123;        empId:    <span class="hljs-number">1</span>,        basicpay: <span class="hljs-number">5000</span>,        pf:       <span class="hljs-number">20</span>,    &#125;    pemp2 := Permanent&#123;        empId:    <span class="hljs-number">2</span>,        basicpay: <span class="hljs-number">6000</span>,        pf:       <span class="hljs-number">30</span>,    &#125;    cemp1 := Contract&#123;        empId:    <span class="hljs-number">3</span>,        basicpay: <span class="hljs-number">3000</span>,    &#125;    freelancer1 := Freelancer&#123;        empId:       <span class="hljs-number">4</span>,        ratePerHour: <span class="hljs-number">70</span>,        totalHours:  <span class="hljs-number">120</span>,    &#125;    freelancer2 := Freelancer&#123;        empId:       <span class="hljs-number">5</span>,        ratePerHour: <span class="hljs-number">100</span>,        totalHours:  <span class="hljs-number">100</span>,    &#125;    employees := []SalaryCalculator&#123;pemp1, pemp2, cemp1, freelancer1, freelancer2&#125;    totalExpense(employees)&#125;</code></pre></div><p><a href="https://play.golang.org/p/J48P5g8ArLn">在 playground 中运行</a></p><p>我们在第 22 行添加了 <code>Freelancer</code> 结构体，并在第 39 行声明了 <code>CalculateSalary</code> 方法。由于 <code>Freelancer</code> 结构体也实现了 <code>SalaryCalculator</code> 接口，因此不需要在 <code>totalExpense</code> 方法中进行任何代码更改。我们在 <code>main</code> 方法中添加了几个 <code>Freelancer</code> 员工。这个程序打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">Total Expense Per Month $32450</code></pre></div><h3 id="接口的内部表示"><a href="#接口的内部表示" class="headerlink" title="接口的内部表示"></a>接口的内部表示</h3><p>接口在内部可以被认为是由一个元组 <code>(type, value)</code> 表示的。<code>type</code> 是接口的底层具体类型，而 <code>value</code> 持有具体类型的值。</p><p>让我们通过一个程序来更好地理解这一点。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> Worker <span class="hljs-keyword">interface</span> &#123;    Work()&#125;<span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;    name <span class="hljs-type">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> Work() &#123;    fmt.Println(p.name, <span class="hljs-string">&quot;is working&quot;</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">describe</span><span class="hljs-params">(w Worker)</span></span> &#123;    fmt.Printf(<span class="hljs-string">&quot;Interface type %T value %v\n&quot;</span>, w, w)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    p := Person&#123;        name: <span class="hljs-string">&quot;Naveen&quot;</span>,    &#125;    <span class="hljs-keyword">var</span> w Worker = p    describe(w)    w.Work()&#125;</code></pre></div><p><a href="https://play.golang.org/p/kweC7_oELzE">在 playground 中运行</a></p><p><em>Worker</em> 接口有一个方法 <code>Work()</code>，而 <em>Person</em> 结构体类型实现了该接口。在第 27 行，我们将 <code>Person</code> 类型的<a href="../%E3%80%90GolangBot%E3%80%913-%E5%8F%98%E9%87%8F/">变量</a> <code>p</code> 赋值给 <code>Worker</code> 类型的 <code>w</code>。现在 <code>w</code> 的具体类型是 <code>Person</code>，它包含一个 <code>name</code> 字段为 <code>Naveen</code> 的 <code>Person</code>。第 17 行的 <code>describe</code> 函数打印了接口的值和具体类型。这个程序输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">Interface type main.Person value &#123;Naveen&#125;Naveen is working</code></pre></div><p>我们将在接下来的章节中讨论如何提取接口的底层值。</p><h3 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h3><p><strong>没有任何方法的接口称为空接口。它表示为 <code>interface&#123;&#125;</code>。</strong> 由于空接口没有方法，所有类型都实现了空接口。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">describe</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;    fmt.Printf(<span class="hljs-string">&quot;Type = %T, value = %v\n&quot;</span>, i, i)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    s := <span class="hljs-string">&quot;Hello World&quot;</span>    describe(s)    i := <span class="hljs-number">55</span>    describe(i)    strt := <span class="hljs-keyword">struct</span> &#123;        name <span class="hljs-type">string</span>    &#125;&#123;        name: <span class="hljs-string">&quot;Naveen R&quot;</span>,    &#125;    describe(strt)&#125;</code></pre></div><p><a href="https://play.golang.org/p/Fm5KescoJb">在 playground 中运行</a></p><p>在上面的程序中，第 7 行的 <code>describe(i interface&#123;&#125;)</code> 函数接受一个空接口作为参数，因此可以传递任何类型。</p><p>我们分别在第 13、15 和 21 行向 <code>describe</code> 函数传递了 <code>string</code>、<code>int</code> 和 <code>struct</code> 类型。这个程序打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">Type = string, value = Hello WorldType = int, value = 55Type = struct &#123; name string &#125;, value = &#123;Naveen R&#125;</code></pre></div><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>类型断言用于提取接口的底层值。</p><p><strong>i.(T)</strong> 是用来获取接口 <code>i</code> 的底层值的语法，其中 <code>T</code> 是接口的具体类型。</p><p>通过一个程序来演示类型断言。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assert</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;s := i.(<span class="hljs-type">int</span>) <span class="hljs-comment">//get the underlying int value from i</span>fmt.Println(s)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> s <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-number">56</span>assert(s)&#125;</code></pre></div><p><a href="https://play.golang.org/p/YstKXEeSBL">Run in playground</a></p><p>如果在上面的程序中，<code>i</code> 的具体类型不是 <code>int</code>，程序会发生什么呢？让我们来看看。</p><p>如果我们尝试断言 <code>i</code> 为一个不同的类型（例如 <code>float64</code> 或 <code>string</code>），而 <code>i</code> 实际上并不是该类型，Go 会抛出一个运行时错误，称为 <strong>panic</strong>。这种情况称为类型断言失败。</p><p>我们可以修改程序，让它在类型不匹配时发生错误。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assert</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;s := i.(<span class="hljs-type">int</span>) fmt.Println(s)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> s <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-string">&quot;Steven Paul&quot;</span>assert(s)&#125;</code></pre></div><p><a href="https://play.golang.org/p/88KflSceHK">Run in playground</a></p><p>在上述程序中，我们将具体类型为 <code>string</code> 的 <code>s</code> 传递给 <code>assert</code> 函数，该函数尝试从中提取 <code>int</code> 值。此程序会因 <code>panic: interface conversion: interface &#123;&#125; is string, not int</code> 错误而崩溃。</p><p>为了解决这个问题，我们可以使用以下语法：</p><div class="code-wrapper"><pre><code class="hljs fallback">v, ok := i.(T)</code></pre></div><p>如果 <code>i</code> 的具体类型是 <code>T</code>，那么 <code>v</code> 将具有 <code>i</code> 的底层值，<code>ok</code> 将为 <code>true</code>。</p><p>如果 <code>i</code> 的具体类型不是 <code>T</code>，那么 <code>ok</code> 将为 <code>false</code>，<code>v</code> 将具有类型 <code>T</code> 的零值，并且 <strong>程序不会崩溃</strong>。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assert</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;v, ok := i.(<span class="hljs-type">int</span>)fmt.Println(v, ok)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> s <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-number">56</span>assert(s)<span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-string">&quot;Steven Paul&quot;</span>assert(i)&#125;</code></pre></div><p><a href="https://play.golang.org/p/0sB-KlVw8A">Run in playground</a></p><p>当 <code>Steven Paul</code> 被传递给 <code>assert</code> 函数时，由于 <code>i</code> 的具体类型不是 <code>int</code>，所以 <code>ok</code> 将为 <code>false</code>，<code>v</code> 将具有 <code>int</code> 类型的零值 0。该程序将打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">56 true0 false</code></pre></div><h3 id="类型switch"><a href="#类型switch" class="headerlink" title="类型switch"></a>类型switch</h3><p><strong>类型switch用于将接口的具体类型与多个类型进行比较，这些类型通过不同的 case 语句指定。它类似于 <a href="../%E3%80%90GolangBot%E3%80%9110-switch%E8%AF%AD%E5%8F%A5/">switch case</a>，唯一的区别是 case 中指定的是类型而不是值。</strong></p><p>类型开关的语法与类型断言类似。在类型断言中，语法是 <code>i.(T)</code>，而在类型开关中，类型 <code>T</code> 应该用关键字 <code>type</code> 替换。让我们看看下面的程序如何工作。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findType</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<span class="hljs-keyword">switch</span> i.(<span class="hljs-keyword">type</span>) &#123;<span class="hljs-keyword">case</span> <span class="hljs-type">string</span>:fmt.Printf(<span class="hljs-string">&quot;I am a string and my value is %s\n&quot;</span>, i.(<span class="hljs-type">string</span>))<span class="hljs-keyword">case</span> <span class="hljs-type">int</span>:fmt.Printf(<span class="hljs-string">&quot;I am an int and my value is %d\n&quot;</span>, i.(<span class="hljs-type">int</span>))<span class="hljs-keyword">default</span>:fmt.Printf(<span class="hljs-string">&quot;Unknown type\n&quot;</span>)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;findType(<span class="hljs-string">&quot;Naveen&quot;</span>)findType(<span class="hljs-number">77</span>)findType(<span class="hljs-number">89.98</span>)&#125;</code></pre></div><p><a href="https://play.golang.org/p/XYPDwOvoCh">Run in playground</a></p><p>在上面的程序中，<strong>第8行</strong>中的 <code>switch i.(type)</code> 指定了一个类型开关。每个 <code>case</code> 语句将接口 <code>i</code> 的具体类型与特定类型进行比较。如果某个 <code>case</code> 匹配，则打印相应的语句。该程序输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">I am a string and my value is NaveenI am an int and my value is 77Unknown type</code></pre></div><p><strong>第20行的*89.98*是<code>float64</code>类型，不匹配任何<code>case</code>，因此最后一行打印<code>Unknown type</code>。</strong></p><p><strong>也可以将类型与接口进行比较。如果我们有一个类型，并且这个类型实现了某个接口，那么可以将该类型与它实现的接口进行比较。</strong></p><p>让我们编写一个程序来进一步说明。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">type</span> Describer <span class="hljs-keyword">interface</span> &#123;Describe()&#125;<span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;name <span class="hljs-type">string</span>age  <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> Describe() &#123;fmt.Printf(<span class="hljs-string">&quot;%s is %d years old&quot;</span>, p.name, p.age)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findType</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<span class="hljs-keyword">switch</span> v := i.(<span class="hljs-keyword">type</span>) &#123;<span class="hljs-keyword">case</span> Describer:v.Describe()<span class="hljs-keyword">default</span>:fmt.Printf(<span class="hljs-string">&quot;unknown type\n&quot;</span>)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;findType(<span class="hljs-string">&quot;Naveen&quot;</span>)p := Person&#123;name: <span class="hljs-string">&quot;Naveen R&quot;</span>,age:  <span class="hljs-number">25</span>,&#125;findType(p)&#125;</code></pre></div><p><a href="https://play.golang.org/p/o6aHzIz4wC">Run in playground</a></p><p>在上述程序中，<code>Person</code> 结构体实现了 <code>Describer</code> 接口。在第19行的 <code>case</code> 语句中，<code>v</code> 被与 <code>Describer</code> 接口类型进行比较。由于 <code>p</code> 实现了 <code>Describer</code> 接口，因此此 <code>case</code> 被满足并调用了 <code>Describe()</code> 方法。</p><p>该程序输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">unknown typeNaveen R is 25 years old</code></pre></div><p><strong>Next tutorial - <a href="https://golangbot.com/interfaces-part-2/">Interfaces - II</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GolangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】17-方法</title>
    <link href="/%E3%80%90GolangBot%E3%80%9117-%E6%96%B9%E6%B3%95/"/>
    <url>/%E3%80%90GolangBot%E3%80%9117-%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到我们的 <a href="../golangbot/">Golang 教程系列</a>的第17篇教程。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>方法实际上就是一个带有特殊接收者类型的函数，这个接收者类型位于<code>func</code>关键字和方法名之间。接收者可以是结构体类型或非结构体类型。</p><p>方法声明的语法如下所示：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t Type)</span></span> methodName(parameter list) &#123;&#125;</code></pre></div><p>上面的代码片段创建了一个名为<code>methodName</code>的方法，其接收者类型为<code>Type</code>。<code>t</code>被称为接收者，可以在方法内部访问它。</p><h3 id="方法示例"><a href="#方法示例" class="headerlink" title="方法示例"></a>方法示例</h3><p>让我们编写一个简单的程序，在结构体类型上创建一个方法并调用它。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> Employee <span class="hljs-keyword">struct</span> &#123;    name     <span class="hljs-type">string</span>    salary   <span class="hljs-type">int</span>    currency <span class="hljs-type">string</span>&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> displaySalary() method has Employee as the receiver type</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e Employee)</span></span> displaySalary() &#123;    fmt.Printf(<span class="hljs-string">&quot;Salary of %s is %s%d&quot;</span>, e.name, e.currency, e.salary)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    emp1 := Employee &#123;        name:     <span class="hljs-string">&quot;Sam Adolf&quot;</span>,        salary:   <span class="hljs-number">5000</span>,        currency: <span class="hljs-string">&quot;$&quot;</span>,    &#125;    emp1.displaySalary() <span class="hljs-comment">//Calling displaySalary() method of Employee type</span>&#125;</code></pre></div><p><a href="https://play.golang.org/p/rRsI_sWAOZ">Run program in playground</a></p><p>在上面程序的第16行中，我们在<code>Employee</code>结构体类型上创建了一个方法<code>displaySalary</code>。<code>displaySalary()</code>方法在其内部可以访问接收者<code>e</code>。在第17行中，我们使用接收者<code>e</code>打印员工的姓名、货币和工资。</p><p>在第26行中，我们使用语法<code>emp1.displaySalary()</code>调用了该方法。</p><p>这个程序打印输出：<code>Salary of Sam Adolf is $5000</code>。</p><h3 id="方法与函数的比较"><a href="#方法与函数的比较" class="headerlink" title="方法与函数的比较"></a>方法与函数的比较</h3><p>上面的程序可以只使用函数而不使用方法重写。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> Employee <span class="hljs-keyword">struct</span> &#123;    name     <span class="hljs-type">string</span>    salary   <span class="hljs-type">int</span>    currency <span class="hljs-type">string</span>&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> displaySalary() method converted to function with Employee as parameter</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">displaySalary</span><span class="hljs-params">(e Employee)</span></span> &#123;    fmt.Printf(<span class="hljs-string">&quot;Salary of %s is %s%d&quot;</span>, e.name, e.currency, e.salary)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    emp1 := Employee&#123;        name:     <span class="hljs-string">&quot;Sam Adolf&quot;</span>,        salary:   <span class="hljs-number">5000</span>,        currency: <span class="hljs-string">&quot;$&quot;</span>,    &#125;    displaySalary(emp1)&#125;</code></pre></div><p><a href="https://play.golang.org/p/dFwObgCUU0">Run program in playground</a></p><p>在上面的程序中，<code>displaySalary</code>方法被转换为一个函数，并且<code>Employee</code>结构体作为参数传递给它。这个程序也产生完全相同的输出：<code>Salary of Sam Adolf is $5000</code>。</p><p>那么既然我们可以用函数写出相同的程序，为什么还要有方法呢？这里有几个原因。让我们一个一个来看。</p><ul><li><a href="https://go.dev/doc/faq#Is_Go_an_object-oriented_language">Go不是一个纯面向对象的编程语言</a>，它不支持类。因此，在类型上定义方法是实现类似类的行为的一种方式。方法允许对与类型相关的行为进行逻辑分组，类似于类。在上面的示例程序中，所有与<code>Employee</code>类型相关的行为都可以通过使用<code>Employee</code>接收者类型创建方法来分组。例如，我们可以添加诸如<code>calculatePension</code>、<code>calculateLeaves</code>等方法。</li><li>可以在不同的类型上定义相同名称的方法，而具有相同名称的函数是不允许的。假设我们有一个<code>Square</code>和<code>Circle</code>结构体。可以在<code>Square</code>和<code>Circle</code>上都定义一个名为<code>Area</code>的方法。这在下面的程序中演示：</li></ul><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;math&quot;</span>)<span class="hljs-keyword">type</span> Rectangle <span class="hljs-keyword">struct</span> &#123;    length <span class="hljs-type">int</span>    width  <span class="hljs-type">int</span>&#125;<span class="hljs-keyword">type</span> Circle <span class="hljs-keyword">struct</span> &#123;    radius <span class="hljs-type">float64</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r Rectangle)</span></span> Area() <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">return</span> r.length * r.width&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Circle)</span></span> Area() <span class="hljs-type">float64</span> &#123;    <span class="hljs-keyword">return</span> math.Pi * c.radius * c.radius&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    r := Rectangle&#123;        length: <span class="hljs-number">10</span>,        width:  <span class="hljs-number">5</span>,    &#125;    fmt.Printf(<span class="hljs-string">&quot;Area of rectangle %d\n&quot;</span>, r.Area())    c := Circle&#123;        radius: <span class="hljs-number">12</span>,    &#125;    fmt.Printf(<span class="hljs-string">&quot;Area of circle %f&quot;</span>, c.Area())&#125;</code></pre></div><p><a href="https://play.golang.org/p/0hDM3E3LiP">Run program in playground</a></p><p>这个程序打印输出：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Area</span> of rectangle <span class="hljs-number">50</span><span class="hljs-attribute">Area</span> of circle <span class="hljs-number">452</span>.<span class="hljs-number">389342</span></code></pre></div><p>方法的这个特性用于实现接口。我们将在下一篇介绍<a href="../%E3%80%90GolangBot%E3%80%9118-%E6%8E%A5%E5%8F%A3-I/">接口</a>的教程中详细讨论这一点。</p><h3 id="指针接收者与值接收者"><a href="#指针接收者与值接收者" class="headerlink" title="指针接收者与值接收者"></a>指针接收者与值接收者</h3><p>到目前为止，我们只看到了带有值接收者的方法。创建带有指针接收者的方法也是可能的。值接收者和指针接收者的区别在于，在带有指针接收者的方法内部所做的更改对调用者是可见的，而在值接收者中则不是这样。让我们通过一个程序来理解这一点。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> Employee <span class="hljs-keyword">struct</span> &#123;    name <span class="hljs-type">string</span>    age  <span class="hljs-type">int</span>&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">Method with value receiver</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e Employee)</span></span> changeName(newName <span class="hljs-type">string</span>) &#123;    e.name = newName&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">Method with pointer receiver</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *Employee)</span></span> changeAge(newAge <span class="hljs-type">int</span>) &#123;    e.age = newAge&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    e := Employee&#123;        name: <span class="hljs-string">&quot;Mark Andrew&quot;</span>,        age:  <span class="hljs-number">50</span>,    &#125;    fmt.Printf(<span class="hljs-string">&quot;Employee name before change: %s&quot;</span>, e.name)    e.changeName(<span class="hljs-string">&quot;Michael Andrew&quot;</span>)    fmt.Printf(<span class="hljs-string">&quot;\nEmployee name after change: %s&quot;</span>, e.name)    fmt.Printf(<span class="hljs-string">&quot;\n\nEmployee age before change: %d&quot;</span>, e.age)    (&amp;e).changeAge(<span class="hljs-number">51</span>)    fmt.Printf(<span class="hljs-string">&quot;\nEmployee age after change: %d&quot;</span>, e.age)&#125;</code></pre></div><p><a href="https://play.golang.org/p/tTO100HmUX">Run program in playground</a></p><p>在上面的程序中，<code>changeName</code>方法有一个值接收者<code>(e Employee)</code>，而<code>changeAge</code>方法有一个指针接收者<code>(e *Employee)</code>。在<code>changeName</code>内部对Employee结构体的<code>name</code>字段所做的更改对调用者不可见，因此在调用方法<code>e.changeName(&quot;Michael Andrew&quot;)</code>之前和之后，程序打印相同的名称。由于<code>changeAge</code>方法有一个指针接收者<code>(e *Employee)</code>，在调用方法<code>(&amp;e).changeAge(51)</code>之后对<code>age</code>字段所做的更改对调用者是可见的。这个程序打印输出：</p><div class="code-wrapper"><pre><code class="hljs coq">Employee name <span class="hljs-built_in">before</span> <span class="hljs-built_in">change</span>: Mark AndrewEmployee name <span class="hljs-built_in">after</span> <span class="hljs-built_in">change</span>: Mark AndrewEmployee age <span class="hljs-built_in">before</span> <span class="hljs-built_in">change</span>: <span class="hljs-number">50</span>Employee age <span class="hljs-built_in">after</span> <span class="hljs-built_in">change</span>: <span class="hljs-number">51</span></code></pre></div><p>在上面程序的第36行中，我们使用<code>(&amp;e).changeAge(51)</code>来调用<code>changeAge</code>方法。由于<code>changeAge</code>有一个指针接收者，我们使用了<code>(&amp;e)</code>来调用该方法。这其实不是必需的，语言给了我们直接使用<code>e.changeAge(51)</code>的选项。<code>e.changeAge(51)</code>会被语言解释为<code>(&amp;e).changeAge(51)</code>。</p><p>以下程序重写为使用<code>e.changeAge(51)</code>而不是<code>(&amp;e).changeAge(51)</code>，它打印相同的输出：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> Employee <span class="hljs-keyword">struct</span> &#123;    name <span class="hljs-type">string</span>    age  <span class="hljs-type">int</span>&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">Method with value receiver</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e Employee)</span></span> changeName(newName <span class="hljs-type">string</span>) &#123;    e.name = newName&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">Method with pointer receiver</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *Employee)</span></span> changeAge(newAge <span class="hljs-type">int</span>) &#123;    e.age = newAge&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    e := Employee&#123;        name: <span class="hljs-string">&quot;Mark Andrew&quot;</span>,        age:  <span class="hljs-number">50</span>,    &#125;    fmt.Printf(<span class="hljs-string">&quot;Employee name before change: %s&quot;</span>, e.name)    e.changeName(<span class="hljs-string">&quot;Michael Andrew&quot;</span>)    fmt.Printf(<span class="hljs-string">&quot;\nEmployee name after change: %s&quot;</span>, e.name)    fmt.Printf(<span class="hljs-string">&quot;\n\nEmployee age before change: %d&quot;</span>, e.age)    e.changeAge(<span class="hljs-number">51</span>)    fmt.Printf(<span class="hljs-string">&quot;\nEmployee age after change: %d&quot;</span>, e.age)&#125;</code></pre></div><p><a href="https://play.golang.org/p/nnXBsR3Uc8">Run program in playground</a></p><h3 id="什么时候使用指针接收者，什么时候使用值接收者"><a href="#什么时候使用指针接收者，什么时候使用值接收者" class="headerlink" title="什么时候使用指针接收者，什么时候使用值接收者"></a>什么时候使用指针接收者，什么时候使用值接收者</h3><p>通常，当在方法内部对接收者所做的更改需要对调用者可见时，可以使用指针接收者。</p><p>在复制数据结构代价较高的地方也可以使用指针接收者。考虑一个有很多字段的结构体。在方法中使用这个结构体作为值接收者将需要复制整个结构体，这将是昂贵的。在这种情况下，如果使用指针接收者，结构体将不会被复制，只会在方法中使用指向它的指针。</p><p>在所有其他情况下，可以使用值接收者。</p><h3 id="匿名结构体字段的方法"><a href="#匿名结构体字段的方法" class="headerlink" title="匿名结构体字段的方法"></a>匿名结构体字段的方法</h3><p>属于结构体的匿名字段的方法可以像属于定义匿名字段的结构体一样被调用。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> address <span class="hljs-keyword">struct</span> &#123;    city  <span class="hljs-type">string</span>    state <span class="hljs-type">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a address)</span></span> fullAddress() &#123;    fmt.Printf(<span class="hljs-string">&quot;Full address: %s, %s&quot;</span>, a.city, a.state)&#125;<span class="hljs-keyword">type</span> person <span class="hljs-keyword">struct</span> &#123;    firstName <span class="hljs-type">string</span>    lastName  <span class="hljs-type">string</span>    address&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    p := person&#123;        firstName: <span class="hljs-string">&quot;Elon&quot;</span>,        lastName:  <span class="hljs-string">&quot;Musk&quot;</span>,        address: address &#123;            city:  <span class="hljs-string">&quot;Los Angeles&quot;</span>,            state: <span class="hljs-string">&quot;California&quot;</span>,        &#125;,    &#125;    p.fullAddress() <span class="hljs-comment">//accessing fullAddress method of address struct</span>&#125;</code></pre></div><p><a href="https://play.golang.org/p/vURnImw4_9">Run program in playground</a></p><p>在上面程序的第32行中，我们使用<code>p.fullAddress()</code>调用了<code>address</code>结构体的<code>fullAddress()</code>方法。不需要显式的方向<code>p.address.fullAddress()</code>。这个程序打印：</p><div class="code-wrapper"><pre><code class="hljs css">Full <span class="hljs-selector-tag">address</span>: Los Angeles, California</code></pre></div><h3 id="方法中的值接收者vs函数中的值参数"><a href="#方法中的值接收者vs函数中的值参数" class="headerlink" title="方法中的值接收者vs函数中的值参数"></a>方法中的值接收者vs函数中的值参数</h3><p>这个主题让很多Go新手感到困惑。我会尽量让它变得清晰 😀。</p><p>当函数有一个值参数时，它只接受值参数。</p><p>当方法有一个值接收者时，它会同时接受指针和值接收者。</p><p>让我们通过一个例子来理解这一点。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> rectangle <span class="hljs-keyword">struct</span> &#123;    length <span class="hljs-type">int</span>    width  <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">area</span><span class="hljs-params">(r rectangle)</span></span> &#123;    fmt.Printf(<span class="hljs-string">&quot;Area Function result: %d\n&quot;</span>, (r.length * r.width))&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r rectangle)</span></span> area() &#123;    fmt.Printf(<span class="hljs-string">&quot;Area Method result: %d\n&quot;</span>, (r.length * r.width))&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    r := rectangle&#123;        length: <span class="hljs-number">10</span>,        width:  <span class="hljs-number">5</span>,    &#125;    area(r)    r.area()    p := &amp;r    <span class="hljs-comment">/*</span><span class="hljs-comment">       compilation error, cannot use p (type *rectangle) as type rectangle </span><span class="hljs-comment">       in argument to area    </span><span class="hljs-comment">    */</span>    <span class="hljs-comment">//area(p)</span>    p.area()<span class="hljs-comment">//calling value receiver with a pointer</span>&#125;</code></pre></div><p><a href="https://play.golang.org/p/gLyHMd2iie">Run program in playground</a></p><p>第12行的函数<code>func area(r rectangle)</code>接受一个值参数，第16行的方法<code>func (r rectangle) area()</code>接受一个值接收者。</p><p>在第25行，我们用值参数调用area函数<code>area(r)</code>，这是可以的。类似地，我们使用值接收者调用area方法<code>r.area()</code>，这也是可以的。</p><p>我们在第28行创建了一个指向<code>r</code>的指针<code>p</code>。如果我们试图将这个指针传递给只接受值的area函数，编译器会报错。我在第33行注释了这个操作。如果你取消这行的注释，编译器会抛出错误<strong>compilation error, cannot use p (type *rectangle) as type rectangle in argument to area</strong>。这符合预期的行为。</p><p>现在来看棘手的部分，代码第35行<code>p.area()</code>使用指针接收者<code>p</code>调用只接受值接收者的方法<code>area</code>。这是完全有效的。原因是<code>p.area()</code>这行代码会被Go解释为<code>(*p).area()</code>，因为<code>area</code>有一个值接收者。这是为了方便而做的处理。</p><p>这个程序将输出：</p><div class="code-wrapper"><pre><code class="hljs oxygene">Area <span class="hljs-keyword">Function</span> <span class="hljs-title function_">result</span>: <span class="hljs-number">50</span>Area <span class="hljs-keyword">Method</span> <span class="hljs-title function_">result</span>: <span class="hljs-number">50</span>Area <span class="hljs-keyword">Method</span> <span class="hljs-title function_">result</span>: <span class="hljs-number">50</span></code></pre></div><h3 id="方法中的指针接收者vs函数中的指针参数"><a href="#方法中的指针接收者vs函数中的指针参数" class="headerlink" title="方法中的指针接收者vs函数中的指针参数"></a>方法中的指针接收者vs函数中的指针参数</h3><p>与值参数类似，带有指针参数的函数只接受指针，而带有指针接收者的方法将同时接受指针和值接收者。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> rectangle <span class="hljs-keyword">struct</span> &#123;length <span class="hljs-type">int</span>width  <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">perimeter</span><span class="hljs-params">(r *rectangle)</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;perimeter function output:&quot;</span>, <span class="hljs-number">2</span>*(r.length+r.width))&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *rectangle)</span></span> perimeter() &#123;fmt.Println(<span class="hljs-string">&quot;perimeter method output:&quot;</span>, <span class="hljs-number">2</span>*(r.length+r.width))&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;r := rectangle&#123;length: <span class="hljs-number">10</span>,width:  <span class="hljs-number">5</span>,&#125;p := &amp;r <span class="hljs-comment">//pointer to r</span>perimeter(p)p.perimeter()<span class="hljs-comment">/*</span><span class="hljs-comment">cannot use r (type rectangle) as type *rectangle in argument to perimeter</span><span class="hljs-comment">*/</span><span class="hljs-comment">//perimeter(r)</span>r.perimeter()<span class="hljs-comment">//calling pointer receiver with a value</span>&#125;</code></pre></div><p><a href="https://play.golang.org/p/Xy5wW9YZMJ">Run program in playground</a></p><p>上面程序的第12行定义了一个接受指针参数的函数<code>perimeter</code>，第17行定义了一个有指针接收者的方法。</p><p>在第27行，我们用指针参数调用perimeter函数，在第28行，我们在指针接收者上调用perimeter方法。这些都是正确的。</p><p>在注释掉的第33行，我们试图用值参数<code>r</code>调用perimeter函数。这是不允许的，因为带有指针参数的函数不接受值参数。如果取消这行的注释并运行程序，编译会失败并显示错误<strong>main.go:33: cannot use r (type rectangle) as type *rectangle in argument to perimeter</strong>。</p><p>在第35行，我们用值接收者<code>r</code>调用指针接收者方法<code>perimeter</code>。这是允许的，代码<code>r.perimeter()</code>会被语言解释为<code>(&amp;r).perimeter()</code>，这是为了方便而做的处理。程序将会输出</p><div class="code-wrapper"><pre><code class="hljs fallback">perimeter function output: 30perimeter method output: 30perimeter method output: 30</code></pre></div><h3 id="非结构体接收者的方法"><a href="#非结构体接收者的方法" class="headerlink" title="非结构体接收者的方法"></a>非结构体接收者的方法</h3><p>到目前为止，我们只在结构体类型上定义了方法。实际上，也可以在非结构体类型上定义方法，但有一个注意事项：<strong>为了在某个类型上定义方法，该类型的定义和方法的定义必须位于同一个包中。</strong> 到目前为止，我们定义的所有结构体和结构体上的方法都位于同一个 <code>main</code> 包中，因此它们都能正常工作。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a <span class="hljs-type">int</span>)</span></span> add(b <span class="hljs-type">int</span>) &#123;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;&#125;</code></pre></div><p><a href="https://play.golang.org/p/ybXLf5o_lA">Run program in playground</a></p><p>在上面的程序中，第三行我们尝试为内建类型 <code>int</code> 添加一个名为 <code>add</code> 的方法。这是不允许的，因为方法 <code>add</code> 的定义和类型 <code>int</code> 的定义不在同一个包中。这个程序会抛出编译错误 <strong>cannot define new methods on non-local type int</strong>。</p><p>使其正常工作的方式是为内建类型 <code>int</code> 创建一个类型别名，然后使用这个类型别名作为接收者定义方法。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">type</span> myInt <span class="hljs-type">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a myInt)</span></span> add(b myInt) myInt &#123;<span class="hljs-keyword">return</span> a + b&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;num1 := myInt(<span class="hljs-number">5</span>)num2 := myInt(<span class="hljs-number">10</span>)sum := num1.add(num2)fmt.Println(<span class="hljs-string">&quot;Sum is&quot;</span>, sum)&#125;</code></pre></div><p><a href="https://play.golang.org/p/sTe7i1qAng">Run program in playground</a></p><p>在上述程序的第五行，我们为 <code>int</code> 创建了一个类型别名 <code>myInt</code>。在第七行，我们定义了一个方法 <code>add</code>，其接收者是 <code>myInt</code>。</p><p>该程序将输出 <code>Sum is 15</code>。</p><p>我已在 <a href="https://github.com/golangbot/methods">github</a> 上创建了一个包含我们讨论过的所有概念的程序。</p><p><strong>下一篇教程 - <a href="../%E3%80%90GolangBot%E3%80%9118-%E6%8E%A5%E5%8F%A3-I">接口 - I</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GolangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】16-结构体</title>
    <link href="/%E3%80%90GolangBot%E3%80%9116-%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <url>/%E3%80%90GolangBot%E3%80%9116-%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到我们的 <a href="../golangbot/">Golang 教程系列</a>的第16篇教程。</p><h3 id="什么是结构体？"><a href="#什么是结构体？" class="headerlink" title="什么是结构体？"></a>什么是结构体？</h3><p>结构体是一个用户定义的类型，表示一组字段的集合。在某些情况下，将数据组合成一个单元比将每个数据作为单独的值更有意义，这时就可以使用结构体。</p><p>例如，一个员工有firstName、lastName和age。将这三个属性组合到一个名为<code>Employee</code>的结构体中是有意义的。</p><h3 id="声明结构体"><a href="#声明结构体" class="headerlink" title="声明结构体"></a>声明结构体</h3><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Employee <span class="hljs-keyword">struct</span> &#123;    firstName <span class="hljs-type">string</span>    lastName  <span class="hljs-type">string</span>    age       <span class="hljs-type">int</span>&#125;</code></pre></div><p>上面的代码声明了一个<code>Employee</code>结构体类型，包含<code>firstName</code>、<code>lastName</code>和<code>age</code>字段。上面的<code>Employee</code>结构体被称为<strong>命名结构体</strong>，因为它使用新的数据类型名称<code>Employee</code>创建了一个新的数据类型，可以用它来创建<code>Employee</code>结构体。</p><p>这个结构体也可以通过将属于同一类型的字段在一行中声明来使其更加紧凑，后面跟着类型名称。在上面的结构体中，<code>firstName</code>和<code>lastName</code>属于同一个类型<code>string</code>，因此结构体可以重写为：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Employee <span class="hljs-keyword">struct</span> &#123;    firstName, lastName <span class="hljs-type">string</span>    age                <span class="hljs-type">int</span>&#125;</code></pre></div><p><em>虽然上述语法节省了几行代码，但它没有使字段声明明确。请避免使用上述语法。</em></p><h3 id="创建命名结构体"><a href="#创建命名结构体" class="headerlink" title="创建命名结构体"></a>创建命名结构体</h3><p>让我们使用以下简单程序声明一个<strong>命名结构体Employee</strong>。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> Employee <span class="hljs-keyword">struct</span> &#123;    firstName <span class="hljs-type">string</span>    lastName  <span class="hljs-type">string</span>    age       <span class="hljs-type">int</span>    salary    <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-comment">//creating struct specifying field names</span>    emp1 := Employee&#123;        firstName: <span class="hljs-string">&quot;Sam&quot;</span>,        age:       <span class="hljs-number">25</span>,        salary:    <span class="hljs-number">500</span>,        lastName:  <span class="hljs-string">&quot;Anderson&quot;</span>,    &#125;    <span class="hljs-comment">//creating struct without specifying field names</span>    emp2 := Employee&#123;<span class="hljs-string">&quot;Thomas&quot;</span>, <span class="hljs-string">&quot;Paul&quot;</span>, <span class="hljs-number">29</span>, <span class="hljs-number">800</span>&#125;    fmt.Println(<span class="hljs-string">&quot;Employee 1&quot;</span>, emp1)    fmt.Println(<span class="hljs-string">&quot;Employee 2&quot;</span>, emp2)&#125;</code></pre></div><p><a href="https://play.golang.org/p/WPlLuPy0Lty">Run in playground</a></p><p>在上面程序的第7行中，我们创建了一个命名结构体类型<code>Employee</code>。在程序的第17行中，通过指定每个字段名的值来定义<code>emp1</code>结构体。字段的顺序不需要与声明结构体类型时的字段名顺序相同。在这种情况下，我们改变了<code>lastName</code>的位置并将其移到末尾。这样做不会有任何问题。</p><p>**在程序的第25行中，定义<code>emp2</code>时省略了字段名。在这种情况下，必须保持字段的顺序与结构体声明中指定的顺序相同。请避免使用这种语法，因为很难弄清楚哪个值对应哪个字段。**我们在这里提到这种格式只是为了让大家了解这也是一种有效的语法 :)</p><p>上述程序打印输出：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Employee</span> <span class="hljs-number">1</span> &#123;Sam Anderson <span class="hljs-number">25</span> <span class="hljs-number">500</span>&#125;  <span class="hljs-attribute">Employee</span> <span class="hljs-number">2</span> &#123;Thomas Paul <span class="hljs-number">29</span> <span class="hljs-number">800</span>&#125;</code></pre></div><h3 id="创建匿名结构体"><a href="#创建匿名结构体" class="headerlink" title="创建匿名结构体"></a>创建匿名结构体</h3><p>可以在不创建新数据类型的情况下声明结构体。这种类型的结构体称为<strong>匿名结构体</strong>。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    emp3 := <span class="hljs-keyword">struct</span> &#123;        firstName <span class="hljs-type">string</span>        lastName  <span class="hljs-type">string</span>        age       <span class="hljs-type">int</span>        salary    <span class="hljs-type">int</span>    &#125;&#123;        firstName: <span class="hljs-string">&quot;Andreah&quot;</span>,        lastName:  <span class="hljs-string">&quot;Nikola&quot;</span>,        age:       <span class="hljs-number">31</span>,        salary:    <span class="hljs-number">5000</span>,    &#125;    fmt.Println(<span class="hljs-string">&quot;Employee 3&quot;</span>, emp3)&#125;</code></pre></div><p><a href="https://play.golang.org/p/m_7UoICTiMy">Run in playground</a></p><p>在上面程序的第8行中，定义了一个<strong>匿名结构体变量</strong><code>emp3</code>。正如我们已经提到的，这个结构体之所以称为匿名，是因为它只创建了一个新的结构体变量<code>emp3</code>，而没有像命名结构体那样定义任何新的结构体类型。</p><p>此程序输出：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Employee</span> <span class="hljs-number">3</span> &#123;Andreah Nikola <span class="hljs-number">31</span> <span class="hljs-number">5000</span>&#125;</code></pre></div><h3 id="访问结构体的单个字段"><a href="#访问结构体的单个字段" class="headerlink" title="访问结构体的单个字段"></a>访问结构体的单个字段</h3><p>使用点<code>.</code>运算符来访问结构体的单个字段。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> Employee <span class="hljs-keyword">struct</span> &#123;    firstName <span class="hljs-type">string</span>    lastName  <span class="hljs-type">string</span>    age       <span class="hljs-type">int</span>    salary    <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    emp6 := Employee&#123;        firstName: <span class="hljs-string">&quot;Sam&quot;</span>,        lastName:  <span class="hljs-string">&quot;Anderson&quot;</span>,        age:       <span class="hljs-number">55</span>,        salary:    <span class="hljs-number">6000</span>,    &#125;    fmt.Println(<span class="hljs-string">&quot;First Name:&quot;</span>, emp6.firstName)    fmt.Println(<span class="hljs-string">&quot;Last Name:&quot;</span>, emp6.lastName)    fmt.Println(<span class="hljs-string">&quot;Age:&quot;</span>, emp6.age)    fmt.Printf(<span class="hljs-string">&quot;Salary: $%d\n&quot;</span>, emp6.salary)    emp6.salary = <span class="hljs-number">6500</span>    fmt.Printf(<span class="hljs-string">&quot;New Salary: $%d&quot;</span>, emp6.salary)&#125;</code></pre></div><p><a href="https://play.golang.org/p/iggKCd8xUMy">Run in playground</a></p><p><strong>emp6.firstName</strong>在上面的程序中访问<code>emp6</code>结构体的<code>firstName</code>字段。在第25行中，我们修改了员工的工资。这个程序打印：</p><div class="code-wrapper"><pre><code class="hljs nestedtext"><span class="hljs-attribute">First Name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Sam</span><span class="hljs-attribute">Last Name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Anderson</span><span class="hljs-attribute">Age</span><span class="hljs-punctuation">:</span> <span class="hljs-string">55</span><span class="hljs-attribute">Salary</span><span class="hljs-punctuation">:</span> <span class="hljs-string">$6000</span><span class="hljs-attribute">New Salary</span><span class="hljs-punctuation">:</span> <span class="hljs-string">$6500</span></code></pre></div><h3 id="结构体的零值"><a href="#结构体的零值" class="headerlink" title="结构体的零值"></a>结构体的零值</h3><p>当定义一个结构体但没有显式地用任何值初始化时，结构体的字段会被默认赋予它们的零值。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> Employee <span class="hljs-keyword">struct</span> &#123;    firstName <span class="hljs-type">string</span>    lastName  <span class="hljs-type">string</span>    age       <span class="hljs-type">int</span>    salary    <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">var</span> emp4 Employee <span class="hljs-comment">//zero valued struct</span>    fmt.Println(<span class="hljs-string">&quot;First Name:&quot;</span>, emp4.firstName)    fmt.Println(<span class="hljs-string">&quot;Last Name:&quot;</span>, emp4.lastName)    fmt.Println(<span class="hljs-string">&quot;Age:&quot;</span>, emp4.age)    fmt.Println(<span class="hljs-string">&quot;Salary:&quot;</span>, emp4.salary)&#125;</code></pre></div><p><a href="https://play.golang.org/p/jiCEH1tFvgW">Run in playground</a></p><p>上面的程序定义了<code>emp4</code>但没有用任何值初始化它。因此<code>firstName</code>和<code>lastName</code>被赋予了string的零值，即空字符串<code>&quot;&quot;</code>，而<code>age</code>和<code>salary</code>被赋予了int的零值，即0。这个程序打印：</p><div class="code-wrapper"><pre><code class="hljs nestedtext"><span class="hljs-attribute">First Name</span><span class="hljs-punctuation">: </span><span class="hljs-attribute">Last Name</span><span class="hljs-punctuation">: </span><span class="hljs-attribute">Age</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0</span><span class="hljs-attribute">Salary</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0</span></code></pre></div><p>也可以指定某些字段的值而忽略其他字段。在这种情况下，被忽略的字段会被赋予零值。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> Employee <span class="hljs-keyword">struct</span> &#123;    firstName <span class="hljs-type">string</span>    lastName  <span class="hljs-type">string</span>    age       <span class="hljs-type">int</span>    salary    <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    emp5 := Employee&#123;        firstName: <span class="hljs-string">&quot;John&quot;</span>,        lastName:  <span class="hljs-string">&quot;Paul&quot;</span>,    &#125;    fmt.Println(<span class="hljs-string">&quot;First Name:&quot;</span>, emp5.firstName)    fmt.Println(<span class="hljs-string">&quot;Last Name:&quot;</span>, emp5.lastName)    fmt.Println(<span class="hljs-string">&quot;Age:&quot;</span>, emp5.age)    fmt.Println(<span class="hljs-string">&quot;Salary:&quot;</span>, emp5.salary)&#125;</code></pre></div><p><a href="https://play.golang.org/p/WANoyFfRt_y">Run in playground</a></p><p>在上面程序的第16行和第17行，初始化了<code>firstName</code>和<code>lastName</code>，而<code>age</code>和<code>salary</code>没有被初始化。因此<code>age</code>和<code>salary</code>被赋予了它们的零值。这个程序输出：</p><div class="code-wrapper"><pre><code class="hljs nestedtext"><span class="hljs-attribute">First Name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">John</span><span class="hljs-attribute">Last Name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Paul</span><span class="hljs-attribute">Age</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0</span><span class="hljs-attribute">Salary</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0</span></code></pre></div><h3 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h3><p>也可以创建指向结构体的指针。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> Employee <span class="hljs-keyword">struct</span> &#123;    firstName <span class="hljs-type">string</span>    lastName  <span class="hljs-type">string</span>    age       <span class="hljs-type">int</span>    salary    <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    emp8 := &amp;Employee&#123;        firstName: <span class="hljs-string">&quot;Sam&quot;</span>,        lastName:  <span class="hljs-string">&quot;Anderson&quot;</span>,        age:       <span class="hljs-number">55</span>,        salary:    <span class="hljs-number">6000</span>,    &#125;    fmt.Println(<span class="hljs-string">&quot;First Name:&quot;</span>, (*emp8).firstName)    fmt.Println(<span class="hljs-string">&quot;Age:&quot;</span>, (*emp8).age)&#125;</code></pre></div><p><a href="https://play.golang.org/p/Rli_WqmE9_H">Run in playground</a></p><p><strong>emp8</strong>在上面的程序中是指向<code>Employee</code>结构体的指针。<code>(*emp8).firstName</code>是访问<code>emp8</code>结构体的<code>firstName</code>字段的语法。这个程序打印：</p><div class="code-wrapper"><pre><code class="hljs nestedtext"><span class="hljs-attribute">First Name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Sam</span><span class="hljs-attribute">Age</span><span class="hljs-punctuation">:</span> <span class="hljs-string">55</span></code></pre></div><p><strong>Go语言给我们提供了使用<code>emp8.firstName</code>而不是显式解引用<code>(*emp8).firstName</code>来访问<code>firstName</code>字段的选项。</strong></p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> Employee <span class="hljs-keyword">struct</span> &#123;    firstName <span class="hljs-type">string</span>    lastName  <span class="hljs-type">string</span>    age       <span class="hljs-type">int</span>    salary    <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    emp8 := &amp;Employee&#123;        firstName: <span class="hljs-string">&quot;Sam&quot;</span>,        lastName:  <span class="hljs-string">&quot;Anderson&quot;</span>,        age:       <span class="hljs-number">55</span>,        salary:    <span class="hljs-number">6000</span>,    &#125;    fmt.Println(<span class="hljs-string">&quot;First Name:&quot;</span>, emp8.firstName)    fmt.Println(<span class="hljs-string">&quot;Age:&quot;</span>, emp8.age)&#125;</code></pre></div><p><a href="https://go.dev/play/p/LxEQgUm3_Fu">Run in playground</a></p><p>我们在上面的程序中使用了<code>emp8.firstName</code>来访问<code>firstName</code>字段，这个程序也输出：</p><div class="code-wrapper"><pre><code class="hljs nestedtext"><span class="hljs-attribute">First Name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Sam</span><span class="hljs-attribute">Age</span><span class="hljs-punctuation">:</span> <span class="hljs-string">55</span></code></pre></div><h3 id="匿名字段"><a href="#匿名字段" class="headerlink" title="匿名字段"></a>匿名字段</h3><p>可以创建只包含类型而没有字段名的结构体字段。这种字段被称为匿名字段。</p><p>下面的代码片段创建了一个<code>Person</code>结构体，它有两个匿名字段<code>string</code>和<code>int</code></p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;    <span class="hljs-type">string</span>    <span class="hljs-type">int</span>&#125;</code></pre></div><p>**虽然匿名字段没有显式的名称，但默认情况下匿名字段的名称是其类型的名称。**例如在上面的Person结构体中，尽管这些字段是匿名的，但默认情况下它们采用字段类型的名称。所以Person结构体有2个名为<code>string</code>和<code>int</code>的字段。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;    <span class="hljs-type">string</span>    <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    p1 := Person&#123;        <span class="hljs-type">string</span>: <span class="hljs-string">&quot;naveen&quot;</span>,        <span class="hljs-type">int</span>:    <span class="hljs-number">50</span>,    &#125;    fmt.Println(p1.<span class="hljs-type">string</span>)    fmt.Println(p1.<span class="hljs-type">int</span>)&#125;</code></pre></div><p><a href="https://play.golang.org/p/zDkb0EbLqyJ">Run in playground</a></p><p>在上面程序的第17行和第18行中，我们使用它们的类型作为字段名来访问Person结构体的匿名字段，即<code>string</code>和<code>int</code>。上面程序的输出是：</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">naveen</span><span class="hljs-number">50</span></code></pre></div><h3 id="嵌套结构体"><a href="#嵌套结构体" class="headerlink" title="嵌套结构体"></a>嵌套结构体</h3><p>结构体可以包含一个字段，这个字段本身就是一个结构体。这种结构体被称为嵌套结构体。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> Address <span class="hljs-keyword">struct</span> &#123;    city  <span class="hljs-type">string</span>    state <span class="hljs-type">string</span>&#125;<span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;    name    <span class="hljs-type">string</span>    age     <span class="hljs-type">int</span>    address Address&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    p := Person&#123;        name: <span class="hljs-string">&quot;Naveen&quot;</span>,        age:  <span class="hljs-number">50</span>,        address: Address&#123;            city:  <span class="hljs-string">&quot;Chicago&quot;</span>,            state: <span class="hljs-string">&quot;Illinois&quot;</span>,        &#125;,    &#125;    fmt.Println(<span class="hljs-string">&quot;Name:&quot;</span>, p.name)    fmt.Println(<span class="hljs-string">&quot;Age:&quot;</span>, p.age)    fmt.Println(<span class="hljs-string">&quot;City:&quot;</span>, p.address.city)    fmt.Println(<span class="hljs-string">&quot;State:&quot;</span>, p.address.state)&#125;</code></pre></div><p>上面程序中的<code>Person</code>结构体有一个字段<code>address</code>，这个字段本身就是一个结构体。这个程序打印：</p><div class="code-wrapper"><pre><code class="hljs avrasm"><span class="hljs-symbol">Name:</span> Naveen<span class="hljs-symbol">Age:</span> <span class="hljs-number">50</span><span class="hljs-symbol">City:</span> Chicago<span class="hljs-symbol">State:</span> Illinois</code></pre></div><h3 id="提升字段"><a href="#提升字段" class="headerlink" title="提升字段"></a>提升字段</h3><p>属于结构体中的匿名结构体字段的字段被称为提升字段，因为可以像它们属于拥有匿名结构体字段的结构体一样访问它们。我知道这个定义很复杂，所以让我们直接看一些代码来理解这一点 :)。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Address <span class="hljs-keyword">struct</span> &#123;    city <span class="hljs-type">string</span>    state <span class="hljs-type">string</span>&#125;<span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;    name <span class="hljs-type">string</span>    age  <span class="hljs-type">int</span>    Address&#125;</code></pre></div><p>在上面的代码片段中，<code>Person</code>结构体有一个匿名字段<code>Address</code>，它是一个结构体。现在<code>Address</code>的字段<code>city</code>和<code>state</code>被称为提升字段，因为它们可以像直接在<code>Person</code>结构体中声明的一样被访问。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> Address <span class="hljs-keyword">struct</span> &#123;    city  <span class="hljs-type">string</span>    state <span class="hljs-type">string</span>&#125;<span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;    name <span class="hljs-type">string</span>    age  <span class="hljs-type">int</span>    Address&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    p := Person&#123;        name: <span class="hljs-string">&quot;Naveen&quot;</span>,        age:  <span class="hljs-number">50</span>,        Address: Address&#123;            city:  <span class="hljs-string">&quot;Chicago&quot;</span>,            state: <span class="hljs-string">&quot;Illinois&quot;</span>,        &#125;,    &#125;    fmt.Println(<span class="hljs-string">&quot;Name:&quot;</span>, p.name)    fmt.Println(<span class="hljs-string">&quot;Age:&quot;</span>, p.age)    fmt.Println(<span class="hljs-string">&quot;City:&quot;</span>, p.city)   <span class="hljs-comment">//city is promoted field</span>    fmt.Println(<span class="hljs-string">&quot;State:&quot;</span>, p.state) <span class="hljs-comment">//state is promoted field</span>&#125;</code></pre></div><p><a href="https://play.golang.org/p/ZwfRatdwc4p">Run in playground</a></p><p>在上面程序的第29行和第30行中，提升字段<code>city</code>和<code>state</code>使用语法<code>p.city</code>和<code>p.state</code>访问，就像它们是在结构体<code>p</code>中声明的一样。这个程序打印：</p><div class="code-wrapper"><pre><code class="hljs avrasm"><span class="hljs-symbol">Name:</span> Naveen<span class="hljs-symbol">Age:</span> <span class="hljs-number">50</span><span class="hljs-symbol">City:</span> Chicago<span class="hljs-symbol">State:</span> Illinois</code></pre></div><h3 id="导出的结构体和字段"><a href="#导出的结构体和字段" class="headerlink" title="导出的结构体和字段"></a>导出的结构体和字段</h3><p>如果结构体类型以大写字母开头，那么它就是一个导出类型，可以从其他包中访问。类似地，如果结构体的字段以大写字母开头，它们也可以从其他包中访问。</p><p>让我们编写一个具有自定义包的程序来更好地理解这一点。</p><p>在你的<code>Documents</code>目录中创建一个名为<code>structs</code>的文件夹。你可以随意在任何地方创建它。我更喜欢我的<code>Documents</code>目录。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> ~/Documents/structs</code></pre></div><p>让我们创建一个名为<code>structs</code>的go模块。</p><div class="code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">cd</span> ~/Documents/structs/<span class="hljs-keyword">go</span> <span class="hljs-keyword">mod</span> init structs</code></pre></div><p>在<code>structs</code>里面创建另一个目录<code>computer</code>。</p><div class="code-wrapper"><pre><code class="hljs arduino">mkdir computer</code></pre></div><p>在<code>computer</code>目录中，创建一个文件<code>spec.go</code>，内容如下。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> computer<span class="hljs-keyword">type</span> Spec <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">//exported struct</span>    Maker <span class="hljs-type">string</span> <span class="hljs-comment">//exported field</span>    Price <span class="hljs-type">int</span> <span class="hljs-comment">//exported field</span>    model <span class="hljs-type">string</span> <span class="hljs-comment">//unexported field</span>&#125;</code></pre></div><p>上述代码片段创建了一个 <a href="https://golangbot.com/go-packages/">包</a> <code>computer</code>，该包包含一个已导出的结构体类型 <code>Spec</code>，其中包含两个已导出的字段 <code>Maker</code> 和 <code>Price</code>，以及一个未导出的字段 <code>model</code>。接下来，让我们从主包中导入这个包，并使用 <code>Spec</code> 结构体。</p><p>在 <code>structs</code> 目录下创建一个名为 <code>main.go</code> 的文件，并在 <code>main.go</code> 中编写以下程序：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;structs/computer&quot;</span>    <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;spec := computer.Spec &#123;            Maker: <span class="hljs-string">&quot;apple&quot;</span>,            Price: <span class="hljs-number">50000</span>,        &#125;fmt.Println(<span class="hljs-string">&quot;Maker:&quot;</span>, spec.Maker)    fmt.Println(<span class="hljs-string">&quot;Price:&quot;</span>, spec.Price)&#125;</code></pre></div><p><code>structs</code>文件夹应该有如下的结构，</p><div class="code-wrapper"><pre><code class="hljs fallback">├── structs│   ├── computer│   │   └── spec.go│   ├── go.mod│   └── main.```</code></pre></div><p>在上述程序的第4行，我们导入了 <code>computer</code> 包。在第13行和第14行，我们访问了结构体 <code>Spec</code> 的两个已导出的字段 <code>Maker</code> 和 <code>Price</code>。可以通过执行命令 <code>go install</code> 后跟 <code>structs</code> 命令来运行此程序。</p><div class="code-wrapper"><pre><code class="hljs fallback">go installstructs</code></pre></div><p>运行上面的程序将会打印，</p><div class="code-wrapper"><pre><code class="hljs fallback">Maker: applePrice: 50000</code></pre></div><p>如果我们尝试访问未导出的字段 model，编译器会报错。将 main.go 的内容替换为以下代码。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;structs/computer&quot;</span>    <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;spec := computer.Spec &#123;            Maker: <span class="hljs-string">&quot;apple&quot;</span>,            Price: <span class="hljs-number">50000</span>,            model: <span class="hljs-string">&quot;Mac Mini&quot;</span>,        &#125;fmt.Println(<span class="hljs-string">&quot;Maker:&quot;</span>, spec.Maker)    fmt.Println(<span class="hljs-string">&quot;Price:&quot;</span>, spec.Price)&#125;</code></pre></div><p>在上面的程序中，第12行我们尝试访问未导出的字段 <code>model</code>。运行此程序将导致编译错误。</p><div class="code-wrapper"><pre><code class="hljs fallback"># structs./main.go:12:13: unknown field &#x27;model&#x27; in struct literal of type computer.Spec</code></pre></div><p>由于 <code>model</code> 字段是未导出的，因此无法从其他包中访问。</p><h3 id="结构体的相等性"><a href="#结构体的相等性" class="headerlink" title="结构体的相等性"></a>结构体的相等性</h3><p><strong>结构体是值类型，只有当其每个字段都是可比较的时，结构体才是可比较的。</strong> 如果两个结构体变量的对应字段相等，则认为这两个结构体变量是相等的。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> name <span class="hljs-keyword">struct</span> &#123;firstName <span class="hljs-type">string</span>lastName  <span class="hljs-type">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;name1 := name&#123;firstName: <span class="hljs-string">&quot;Steve&quot;</span>,lastName:  <span class="hljs-string">&quot;Jobs&quot;</span>,&#125;name2 := name&#123;firstName: <span class="hljs-string">&quot;Steve&quot;</span>,lastName:  <span class="hljs-string">&quot;Jobs&quot;</span>,&#125;<span class="hljs-keyword">if</span> name1 == name2 &#123;fmt.Println(<span class="hljs-string">&quot;name1 and name2 are equal&quot;</span>)&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(<span class="hljs-string">&quot;name1 and name2 are not equal&quot;</span>)&#125;name3 := name&#123;firstName: <span class="hljs-string">&quot;Steve&quot;</span>,lastName:  <span class="hljs-string">&quot;Jobs&quot;</span>,&#125;name4 := name&#123;firstName: <span class="hljs-string">&quot;Steve&quot;</span>,&#125;<span class="hljs-keyword">if</span> name3 == name4 &#123;fmt.Println(<span class="hljs-string">&quot;name3 and name4 are equal&quot;</span>)&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(<span class="hljs-string">&quot;name3 and name4 are not equal&quot;</span>)&#125;&#125;</code></pre></div><p><a href="https://play.golang.org/p/ntDT8ZuOVK8">Run in playground</a></p><p>在上面的程序中，<code>name</code> 结构体类型包含两个 <code>string</code> 字段。由于字符串是可比较的，因此可以比较两个 <code>name</code> 类型的结构体变量。</p><p>在上面的程序中，<code>name1</code> 和 <code>name2</code> 是相等的，而 <code>name3</code> 和 <code>name4</code> 是不相等的。该程序的输出为：</p><div class="code-wrapper"><pre><code class="hljs fallback">name1 and name2 are equalname3 and name4 are not equal</code></pre></div><p><strong>结构体变量在其包含不可比较的字段时不可比较</strong>（感谢 <a href="https://www.reddit.com/r/golang/comments/6cht1j/a_complete_guide_to_structs_in_go/dhvf7hd/">alasijia</a> 在 Reddit 上指出这一点）。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> image <span class="hljs-keyword">struct</span> &#123;data <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;image1 := image&#123;data: <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>: <span class="hljs-number">155</span>,&#125;&#125;image2 := image&#123;data: <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>: <span class="hljs-number">155</span>,&#125;&#125;<span class="hljs-keyword">if</span> image1 == image2 &#123;fmt.Println(<span class="hljs-string">&quot;image1 and image2 are equal&quot;</span>)&#125;&#125;</code></pre></div><p><a href="https://play.golang.org/p/NUfoyGdOgu4">Run in playground</a></p><p>在上面的程序中，<code>image</code> 结构体类型包含一个字段 <code>data</code>，它是 <code>map</code> 类型。由于 <a href="https://golangbot.com/maps/">maps</a> 是不可比较的，因此 <code>image1</code> 和 <code>image2</code> 不能进行比较。如果运行此程序，将会遇到编译错误。</p><div class="code-wrapper"><pre><code class="hljs fallback">./prog.go:20:12: invalid operation: image1 == image2 (struct containing map[int]int cannot be compared)</code></pre></div><p><strong>下一篇教程 - <a href="../%E3%80%90GolangBot%E3%80%9117-%E6%96%B9%E6%B3%95/">方法</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GolangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】15-指针</title>
    <link href="/%E3%80%90GolangBot%E3%80%9115-%E6%8C%87%E9%92%88/"/>
    <url>/%E3%80%90GolangBot%E3%80%9115-%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到<a href="../golangbot/">Golang系列教程</a>的第15篇。<br>在本教程中，我们将学习Go中的指针，我们还将了解Go指针与其他语言（如C和C++）中的指针有何不同。<br>本教程包含以下部分：</p><ul><li>什么是指针？</li><li>声明指针</li><li>指针的零值</li><li>使用<code>new</code>函数创建指针</li><li>解引用指针</li><li>将指针传递给函数</li><li>从函数返回指针</li><li>不要将数组作为参数传递给函数。使用切片代替。</li><li>Go不支持指针运算</li></ul><h3 id="什么是指针？"><a href="#什么是指针？" class="headerlink" title="什么是指针？"></a>什么是指针？</h3><p>指针是一个变量，它存储了另一个变量的内存地址。</p><p><img src="https://golangbot.com/content/images/2017/05/pointer-explained.png" alt="Pointers in Go"></p><p>在上面的插图中，变量<code>b</code>的值为<code>156</code>，存储在内存地址<code>0x1040a124</code>。变量<code>a</code>持有<code>b</code>的地址。现在<code>a</code>指向<code>b</code>。现在<code>a</code>被称为指向<code>b</code>。</p><h3 id="声明指针"><a href="#声明指针" class="headerlink" title="声明指针"></a>声明指针</h3><p><strong>T</strong> 是指针变量的类型，它指向一个值为类型<strong>T</strong>的变量。<br>让我们写一个程序来声明一个指针。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;b := <span class="hljs-number">255</span><span class="hljs-keyword">var</span> a *<span class="hljs-type">int</span> = &amp;b    fmt.Printf(<span class="hljs-string">&quot;Type of a is %T\n&quot;</span>, a)fmt.Println(<span class="hljs-string">&quot;address of b is&quot;</span>, a)&#125;</code></pre></div><p><a href="https://play.golang.org/p/A4vmlgxAy8">Run in playground</a></p><p><strong>&amp;</strong> 运算符用于获取变量的地址。在上面程序的第9行中，我们将<code>b</code>的地址分配给<code>a</code>，其类型为<code>*int</code>。现在<code>a</code>被称为指向<code>b</code>。当我们打印<code>a</code>的值时，将打印<code>b</code>的地址。此程序输出</p><div class="code-wrapper"><pre><code class="hljs fallback">Type of a is *intaddress of b is 0x1040a124</code></pre></div><p>因为b的地址可能在内存中的任何位置，因此它的地址可能会有所不同。</p><h3 id="指针的零值"><a href="#指针的零值" class="headerlink" title="指针的零值"></a>指针的零值</h3><p>指针的零值是<code>nil</code>。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := <span class="hljs-number">25</span><span class="hljs-keyword">var</span> b *<span class="hljs-type">int</span><span class="hljs-keyword">if</span> b == <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;b is&quot;</span>, b)b = &amp;afmt.Println(<span class="hljs-string">&quot;b after initialization is&quot;</span>, b)&#125;&#125;</code></pre></div><p><a href="https://play.golang.org/p/yAeGhzgQE1">Run in playground</a><br>b在上面的程序中被初始化为nil，然后它被赋值给了a的地址。此程序输出</p><div class="code-wrapper"><pre><code class="hljs fallback">b is &lt;nil&gt;b after initialisation is 0x1040a124</code></pre></div><h3 id="使用new函数创建指针"><a href="#使用new函数创建指针" class="headerlink" title="使用new函数创建指针"></a>使用new函数创建指针</h3><p>Go也提供了一个方便的函数<code>new</code>来创建指针。<code>new</code>函数接受一个类型作为参数，并返回一个指向新分配的零值的类型的指针。<br>下面的例子将会让你更好地理解指针。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;size := <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>)fmt.Printf(<span class="hljs-string">&quot;Size value is %d, type is %T, address is %v\n&quot;</span>, *size, size, size)*size = <span class="hljs-number">85</span>fmt.Println(<span class="hljs-string">&quot;New size value is&quot;</span>, *size)&#125;</code></pre></div><p><a href="https://play.golang.org/p/BNkfB3RZCOY">Run in playground</a></p><p>在上面的程序中，在第8行，我们使用<code>new</code>函数创建一个类型为<code>int</code>的指针。这个函数将返回一个指向新分配的零值的类型为<code>int</code>的指针。<code>int</code>的零值为<code>0</code>。因此，<code>size</code>将为类型<code>*int</code>，并指向<code>0</code>，即<code>*size</code>将为<code>0</code>。<br>这个程序将打印</p><div class="code-wrapper"><pre><code class="hljs fallback">Size value is 0, type is *int, address is 0x414020New size value is 85</code></pre></div><h3 id="解引用指针"><a href="#解引用指针" class="headerlink" title="解引用指针"></a>解引用指针</h3><p>解引用指针意味着访问指针指向的变量的值。<code>*a</code>是解引用的语法。<br>让我们写一个程序来理解指针的解引用。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (      <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;      b := <span class="hljs-number">255</span>    a := &amp;b    fmt.Println(<span class="hljs-string">&quot;address of b is&quot;</span>, a)    fmt.Println(<span class="hljs-string">&quot;value of b is&quot;</span>, *a)&#125;</code></pre></div><p><a href="https://play.golang.org/p/m5pNbgFwbM">Run in playground</a></p><p>在上面程序的第10行，我们解引用指针<code>a</code>并打印它的值。正如预期的那样，它打印<code>b</code>的值。此程序的输出为</p><div class="code-wrapper"><pre><code class="hljs fallback">address of b is 0x1040a124value of b is 255</code></pre></div><p>让我们再写一个程序来理解指针的解引用，这次我们使用指针修改<code>b</code>的值。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;b := <span class="hljs-number">255</span>a := &amp;bfmt.Println(<span class="hljs-string">&quot;address of b is&quot;</span>, a)fmt.Println(<span class="hljs-string">&quot;value of b is&quot;</span>, *a)*a++fmt.Println(<span class="hljs-string">&quot;new value of b is&quot;</span>, b)&#125;</code></pre></div><p><a href="https://play.golang.org/p/cdmvlpBNmb">Run in playground</a></p><p>在上面程序的第 12 行，我们将 a 指向的值加 1，这会改变 b 的值，因为 a 指向的是 b。因此，b 的值变为 256。程序的输出是：</p><div class="code-wrapper"><pre><code class="hljs fallback">address of b is 0x1040a124value of b is 255new value of b is 256</code></pre></div><h3 id="将指针传递给函数"><a href="#将指针传递给函数" class="headerlink" title="将指针传递给函数"></a>将指针传递给函数</h3><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">change</span><span class="hljs-params">(val *<span class="hljs-type">int</span>)</span></span> &#123;*val = <span class="hljs-number">55</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := <span class="hljs-number">58</span>fmt.Println(<span class="hljs-string">&quot;value of a before function call is&quot;</span>,a)b := &amp;achange(b)fmt.Println(<span class="hljs-string">&quot;value of a after function call is&quot;</span>, a)&#125;</code></pre></div><p><a href="https://play.golang.org/p/3n2nHRJJqn">Run in playground</a></p><p>在上面程序的第 14 行，我们将保存了 a 地址的指针变量 b 传递给函数 change。在 change 函数内部，第 8 行通过解引用更改了 a 的值。程序的输出是：</p><div class="code-wrapper"><pre><code class="hljs fallback">value of a before function call is 58value of a after function call is 55</code></pre></div><h3 id="从函数返回指针"><a href="#从函数返回指针" class="headerlink" title="从函数返回指针"></a>从函数返回指针</h3><p>函数返回局部变量的指针是完全合法的。Go 编译器足够智能，会将该变量分配到堆上。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> *<span class="hljs-type">int</span> &#123;i := <span class="hljs-number">5</span><span class="hljs-keyword">return</span> &amp;i&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;d := hello()fmt.Println(<span class="hljs-string">&quot;Value of d&quot;</span>, *d)&#125;</code></pre></div><p><a href="https://play.golang.org/p/I6r-fRx2qML">Run in playground</a></p><p>在上面程序的第 9 行，我们从函数 <code>hello</code> 返回局部变量 <code>i</code> 的地址。<strong>在 C 和 C++ 等编程语言中，这段代码的行为是未定义的，因为变量 <code>i</code> 在函数 <code>hello</code> 返回后会超出作用域。但在 Go 中，编译器会进行逃逸分析，并将 <code>i</code> 分配到堆上，因为其地址超出了局部作用域。</strong> 因此，这段程序可以正常运行，并将打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">Value of d 5</code></pre></div><h3 id="不要将数组作为参数传递给函数。使用切片代替。"><a href="#不要将数组作为参数传递给函数。使用切片代替。" class="headerlink" title="不要将数组作为参数传递给函数。使用切片代替。"></a>不要将数组作为参数传递给函数。使用切片代替。</h3><p>假设我们想在函数内部修改一个数组，并希望在函数内部对该数组所做的更改对调用者可见。一种实现方法是将数组的指针作为参数传递给函数。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (      <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">modify</span><span class="hljs-params">(arr *[3]<span class="hljs-type">int</span>)</span></span> &#123;(*arr)[<span class="hljs-number">0</span>] = <span class="hljs-number">90</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;      a := [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">89</span>, <span class="hljs-number">90</span>, <span class="hljs-number">91</span>&#125;    modify(&amp;a)    fmt.Println(a)&#125;</code></pre></div><p><a href="https://play.golang.org/p/lOIznCbcvs">Run in playground</a></p><p>在上面程序的第 13 行，我们将数组 <code>a</code> 的地址传递给了 <code>modify</code> 函数。在 <code>modify</code> 函数的第 8 行，我们通过解引用 <code>arr</code> 并将 <code>90</code> 分配给数组的第一个元素。该程序输出 <code>[90 90 91]</code>。</p><p><strong><code>a[x]</code> 是 <code>(*a)[x]</code> 的简写。因此，上述程序中的 <code>(*arr)[0]</code> 可以替换为 <code>arr[0]</code>。</strong> 让我们使用这种简写语法重写上述程序。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (      <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">modify</span><span class="hljs-params">(arr *[3]<span class="hljs-type">int</span>)</span></span> &#123;arr[<span class="hljs-number">0</span>] = <span class="hljs-number">90</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;      a := [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">89</span>, <span class="hljs-number">90</span>, <span class="hljs-number">91</span>&#125;    modify(&amp;a)    fmt.Println(a)&#125;</code></pre></div><p><a href="https://play.golang.org/p/k7YR0EUE1G">Run in playground</a></p><p>该程序同样输出 <code>[90 90 91]</code>。</p><p><strong>尽管通过将数组的指针作为参数传递给函数并修改它的方式可以实现目标，但这并不是 Go 中实现此功能的惯用方式。我们有 <a href="../%E3%80%90GolangBot%E3%80%9111-%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/">切片</a> 来实现这一点。</strong></p><p>让我们使用 <a href="../%E3%80%90GolangBot%E3%80%9111-%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/">切片</a> 重写同样的程序。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">modify</span><span class="hljs-params">(sls []<span class="hljs-type">int</span>)</span></span> &#123;sls[<span class="hljs-number">0</span>] = <span class="hljs-number">90</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">89</span>, <span class="hljs-number">90</span>, <span class="hljs-number">91</span>&#125;modify(a[:])fmt.Println(a)&#125;</code></pre></div><p><a href="https://play.golang.org/p/rRvbvuI67W">Run in playground</a></p><p>在上面程序的第 13 行，我们将切片传递给 <code>modify</code> 函数。在 <code>modify</code> 函数内部，将切片的第一个元素修改为 <code>90</code>。该程序同样输出 <code>[90 90 91]</code>。<br> <strong>所以，忘掉传递数组指针的方法，直接使用切片吧 :)。这种代码更简洁，并且符合 Go 的惯用写法 :)。</strong></p><h3 id="Go-不支持指针运算"><a href="#Go-不支持指针运算" class="headerlink" title="Go 不支持指针运算"></a>Go 不支持指针运算</h3><p>Go 不支持像 C 和 C++ 等其他语言中存在的指针运算功能。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;b := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">109</span>, <span class="hljs-number">110</span>, <span class="hljs-number">111</span>&#125;p := &amp;bp++&#125;</code></pre></div><p><a href="https://play.golang.org/p/WRaj4pkqRD">Run in playground</a></p><p>上述程序会抛出编译错误：<br><strong>main.go:6: invalid operation: p++ (non-numeric type *[3]int)</strong>  </p><p>我已经在 <a href="https://github.com/golangbot/pointers">GitHub</a> 上创建了一个完整的程序，涵盖了我们讨论的所有内容。  </p><p><strong>下一篇教程 - <a href="../%E3%80%90GolangBot%E3%80%9116-%E7%BB%93%E6%9E%84%E4%BD%93/">结构体</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GolangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】14-Strings</title>
    <link href="/%E3%80%90GolangBot%E3%80%9114-Strings/"/>
    <url>/%E3%80%90GolangBot%E3%80%9114-Strings/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到<a href="../golangbot/">Golang系列教程</a>第14篇。</p><p>字符串在 Go 中值得特别提及，因为与其他语言相比，它们的实现有所不同。</p><h3 id="什么是字符串？"><a href="#什么是字符串？" class="headerlink" title="什么是字符串？"></a>什么是字符串？</h3><p><strong>在 Go 中，字符串是字节的<a href="../%E3%80%90GolangBot%E3%80%9111-%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/">切片</a>。可以通过将一组字符用双引号 <code>&quot;&quot;</code> 包括起来来创建字符串。</strong></p><p>让我们通过一个简单的示例来创建一个 <code>string</code> 并打印它。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;name := <span class="hljs-string">&quot;Hello World&quot;</span>fmt.Println(name)&#125;</code></pre></div><p><a href="https://play.golang.org/p/o9OVDgEMU0">Run in playground</a></p><p>上述程序将打印 <code>Hello World</code>。</p><p>Go 中的字符串是<a href="https://naveenr.net/unicode-character-set-and-utf-8-utf-16-utf-32-encoding/">符合 Unicode 标准</a>的，并且采用<a href="https://naveenr.net/unicode-character-set-and-utf-8-utf-16-utf-32-encoding/">UTF-8 编码</a>。</p><h3 id="访问字符串的各个字节"><a href="#访问字符串的各个字节" class="headerlink" title="访问字符串的各个字节"></a>访问字符串的各个字节</h3><p>由于字符串是字节的切片，因此可以访问字符串的每个字节。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printBytes</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;Bytes: &quot;</span>)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;fmt.Printf(<span class="hljs-string">&quot;%x &quot;</span>, s[i])&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;name := <span class="hljs-string">&quot;Hello World&quot;</span>fmt.Printf(<span class="hljs-string">&quot;String: %s\n&quot;</span>, name)printBytes(name)&#125;</code></pre></div><p><a href="https://play.golang.org/p/B3KgBBQhiN9">Run in playground</a></p><p><strong>%s 是用于打印字符串的格式说明符。</strong> 在上述程序的第 16 行，打印了输入的字符串。在第 9 行，<strong><code>len(s)</code> 返回字符串中的字节数</strong>，并使用<a href="../%E3%80%90GolangBot%E3%80%919-%E5%BE%AA%E7%8E%AF/">for 循环</a>以十六进制格式打印这些字节。**%x 是表示十六进制的格式说明符。**上述程序的输出为：</p><div class="code-wrapper"><pre><code class="hljs fallback">String: Hello WorldBytes: 48 65 6c 6c 6f 20 57 6f 72 6c 64</code></pre></div><p>这些是 <code>Hello World</code> 的 [Unicode UTF-8 编码](<a href="https://mothereff.in/utf-8#Hello">https://mothereff.in/utf-8#Hello</a> World)值。要更好地理解字符串，需要对 Unicode 和 UTF-8 有基本的了解。推荐阅读 <a href="https://naveenr.net/unicode-character-set-and-utf-8-utf-16-utf-32-encoding/">https://naveenr.net/unicode-character-set-and-utf-8-utf-16-utf-32-encoding/</a> 以了解更多关于 Unicode 和 UTF-8 的内容。</p><h3 id="访问字符串中的单个字符"><a href="#访问字符串中的单个字符" class="headerlink" title="访问字符串中的单个字符"></a>访问字符串中的单个字符</h3><p>让我们稍微修改一下上面的程序，以打印字符串的字符。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printBytes</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;Bytes: &quot;</span>)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;fmt.Printf(<span class="hljs-string">&quot;%x &quot;</span>, s[i])&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printChars</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;Characters: &quot;</span>)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;fmt.Printf(<span class="hljs-string">&quot;%c &quot;</span>, s[i])&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;name := <span class="hljs-string">&quot;Hello World&quot;</span>fmt.Printf(<span class="hljs-string">&quot;String: %s\n&quot;</span>, name)printChars(name)fmt.Printf(<span class="hljs-string">&quot;\n&quot;</span>)printBytes(name)&#125;</code></pre></div><p><a href="https://play.golang.org/p/ZkXmyVNsqv7">Run in playground</a></p><p>在上面程序的第 17 行，<code>%c</code> 格式说明符用于在 <code>printChars</code> 方法中打印字符串的字符。程序输出如下：</p><div class="code-wrapper"><pre><code class="hljs fallback">String: Hello WorldCharacters: H e l l o   W o r l d Bytes: 48 65 6c 6c 6f 20 57 6f 72 6c 64</code></pre></div><p>尽管上面的程序看起来是访问字符串中各个字符的合法方式，但实际上存在一个严重的漏洞。我们来看看这个漏洞是什么。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printBytes</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;Bytes: &quot;</span>)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;fmt.Printf(<span class="hljs-string">&quot;%x &quot;</span>, s[i])&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printChars</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;Characters: &quot;</span>)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;fmt.Printf(<span class="hljs-string">&quot;%c &quot;</span>, s[i])&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;name := <span class="hljs-string">&quot;Hello World&quot;</span>fmt.Printf(<span class="hljs-string">&quot;String: %s\n&quot;</span>, name)printChars(name)fmt.Printf(<span class="hljs-string">&quot;\n&quot;</span>)printBytes(name)fmt.Printf(<span class="hljs-string">&quot;\n\n&quot;</span>)name = <span class="hljs-string">&quot;Señor&quot;</span>fmt.Printf(<span class="hljs-string">&quot;String: %s\n&quot;</span>, name)printChars(name)fmt.Printf(<span class="hljs-string">&quot;\n&quot;</span>)printBytes(name)&#125;</code></pre></div><p><a href="https://play.golang.org/p/2hyVf8l9fiO">Run in playground</a></p><p>上面的程序的输出是</p><div class="code-wrapper"><pre><code class="hljs fallback">String: Hello WorldCharacters: H e l l o   W o r l d Bytes: 48 65 6c 6c 6f 20 57 6f 72 6c 64 String: SeñorCharacters: S e Ã ± o r Bytes: 53 65 c3 b1 6f 72</code></pre></div><p>在上面的程序第30行，我们尝试打印<strong>Señor</strong>的字符，结果输出为<strong>S e Ã ± o r</strong>，这是错误的。为什么<code>Señor</code>会出错，而<code>Hello World</code>却能正常工作呢？原因是<code>ñ</code>的Unicode代码点是<code>U+00F1</code>，其<a href="https://mothereff.in/utf-8#%C3%B1">UTF-8编码</a>占用2个字节<code>c3</code>和<code>b1</code>。我们在尝试打印字符时，假设每个代码点仅占用一个字节，这是错误的。<strong>在UTF-8编码中，一个代码点可能占用多个字节</strong>。那么我们该如何解决这个问题呢？这就是<strong>rune</strong>的作用所在。</p><h3 id="Rune"><a href="#Rune" class="headerlink" title="Rune"></a>Rune</h3><p>在Go中，rune是一个内建类型，它是int32的别名。Rune表示Go中的Unicode代码点。无论代码点占用多少字节，都可以用rune表示。让我们修改上面的程序，使用rune来打印字符。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printBytes</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;Bytes: &quot;</span>)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;fmt.Printf(<span class="hljs-string">&quot;%x &quot;</span>, s[i])&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printChars</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;Characters: &quot;</span>)runes := []<span class="hljs-type">rune</span>(s)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(runes); i++ &#123;fmt.Printf(<span class="hljs-string">&quot;%c &quot;</span>, runes[i])&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;name := <span class="hljs-string">&quot;Hello World&quot;</span>fmt.Printf(<span class="hljs-string">&quot;String: %s\n&quot;</span>, name)printChars(name)fmt.Printf(<span class="hljs-string">&quot;\n&quot;</span>)printBytes(name)fmt.Printf(<span class="hljs-string">&quot;\n\n&quot;</span>)name = <span class="hljs-string">&quot;Señor&quot;</span>fmt.Printf(<span class="hljs-string">&quot;String: %s\n&quot;</span>, name)printChars(name)fmt.Printf(<span class="hljs-string">&quot;\n&quot;</span>)printBytes(name)&#125;</code></pre></div><p><a href="https://play.golang.org/p/n8rsfagm2SJ">Run in playground</a></p><p>在上面的程序第16行，字符串被转换为<a href="../%E3%80%90GolangBot%E3%80%9111-%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/">rune切片</a>。然后，我们遍历该切片并显示字符。该程序输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">String: Hello WorldCharacters: H e l l o   W o r l d Bytes: 48 65 6c 6c 6f 20 57 6f 72 6c 64 String: SeñorCharacters: S e ñ o r Bytes: 53 65 c3 b1 6f 72</code></pre></div><p>上面的输出是完美的。正是我们想要的 😀。</p><h3 id="使用-for-range-循环访问单个-rune"><a href="#使用-for-range-循环访问单个-rune" class="headerlink" title="使用 for range 循环访问单个 rune"></a>使用 for range 循环访问单个 rune</h3><p>上面的程序是迭代字符串中单个 rune 的完美方式。但是 Go 提供了一个更简单的方法，使用 <strong>for range</strong> 循环。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (      <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">charsAndBytePosition</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> &#123;<span class="hljs-keyword">for</span> index, <span class="hljs-type">rune</span> := <span class="hljs-keyword">range</span> s &#123;fmt.Printf(<span class="hljs-string">&quot;%c starts at byte %d\n&quot;</span>, <span class="hljs-type">rune</span>, index)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;      name := <span class="hljs-string">&quot;Señor&quot;</span>    charsAndBytePosition(name)&#125;</code></pre></div><p><a href="https://play.golang.org/p/0ldNBeffjYI">Run in playground</a></p><p>在上面的程序的第8行，使用 <code>for range</code> 循环迭代字符串。循环返回了每个 rune 开始的位置以及该 rune 本身。该程序的输出为：</p><div class="code-wrapper"><pre><code class="hljs fallback">S starts at byte 0e starts at byte 1ñ starts at byte 2o starts at byte 4r starts at byte 5</code></pre></div><p>从上面的输出可以看出，<code>ñ</code> 占用了 2 个字节，因为下一个字符 <code>o</code> 从字节 4 开始，而不是从字节 3 开始 😀。</p><h3 id="从字节切片创建字符串"><a href="#从字节切片创建字符串" class="headerlink" title="从字节切片创建字符串"></a>从字节切片创建字符串</h3><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;byteSlice := []<span class="hljs-type">byte</span>&#123;<span class="hljs-number">0x43</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x66</span>, <span class="hljs-number">0xC3</span>, <span class="hljs-number">0xA9</span>&#125;str := <span class="hljs-type">string</span>(byteSlice)fmt.Println(str)&#125;</code></pre></div><p><a href="https://play.golang.org/p/Vr9pf8X8xO">Run in playground</a></p><p><em>byteSlice</em> 在上面程序的第8行包含了字符串 <code>Café</code> 的 <a href="https://mothereff.in/utf-8#Caf%C3%A9">UTF-8 编码</a> 十六进制字节。程序输出</p><div class="code-wrapper"><pre><code class="hljs fallback">Café</code></pre></div><p>如果我们有十六进制值的十进制等价物，上面的程序还会有效吗？让我们来检查一下。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;byteSlice := []<span class="hljs-type">byte</span>&#123;<span class="hljs-number">67</span>, <span class="hljs-number">97</span>, <span class="hljs-number">102</span>, <span class="hljs-number">195</span>, <span class="hljs-number">169</span>&#125;<span class="hljs-comment">//decimal equivalent of &#123;&#x27;\x43&#x27;, &#x27;\x61&#x27;, &#x27;\x66&#x27;, &#x27;\xC3&#x27;, &#x27;\xA9&#x27;&#125;</span>str := <span class="hljs-type">string</span>(byteSlice)fmt.Println(str)&#125;</code></pre></div><p><a href="https://play.golang.org/p/jgsRowW6XN">Run in playground</a></p><p>十进制值也可以正常工作，上面的程序将打印 <code>Café</code>。</p><h3 id="从-rune-切片创建字符串"><a href="#从-rune-切片创建字符串" class="headerlink" title="从 rune 切片创建字符串"></a>从 rune 切片创建字符串</h3><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;runeSlice := []<span class="hljs-type">rune</span>&#123;<span class="hljs-number">0x0053</span>, <span class="hljs-number">0x0065</span>, <span class="hljs-number">0x00f1</span>, <span class="hljs-number">0x006f</span>, <span class="hljs-number">0x0072</span>&#125;str := <span class="hljs-type">string</span>(runeSlice)fmt.Println(str)&#125;</code></pre></div><p><a href="https://play.golang.org/p/m8wTMOpYJP">Run in playground</a></p><p>在上面的程序中，<code>runeSlice</code> 包含字符串 <code>Señor</code> 的 Unicode 代码点的十六进制表示。程序的输出是：</p><div class="code-wrapper"><pre><code class="hljs fallback">Señor</code></pre></div><h3 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h3><p>可以使用 <a href="https://golang.org/pkg/unicode/utf8/#RuneCountInString">utf8 包</a> 的 <code>RuneCountInString(s string) (n int)</code> 函数来获取字符串的长度。该方法接受一个字符串作为参数，并返回其中的 rune 数量。</p><p>如前所述，<code>len(s)</code> 用于获取字符串的字节数，而不是字符串的长度。正如我们之前讨论的那样，一些 Unicode 字符的代码点占用了超过 1 个字节。使用 <code>len</code> 来计算这些字符串的长度会返回不正确的字符串长度。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;unicode/utf8&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;word1 := <span class="hljs-string">&quot;Señor&quot;</span>fmt.Printf(<span class="hljs-string">&quot;String: %s\n&quot;</span>, word1)fmt.Printf(<span class="hljs-string">&quot;Length: %d\n&quot;</span>, utf8.RuneCountInString(word1))fmt.Printf(<span class="hljs-string">&quot;Number of bytes: %d\n&quot;</span>, <span class="hljs-built_in">len</span>(word1))fmt.Printf(<span class="hljs-string">&quot;\n&quot;</span>)word2 := <span class="hljs-string">&quot;Pets&quot;</span>fmt.Printf(<span class="hljs-string">&quot;String: %s\n&quot;</span>, word2)fmt.Printf(<span class="hljs-string">&quot;Length: %d\n&quot;</span>, utf8.RuneCountInString(word2))fmt.Printf(<span class="hljs-string">&quot;Number of bytes: %d\n&quot;</span>, <span class="hljs-built_in">len</span>(word2))&#125;</code></pre></div><p><a href="https://play.golang.org/p/KBQg1qagnfC">Run in playground</a></p><p>上面的程序将会输出</p><div class="code-wrapper"><pre><code class="hljs fallback">String: SeñorLength: 5Number of bytes: 6String: PetsLength: 4Number of bytes: 4</code></pre></div><p>上述输出确认了 <code>len(s)</code> 和 <code>RuneCountInString(s)</code> 返回的值不同 😀。</p><h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><p>使用 <code>==</code> 运算符可以比较两个字符串是否相等。如果两个字符串相等，则结果为 <code>true</code>，否则为 <code>false</code>。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">compareStrings</span><span class="hljs-params">(str1 <span class="hljs-type">string</span>, str2 <span class="hljs-type">string</span>)</span></span> &#123;<span class="hljs-keyword">if</span> str1 == str2 &#123;fmt.Printf(<span class="hljs-string">&quot;%s and %s are equal\n&quot;</span>, str1, str2)<span class="hljs-keyword">return</span>&#125;fmt.Printf(<span class="hljs-string">&quot;%s and %s are not equal\n&quot;</span>, str1, str2)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;string1 := <span class="hljs-string">&quot;Go&quot;</span>string2 := <span class="hljs-string">&quot;Go&quot;</span>compareStrings(string1, string2)string3 := <span class="hljs-string">&quot;hello&quot;</span>string4 := <span class="hljs-string">&quot;world&quot;</span>compareStrings(string3, string4)&#125;</code></pre></div><p><a href="https://play.golang.org/p/JEAMexbvJ1s">Run in playground</a></p><p>在上面的 <code>compareStrings</code> 函数中，第 8 行使用 <code>==</code> 运算符比较两个字符串 <code>str1</code> 和 <code>str2</code> 是否相等。如果它们相等，则打印相应的消息，并且 <a href="../%E3%80%90GolangBot%E3%80%916-%E5%87%BD%E6%95%B0/">函数</a> 返回。</p><p>上述程序打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">Go and Go are equalhello and world are not equal</code></pre></div><h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>在 Go 中，有多种方法可以进行字符串拼接。我们来看其中的几种方法。</p><p>最简单的字符串拼接方式是使用 <code>+</code> 运算符。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;string1 := <span class="hljs-string">&quot;Go&quot;</span>string2 := <span class="hljs-string">&quot;is awesome&quot;</span>result := string1 + <span class="hljs-string">&quot; &quot;</span> + string2fmt.Println(result)&#125;</code></pre></div><p><a href="https://play.golang.org/p/RCL8SGkrBe9">Run in playground</a></p><p>在上面的程序中，程序的第10行将 <code>string1</code> 和 <code>string2</code> 用一个空格连接起来。该程序输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">Go is awesome</code></pre></div><p>第二种连接字符串的方法是使用 <code>fmt</code> 包中的 <a href="https://golang.org/pkg/fmt/#Sprintf">Sprintf</a> 函数。</p><p><code>Sprintf</code> 函数根据输入的格式说明符格式化字符串，并返回结果字符串。让我们使用 <code>Sprintf</code> 函数重写上面的程序。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;string1 := <span class="hljs-string">&quot;Go&quot;</span>string2 := <span class="hljs-string">&quot;is awesome&quot;</span>result := fmt.Sprintf(<span class="hljs-string">&quot;%s %s&quot;</span>, string1, string2)fmt.Println(result)&#125;</code></pre></div><p><a href="https://play.golang.org/p/AgqI29aQQDu">Run in playground</a></p><p>在上面的程序中，第10行的 <code>%s %s</code> 是 <code>Sprintf</code> 的格式说明符输入。这个格式说明符接收两个字符串作为输入，并且它们之间有一个空格。这样就会将两个字符串连接起来，中间有一个空格。结果字符串会被存储在 <code>result</code> 变量中。该程序也会打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">Go is awesome</code></pre></div><h3 id="字符串是不可变的"><a href="#字符串是不可变的" class="headerlink" title="字符串是不可变的"></a>字符串是不可变的</h3><p>在 Go 中，字符串是不可变的。一旦字符串被创建，就无法修改它。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (      <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mutate</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span><span class="hljs-type">string</span> &#123;s[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;a&#x27;</span><span class="hljs-comment">//any valid unicode character within single quote is a rune </span><span class="hljs-keyword">return</span> s&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;      h := <span class="hljs-string">&quot;hello&quot;</span>    fmt.Println(mutate(h))&#125;</code></pre></div><p><a href="https://play.golang.org/p/bv4SlSd_hp">Run in playground</a></p><p>在上面的程序的第 8 行，我们试图将字符串的第一个字符更改为 <code>&#39;a&#39;</code>。在单引号内的任何有效 Unicode 字符都是一个 rune。我们尝试将 rune <code>a</code> 赋值给切片的第零个位置。这是不允许的，因为字符串是不可变的，因此程序无法编译并报错 <strong>.&#x2F;prog.go:8:7: cannot assign to s[0]</strong>。</p><p>为了解决字符串不可变的问题，可以将字符串转换为 <a href="../%E3%80%90GolangBot%E3%80%9111-%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/">rune 切片</a>，然后在该切片上进行所需的修改，最后将其转换回一个新的字符串。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (      <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mutate</span><span class="hljs-params">(s []<span class="hljs-type">rune</span>)</span></span> <span class="hljs-type">string</span> &#123;s[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(s)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;      h := <span class="hljs-string">&quot;hello&quot;</span>    fmt.Println(mutate([]<span class="hljs-type">rune</span>(h)))&#125;</code></pre></div><p><a href="https://play.golang.org/p/GL1cm17IP1">Run in playground</a></p><p>在上面的程序的第 7 行，<code>mutate</code> 函数接受一个 rune 切片作为参数。然后，它将切片的第一个元素更改为 <code>&#39;a&#39;</code>，并将 rune 切片转换回字符串并返回。在程序的第 13 行调用了这个方法。<code>h</code> 被转换为 rune 切片并传递给 <code>mutate</code>。这个程序的输出是 <code>aello</code>。</p><p>我已经将我们讨论过的内容整合到一个 GitHub 程序中，你可以 <a href="https://github.com/golangbot/stringsexplained">点击这里下载</a>。</p><p>这就是关于字符串的所有内容。祝你有个愉快的一天！</p><p><strong>下一篇教程 - <a href="../%E3%80%90GolangBot%E3%80%9115-%E6%8C%87%E9%92%88/">指针</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GolangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】13-Maps</title>
    <link href="/%E3%80%90GolangBot%E3%80%9113-Maps/"/>
    <url>/%E3%80%90GolangBot%E3%80%9113-Maps/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到<a href="../GolangBot/">Golang系列教程</a>的第13篇。</p><h3 id="什么是map？"><a href="#什么是map？" class="headerlink" title="什么是map？"></a>什么是map？</h3><p>Go 中的 map 是一种内建的数据类型，用于存储键值对。一个实际的使用场景是存储货币代码和相应的货币名称。</p><div class="code-wrapper"><pre><code class="hljs fallback">USD - United States DollarEUR - EuroINR - India Rupee</code></pre></div><p>一个 map 非常适合上面的使用场景。货币代码可以作为键，货币名称可以作为值。map 类似于其他语言（如 Python）中的字典。</p><h3 id="如何创建一个-map？"><a href="#如何创建一个-map？" class="headerlink" title="如何创建一个 map？"></a><strong>如何创建一个 map？</strong></h3><p>可以通过将键和值的<a href="../%E3%80%90GolangBot%E3%80%914-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">数据类型</a>传递给 <code>make</code> 函数来创建一个 map。以下是创建新 map 的语法。</p><div class="code-wrapper"><pre><code class="hljs fallback">make(map[type of key]type of value)currencyCode := make(map[string]string)</code></pre></div><p>上面的代码创建了一个名为 currencyCode 的 map，其键和值的类型均为 string。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;currencyCode := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)fmt.Println(currencyCode)&#125;</code></pre></div><p><a href="https://go.dev/play/p/A31zIgnFiW5">Run in Playground</a></p><p>上述程序创建了一个名为 currencyCode 的 map，其键和值的类型均为 string。程序的输出将是：</p><div class="code-wrapper"><pre><code class="hljs fallback">map[]</code></pre></div><p>因为我们没有把任何元素添加进map，所以它是空的。</p><h3 id="向-Map-中添加条目"><a href="#向-Map-中添加条目" class="headerlink" title="向 Map 中添加条目"></a>向 Map 中添加条目</h3><p>向 map 中添加新条目的语法与 <a href="../%E3%80%90GolangBot%E3%80%9111-%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/">数组</a> 的操作类似。下面的程序向 <code>currencyCode</code> map 中添加了一些新的货币代码和对应的货币名称：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;currencyCode := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)currencyCode[<span class="hljs-string">&quot;USD&quot;</span>] = <span class="hljs-string">&quot;US Dollar&quot;</span>currencyCode[<span class="hljs-string">&quot;GBP&quot;</span>] = <span class="hljs-string">&quot;Pound Sterling&quot;</span>currencyCode[<span class="hljs-string">&quot;EUR&quot;</span>] = <span class="hljs-string">&quot;Euro&quot;</span>currencyCode[<span class="hljs-string">&quot;INR&quot;</span>] = <span class="hljs-string">&quot;Indian Rupee&quot;</span>fmt.Println(<span class="hljs-string">&quot;currencyCode map contents:&quot;</span>, currencyCode)&#125;</code></pre></div><p><a href="https://go.dev/play/p/2M4ZVP1QaQ1">Run in playground</a></p><p>我们添加了4个货币代码，分别是 <code>USD</code>、<code>GBP</code>、<code>EUR</code> 和<code>INR</code>，以及它们对应的名称。</p><div class="code-wrapper"><pre><code class="hljs fallback">currencyCode map contents: map[EUR:Euro GBP:Pound Sterling INR:Indian Rupee USD:US Dollar]</code></pre></div><p><strong>正如你可能从上述输出中注意到的，从 map 中检索值的顺序并不保证与添加到 map 中的顺序相同。</strong></p><p>在声明时，也可以直接对 map 进行初始化。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;currencyCode := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span> &#123;<span class="hljs-string">&quot;USD&quot;</span>: <span class="hljs-string">&quot;US Dollar&quot;</span>,<span class="hljs-string">&quot;GBP&quot;</span>: <span class="hljs-string">&quot;Pound Sterling&quot;</span>,<span class="hljs-string">&quot;EUR&quot;</span>: <span class="hljs-string">&quot;Euro&quot;</span>,&#125;currencyCode[<span class="hljs-string">&quot;INR&quot;</span>] = <span class="hljs-string">&quot;Indian Rupee&quot;</span>fmt.Println(<span class="hljs-string">&quot;currencyCode map contents:&quot;</span>, currencyCode)&#125;</code></pre></div><p><a href="https://go.dev/play/p/Rd6QoqZ7udE">Run in playground</a></p><p>上述程序在声明时定义了 <code>currencyCode</code> map，并初始化了 3 个键值对。随后又添加了一个键为 <code>INR</code> 的新元素。程序的输出为：</p><div class="code-wrapper"><pre><code class="hljs fallback">currencyCode map contents: map[EUR:Euro GBP:Pound Sterling INR:Indian Rupee USD:US Dollar]</code></pre></div><p>键的类型并不局限于 <a href="../%E3%80%90GolangBot%E3%80%9114-Strings/">string</a>。所有可以比较的类型（如布尔值、整数、浮点数、复数、字符串等）都可以用作键。甚至用户定义的类型（如 <a href="../%E3%80%90GolangBot%E3%80%9116-%E7%BB%93%E6%9E%84%E4%BD%93/">structs</a>）也可以作为键。</p><p>如果您想了解更多关于可比较类型的信息，请访问 <a href="https://go.dev/ref/spec#Comparison_operators">Go 官方文档</a>。</p><h3 id="nil-map-panics"><a href="#nil-map-panics" class="headerlink" title="nil map panics"></a>nil map panics</h3><p>映射（map）的零值是 nil。如果尝试向一个 nil 映射中添加元素，会触发运行时的 <a href="../%E3%80%90GolangBot%E3%80%9133-Panic%E5%92%8CRecover/">panic</a>。因此，在向映射中添加元素之前，必须先对映射进行初始化。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> currencyCode <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>currencyCode[<span class="hljs-string">&quot;USD&quot;</span>] = <span class="hljs-string">&quot;US Dollar&quot;</span>&#125;</code></pre></div><p><a href="https://go.dev/play/p/UuJ8pmtOp5D">Run in playground</a></p><p>在上面的程序中，<code>currencyCode</code> 是 <code>nil</code>，我们尝试向一个 <code>nil</code> 映射中添加新键值对。程序将会发生 panic，错误信息如下：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-built_in">panic</span>: assignment to entry in <span class="hljs-literal">nil</span> <span class="hljs-keyword">map</span></code></pre></div><h3 id="从映射中检索键的值"><a href="#从映射中检索键的值" class="headerlink" title="从映射中检索键的值"></a>从映射中检索键的值</h3><p>现在我们已经向映射中添加了一些元素，接下来学习如何检索它们。使用 <code>map[key]</code> 语法来检索映射中的元素。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;currencyCode := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;USD&quot;</span>: <span class="hljs-string">&quot;US Dollar&quot;</span>,<span class="hljs-string">&quot;GBP&quot;</span>: <span class="hljs-string">&quot;Pound Sterling&quot;</span>,<span class="hljs-string">&quot;EUR&quot;</span>: <span class="hljs-string">&quot;Euro&quot;</span>,&#125;currency := <span class="hljs-string">&quot;USD&quot;</span>currencyName := currencyCode[currency]fmt.Println(<span class="hljs-string">&quot;Currency name for currency code&quot;</span>, currency, <span class="hljs-string">&quot;is&quot;</span>, currencyName)&#125;</code></pre></div><p><a href="https://go.dev/play/p/5eLMNMwQJbY">Run in playground</a></p><p>上面的程序非常简单。程序检索并打印了货币代码 <code>USD</code> 对应的货币名称。程序的输出是：</p><div class="code-wrapper"><pre><code class="hljs fallback">Currency name for currency code USD is US Dollar</code></pre></div><p>如果尝试访问不存在的元素，map 将返回该元素类型的零值。在 <code>currencyCode</code> map 的例子中，如果我们尝试访问一个不存在的元素，返回的将是该类型的零值，即空字符串 “”。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;currencyCode := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;USD&quot;</span>: <span class="hljs-string">&quot;US Dollar&quot;</span>,<span class="hljs-string">&quot;GBP&quot;</span>: <span class="hljs-string">&quot;Pound Sterling&quot;</span>,<span class="hljs-string">&quot;EUR&quot;</span>: <span class="hljs-string">&quot;Euro&quot;</span>,&#125;fmt.Println(<span class="hljs-string">&quot;Currency name for currency code INR is&quot;</span>, currencyCode[<span class="hljs-string">&quot;INR&quot;</span>])&#125;</code></pre></div><p><a href="https://go.dev/play/p/zikbC-C_DEP">Run in playground</a></p><p>上述程序的输出是</p><div class="code-wrapper"><pre><code class="hljs fallback">Currency name for currency code INR is</code></pre></div><p>在上述程序中，尝试获取 <code>INR</code> 的货币名称时，返回的是空字符串。这表明，当尝试检索一个不存在的键时，<strong>map 不会抛出运行时错误</strong>。</p><h3 id="检查key是否存在"><a href="#检查key是否存在" class="headerlink" title="检查key是否存在"></a>检查key是否存在</h3><p>在上一节中，我们了解到，当一个键不存在时，map 会返回该类型的零值。然而，这在我们需要确认某个键是否实际存在于 map 中时并不起作用。</p><p>例如，我们想知道某个货币代码键是否存在于 <code>currencyCode</code> map 中。可以使用以下语法来检查某个键是否存在于 map 中：</p><div class="code-wrapper"><pre><code class="hljs fallback">value, ok := map[key]</code></pre></div><p>在上述代码中，当键存在时，<code>ok</code> 的值为 <code>true</code>，对应键的值会存储在变量 <code>value</code> 中。<br>如果键不存在，<code>ok</code> 的值为 <code>false</code>，而 <code>value</code> 则会返回类型的零值。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;currencyCode := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;USD&quot;</span>: <span class="hljs-string">&quot;US Dollar&quot;</span>,<span class="hljs-string">&quot;GBP&quot;</span>: <span class="hljs-string">&quot;Pound Sterling&quot;</span>,<span class="hljs-string">&quot;EUR&quot;</span>: <span class="hljs-string">&quot;Euro&quot;</span>,&#125;cyCode := <span class="hljs-string">&quot;INR&quot;</span><span class="hljs-keyword">if</span> currencyName, ok := currencyCode[cyCode]; ok &#123;fmt.Println(<span class="hljs-string">&quot;Currency name for currency code&quot;</span>, cyCode, <span class="hljs-string">&quot; is&quot;</span>, currencyName)<span class="hljs-keyword">return</span>&#125;fmt.Println(<span class="hljs-string">&quot;Currency name for currency code&quot;</span>, cyCode, <span class="hljs-string">&quot;not found&quot;</span>)&#125;</code></pre></div><p><a href="https://go.dev/play/p/Jo3AUobSf9J">Run in playground</a></p><p>在上述程序中，第 14 行的 <code>ok</code> 将为 <code>false</code>，因为键 <code>INR</code> 不存在。因此，程序将打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">Currency name for currency code INR not found</code></pre></div><h3 id="遍历-map-中的所有元素"><a href="#遍历-map-中的所有元素" class="headerlink" title="遍历 map 中的所有元素"></a>遍历 map 中的所有元素</h3><p>可以使用 <code>for</code> 循环的 <code>range</code> 形式来遍历 map 中的所有元素。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;currencyCode := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;USD&quot;</span>: <span class="hljs-string">&quot;US Dollar&quot;</span>,<span class="hljs-string">&quot;GBP&quot;</span>: <span class="hljs-string">&quot;Pound Sterling&quot;</span>,<span class="hljs-string">&quot;EUR&quot;</span>: <span class="hljs-string">&quot;Euro&quot;</span>,&#125;<span class="hljs-keyword">for</span> code, name := <span class="hljs-keyword">range</span> currencyCode &#123;fmt.Printf(<span class="hljs-string">&quot;Currency Name for currency code %s is %s\n&quot;</span>, code, name)&#125;&#125;</code></pre></div><p><a href="https://go.dev/play/p/nCbYjtQxA2m">Run in playground</a></p><p>上述程序将会输出，</p><div class="code-wrapper"><pre><code class="hljs fallback">Currency Name for currency code GBP is Pound SterlingCurrency Name for currency code EUR is EuroCurrency Name for currency code USD is US Dollar</code></pre></div><p><em>一个需要注意的重要事实是，使用 <code>for range</code> 遍历 map 时，值的检索顺序在每次程序执行时都可能不同。它也不一定与元素添加到 map 的顺序相同。</em></p><h3 id="从-map-中删除元素"><a href="#从-map-中删除元素" class="headerlink" title="从 map 中删除元素"></a>从 map 中删除元素</h3><p>要从 <code>map</code> 中删除某个键，可以使用以下语法：<br><em><a href="https://pkg.go.dev/builtin#delete">delete(map, key)</a></em>。</p><p><code>delete</code> 函数不会返回任何值。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;currencyCode := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;USD&quot;</span>: <span class="hljs-string">&quot;US Dollar&quot;</span>,<span class="hljs-string">&quot;GBP&quot;</span>: <span class="hljs-string">&quot;Pound Sterling&quot;</span>,<span class="hljs-string">&quot;EUR&quot;</span>: <span class="hljs-string">&quot;Euro&quot;</span>,&#125;fmt.Println(<span class="hljs-string">&quot;map before deletion&quot;</span>, currencyCode)<span class="hljs-built_in">delete</span>(currencyCode, <span class="hljs-string">&quot;EUR&quot;</span>)fmt.Println(<span class="hljs-string">&quot;map after deletion&quot;</span>, currencyCode)&#125;</code></pre></div><p><a href="https://go.dev/play/p/6R00ro5T6Q0">Run in playground</a></p><p>上述程序删除键<code>EUR</code>，它打印</p><div class="code-wrapper"><pre><code class="hljs fallback">map before deletion map[EUR:Euro GBP:Pound Sterling USD:US Dollar]map after deletion map[GBP:Pound Sterling USD:US Dollar]</code></pre></div><p>即使我们尝试删除一个 map 中不存在的键，也不会发生运行时错误。</p><h3 id="结构体的-map"><a href="#结构体的-map" class="headerlink" title="结构体的 map"></a>结构体的 map</h3><p>到目前为止，我们仅在 map 中存储了货币名称。如果还能存储货币符号，是不是更方便呢？这可以通过使用结构体的map来实现。<br>货币可以用一个包含货币名称和货币符号字段的结构体表示。然后可以将该结构体作为值存储在 map 中，并以货币代码作为键。<br>让我们通过编写一个程序来理解如何实现这一点。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> currency <span class="hljs-keyword">struct</span> &#123;name   <span class="hljs-type">string</span>symbol <span class="hljs-type">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;curUSD := currency&#123;name:   <span class="hljs-string">&quot;US Dollar&quot;</span>,symbol: <span class="hljs-string">&quot;$&quot;</span>,&#125;curGBP := currency&#123;name:   <span class="hljs-string">&quot;Pound Sterling&quot;</span>,symbol: <span class="hljs-string">&quot;£&quot;</span>,&#125;curEUR := currency&#123;name:   <span class="hljs-string">&quot;Euro&quot;</span>,symbol: <span class="hljs-string">&quot;€&quot;</span>,&#125;currencyCode := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]currency&#123;<span class="hljs-string">&quot;USD&quot;</span>: curUSD,<span class="hljs-string">&quot;GBP&quot;</span>: curGBP,<span class="hljs-string">&quot;EUR&quot;</span>: curEUR,&#125;<span class="hljs-keyword">for</span> cyCode, cyInfo := <span class="hljs-keyword">range</span> currencyCode &#123;fmt.Printf(<span class="hljs-string">&quot;Currency Code: %s, Name: %s, Symbol: %s\n&quot;</span>, cyCode, cyInfo.name, cyInfo.symbol)&#125;&#125;</code></pre></div><p><a href="https://go.dev/play/p/o6ONzGDm6-m">Run in playground</a></p><p>在上述程序中，<code>currency</code> 结构体包含 <code>name</code> 和 <code>symbol</code> 字段。我们创建了三个货币对象：<code>curUSD</code>、<code>curGBP</code> 和 <code>curEUR</code>。</p><p>在第 26 行，我们初始化了一个以 <code>string</code> 类型为键、<code>currency</code> 类型为值的 map，其中包含我们创建的三个货币。</p><p>第 32 行使用 <code>for range</code> 遍历 map，接下来的代码打印了货币的详细信息。程序将输出如下内容：</p><div class="code-wrapper"><pre><code class="hljs fallback">Currency Code: USD, Name: US Dollar, Symbol: $Currency Code: GBP, Name: Pound Sterling, Symbol: £Currency Code: EUR, Name: Euro, Symbol: €</code></pre></div><h3 id="map的长度"><a href="#map的长度" class="headerlink" title="map的长度"></a>map的长度</h3><p>可以使用 <a href="https://pkg.go.dev/builtin#len">len</a> 函数来确定 map 的长度。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;currencyCode := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;USD&quot;</span>: <span class="hljs-string">&quot;US Dollar&quot;</span>,<span class="hljs-string">&quot;GBP&quot;</span>: <span class="hljs-string">&quot;Pound Sterling&quot;</span>,<span class="hljs-string">&quot;EUR&quot;</span>: <span class="hljs-string">&quot;Euro&quot;</span>,&#125;fmt.Println(<span class="hljs-string">&quot;length is&quot;</span>, <span class="hljs-built_in">len</span>(currencyCode))&#125;</code></pre></div><p><a href="https://go.dev/play/p/jGWltEW5X1c">Run in playground</a></p><p>上面的程序中，<code>len(currencyCode)</code> 返回 map 的长度。程序会输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">length is 3</code></pre></div><h3 id="Map-是引用类型"><a href="#Map-是引用类型" class="headerlink" title="Map 是引用类型"></a>Map 是引用类型</h3><p>与 <a href="../%E3%80%90GolangBot%E3%80%9111-%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/">切片</a>类似，map 是引用类型。当一个 map 被赋值给一个新变量时，它们都会指向相同的底层数据结构。因此，在一个变量中所做的更改会反映在另一个变量中。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;employeeSalary := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-string">&quot;steve&quot;</span>: <span class="hljs-number">12000</span>,<span class="hljs-string">&quot;jamie&quot;</span>: <span class="hljs-number">15000</span>,<span class="hljs-string">&quot;mike&quot;</span>: <span class="hljs-number">9000</span>,&#125;fmt.Println(<span class="hljs-string">&quot;Original employee salary&quot;</span>, employeeSalary)modified := employeeSalarymodified[<span class="hljs-string">&quot;mike&quot;</span>] = <span class="hljs-number">18000</span>fmt.Println(<span class="hljs-string">&quot;Employee salary changed&quot;</span>, employeeSalary)&#125;</code></pre></div><p><a href="https://go.dev/play/p/YUhmL6d0K5__x">Run in playground</a></p><p>在上面程序的第 14 行，<code>employeeSalary</code> 被赋值给了 <code>modified</code>。接下来一行中，<code>mike</code> 的薪水在 <code>modified</code> map 中被更改为 <code>18000</code>。由于 map 是引用类型，<code>employeeSalary</code> 中 <code>mike</code> 的薪水也会变成 <code>18000</code>。</p><p>程序会输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">Original employee salary map[jamie:15000 mike:9000 steve:12000]Employee salary changed map[jamie:15000 mike:18000 steve:12000]</code></pre></div><p>类似地，当 map 被作为参数传递给函数时，对 map 的任何修改也会影响到调用者。</p><h3 id="Map-的相等性"><a href="#Map-的相等性" class="headerlink" title="Map 的相等性"></a>Map 的相等性</h3><p>Map 不能使用 <code>==</code> 运算符进行比较。<code>==</code> 运算符只能用于检查一个 map 是否是 <code>nil</code>。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;      map1 := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;        <span class="hljs-string">&quot;one&quot;</span>: <span class="hljs-number">1</span>,        <span class="hljs-string">&quot;two&quot;</span>: <span class="hljs-number">2</span>,    &#125;    map2 := map1    <span class="hljs-keyword">if</span> map1 == map2 &#123;    &#125;&#125;</code></pre></div><p><a href="https://go.dev/play/p/mkfkORUV5pi">Run in playground</a></p><p>The above program will fail to compile with error</p><p>上面的程序将会编译错误</p><div class="code-wrapper"><pre><code class="hljs fallback">invalid operation: map1 == map2 (map can only be compared to nil)</code></pre></div><p>检查两个 map 是否相等的一种方法是逐个比较它们的元素。另一种方法是使用 <a href="../%E3%80%90GolangBot%E3%80%9135-%E5%8F%8D%E5%B0%84/">反射</a>。我鼓励你自己写一个程序来实现这个功能并使其工作 :)。</p><p><strong>下一篇教程 - <a href="../%E3%80%90GolangBot%E3%80%9114-Strings/">Strings</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GolangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】12-可变参数函数</title>
    <link href="/%E3%80%90GolangBot%E3%80%9112-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0/"/>
    <url>/%E3%80%90GolangBot%E3%80%9112-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到<a href="../golangbot/">Golang系列教程</a>的第12篇。</p><h3 id="什么是变参函数？"><a href="#什么是变参函数？" class="headerlink" title="什么是变参函数？"></a>什么是变参函数？</h3><p>通常，<a href="../%E3%80%90GolangBot%E3%80%916-%E5%87%BD%E6%95%B0">函数</a>只接受固定数量的参数。*变参函数是接受可变数量参数的函数。如果函数定义的最后一个参数前面有省略号 <strong>…</strong>，则该函数可以接受任意数量的参数。*</p><p><strong>只有函数的最后一个参数可以是变参。我们将在本教程的下一部分了解为什么会这样。</strong></p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h3 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h3><div class="code-wrapper"><pre><code class="hljs fallback">func hello(a int, b ...int) &#123;&#125;</code></pre></div><p>在上述函数中，参数 <code>b</code> 是变参，因为它前面加了省略号，它可以接受任意数量的参数。这个函数可以通过以下语法调用：</p><div class="code-wrapper"><pre><code class="hljs fallback">hello(1, 2) //passing one argument &quot;2&quot; to bhello(5, 6, 7, 8, 9) //passing arguments &quot;6, 7, 8 and 9&quot; to b</code></pre></div><p>在上述代码中，第 1 行我们传递了一个参数 <code>2</code> 给 <code>b</code>，在下一行，我们将四个参数 <code>6, 7, 8, 9</code> 传递给 <code>b</code>。</p><p>也可以向变参函数传递零个参数。</p><div class="code-wrapper"><pre><code class="hljs fallback">hello(1)</code></pre></div><p>在上述代码中，我们向 <code>hello</code> 传递了零个参数给 <code>b</code>，这是完全允许的。</p><p>到现在为止，你应该已经明白为什么变参参数只能放在最后了。</p><p>让我们尝试将 <code>hello</code> 函数的第一个参数改为变参。</p><p>语法将如下所示：</p><div class="code-wrapper"><pre><code class="hljs fallback">func hello(b ...int, a int) &#123;&#125;</code></pre></div><p>在上述函数中，无法为参数 <code>a</code> 传递参数，因为无论我们传递什么参数，它都会分配给第一个参数 <code>b</code>，因为它是变参。因此，变参参数只能在函数定义的最后出现。上述函数会因错误 <code>syntax error: cannot use ... with non-final parameter b</code> 编译失败。</p><h3 id="示例和理解变参函数如何工作"><a href="#示例和理解变参函数如何工作" class="headerlink" title="示例和理解变参函数如何工作"></a>示例和理解变参函数如何工作</h3><p>让我们创建一个自己的变参函数。我们将编写一个简单的程序来判断一个整数是否存在于输入的整数列表中。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">find</span><span class="hljs-params">(num <span class="hljs-type">int</span>, nums ...<span class="hljs-type">int</span>)</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;type of nums is %T\n&quot;</span>, nums)found := <span class="hljs-literal">false</span><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> nums &#123;<span class="hljs-keyword">if</span> v == num &#123;fmt.Println(num, <span class="hljs-string">&quot;found at index&quot;</span>, i, <span class="hljs-string">&quot;in&quot;</span>, nums)found = <span class="hljs-literal">true</span>&#125;&#125;<span class="hljs-keyword">if</span> !found &#123;fmt.Println(num, <span class="hljs-string">&quot;not found in &quot;</span>, nums)&#125;fmt.Printf(<span class="hljs-string">&quot;\n&quot;</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;find(<span class="hljs-number">89</span>, <span class="hljs-number">89</span>, <span class="hljs-number">90</span>, <span class="hljs-number">95</span>)find(<span class="hljs-number">45</span>, <span class="hljs-number">56</span>, <span class="hljs-number">67</span>, <span class="hljs-number">45</span>, <span class="hljs-number">90</span>, <span class="hljs-number">109</span>)find(<span class="hljs-number">78</span>, <span class="hljs-number">38</span>, <span class="hljs-number">56</span>, <span class="hljs-number">98</span>)    find(<span class="hljs-number">87</span>)&#125;</code></pre></div><p><a href="https://play.golang.org/p/7occymiS6s">Run in playground</a></p><p>在上述程序中，第 7 行的 <code>func find(num int, nums ...int)</code> 接受可变数量的参数给 <code>nums</code> 参数。在 <code>find</code> 函数内部，<code>nums</code> 的类型是 <code>[]int</code>，即整数切片。</p><p><strong>变参函数的工作方式是将可变数量的参数转换为变参类型的切片。例如，在上述程序的第 22 行，传递给 <code>find</code> 函数的可变数量的参数是 89、90、95。<code>find</code> 函数期望一个变参 <code>int</code> 类型的参数。因此，编译器会将这三个参数转换为类型为 <code>int</code> 的切片 <code>[]int&#123;89, 90, 95&#125;</code>，然后传递给 <code>find</code> 函数。</strong></p><p>在第 10 行，<code>for</code> 循环遍历 <code>nums</code> 切片，并打印 <code>num</code> 的位置，如果它存在于切片中。如果不存在，则打印该数字未找到。</p><p>上述程序的输出是：</p><div class="code-wrapper"><pre><code class="hljs fallback">type of nums is []int89 found at index 0 in [89 90 95]type of nums is []int45 found at index 2 in [56 67 45 90 109]type of nums is []int78 not found in  [38 56 98]type of nums is []int87 not found in  []</code></pre></div><p>在上述程序的第 25 行，<code>find</code> 函数调用只传递了一个参数。我们没有向变参 <code>nums ...int</code> 传递任何参数。如前所述，这完全合法，在这种情况下，<code>nums</code> 将是一个 <code>nil</code> 切片，长度和容量都为 0。</p><h3 id="切片参数与变参参数"><a href="#切片参数与变参参数" class="headerlink" title="切片参数与变参参数"></a>切片参数与变参参数</h3><p>现在你一定会有一个问题。在上一节中，我们学到变参传递给函数时，实际上会被转换成切片。那么，当我们可以使用切片实现相同的功能时，为什么还需要变参函数呢？我已经用切片重写了上面的程序。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (      <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">find</span><span class="hljs-params">(num <span class="hljs-type">int</span>, nums []<span class="hljs-type">int</span>)</span></span> &#123;      fmt.Printf(<span class="hljs-string">&quot;type of nums is %T\n&quot;</span>, nums)    found := <span class="hljs-literal">false</span>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> nums &#123;        <span class="hljs-keyword">if</span> v == num &#123;            fmt.Println(num, <span class="hljs-string">&quot;found at index&quot;</span>, i, <span class="hljs-string">&quot;in&quot;</span>, nums)            found = <span class="hljs-literal">true</span>        &#125;    &#125;    <span class="hljs-keyword">if</span> !found &#123;        fmt.Println(num, <span class="hljs-string">&quot;not found in &quot;</span>, nums)    &#125;    fmt.Printf(<span class="hljs-string">&quot;\n&quot;</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;      find(<span class="hljs-number">89</span>, []<span class="hljs-type">int</span>&#123;<span class="hljs-number">89</span>, <span class="hljs-number">90</span>, <span class="hljs-number">95</span>&#125;)    find(<span class="hljs-number">45</span>, []<span class="hljs-type">int</span>&#123;<span class="hljs-number">56</span>, <span class="hljs-number">67</span>, <span class="hljs-number">45</span>, <span class="hljs-number">90</span>, <span class="hljs-number">109</span>&#125;)    find(<span class="hljs-number">78</span>, []<span class="hljs-type">int</span>&#123;<span class="hljs-number">38</span>, <span class="hljs-number">56</span>, <span class="hljs-number">98</span>&#125;)    find(<span class="hljs-number">87</span>, []<span class="hljs-type">int</span>&#123;&#125;)&#125;</code></pre></div><p><a href="https://play.golang.org/p/rG-XRL3yycJ">Run in playground</a></p><p>以下是使用变参参数而非切片的优点：</p><ol><li>每次函数调用时无需创建切片。如果你查看上面的程序，我们在第 22、23、24 和 25 行每次调用时都创建了新的切片。使用变参函数时可以避免这种额外的切片创建。</li><li>在上述程序的第 25 行，我们仅仅为了满足 <code>find</code> 函数的签名创建了一个空切片。这在使用变参函数时完全不需要。使用变参函数时，这行代码可以简化为 <code>find(87)</code>。</li><li>我个人觉得使用变参函数的程序比使用切片的程序更具可读性 :)</li></ol><h3 id="append-是一个变参函数"><a href="#append-是一个变参函数" class="headerlink" title="append 是一个变参函数"></a><code>append</code> 是一个变参函数</h3><p>你是否曾经想过，标准库中的 <a href="https://golang.org/pkg/builtin/#append">append</a> 函数是如何接受任意数量的参数来追加值到 <a href="https://golangbot.com/arrays-and-slices/">切片</a> 的？这是因为它是一个变参函数。</p><div class="code-wrapper"><pre><code class="hljs fallback">func append(slice []Type, elems ...Type) []Type</code></pre></div><p>上面是 <code>append</code> 函数的定义。在这个定义中，<code>elems</code> 是一个变参参数。因此，<code>append</code> 可以接受任意数量的参数。</p><h3 id="将切片传递给变参函数"><a href="#将切片传递给变参函数" class="headerlink" title="将切片传递给变参函数"></a>将切片传递给变参函数</h3><p>让我们通过以下示例来传递一个切片给变参函数，并查看会发生什么。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (      <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">find</span><span class="hljs-params">(num <span class="hljs-type">int</span>, nums ...<span class="hljs-type">int</span>)</span></span> &#123;      fmt.Printf(<span class="hljs-string">&quot;type of nums is %T\n&quot;</span>, nums)    found := <span class="hljs-literal">false</span>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> nums &#123;        <span class="hljs-keyword">if</span> v == num &#123;            fmt.Println(num, <span class="hljs-string">&quot;found at index&quot;</span>, i, <span class="hljs-string">&quot;in&quot;</span>, nums)            found = <span class="hljs-literal">true</span>        &#125;    &#125;    <span class="hljs-keyword">if</span> !found &#123;        fmt.Println(num, <span class="hljs-string">&quot;not found in &quot;</span>, nums)    &#125;    fmt.Printf(<span class="hljs-string">&quot;\n&quot;</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;      nums := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">89</span>, <span class="hljs-number">90</span>, <span class="hljs-number">95</span>&#125;    find(<span class="hljs-number">89</span>, nums)&#125;</code></pre></div><p><a href="https://play.golang.org/p/A-DNilpH2L">Run in playground</a></p><p>在第 23 行，我们将一个切片传递给一个期望变参参数的函数。</p><p>这将不起作用。上述程序会因编译错误 <code>./prog.go:23:10: cannot use nums (type []int) as type int in argument to find</code> 而失败。</p><p>为什么这样不行呢？其实非常简单。<code>find</code> 函数的签名如下所示：</p><div class="code-wrapper"><pre><code class="hljs fallback">func find(num int, nums ...int)</code></pre></div><p>根据变参函数的定义，<code>nums ...int</code> 意味着它将接受可变数量的 <code>int</code> 类型的参数。</p><p>在上面的程序的第 23 行，<code>nums</code> 是一个 <code>[]int</code> 切片，它被传递给 <code>find</code> 函数，而 <code>find</code> 函数期望的是变参的 <code>int</code> 类型参数。如我们之前讨论的，变参将被转换为 <code>int</code> 类型的切片，因为 <code>find</code> 期望的是变参的 <code>int</code> 类型参数。在这种情况下，<code>nums</code> 已经是一个 <code>[]int</code> 切片，编译器会尝试创建一个新的 <code>[]int</code>，即编译器尝试执行以下操作：</p><div class="code-wrapper"><pre><code class="hljs fallback">find(89, []int&#123;nums&#125;)</code></pre></div><p>这会失败，因为 <code>nums</code> 是一个 <code>[]int</code>，而不是一个 <code>int</code>。</p><p>那么，有没有办法将切片传递给变参函数呢？答案是有的。</p><p><strong>有一种语法糖可以用来将切片传递给变参函数。你需要在切片后面加上省略号 <code>...</code>。这样做时，切片会直接传递给函数，而不会创建一个新的切片。</strong></p><p>在上述程序中，如果你将第 23 行的 <code>find(89, nums)</code> 替换为 <code>find(89, nums...)</code>，程序将会编译并打印以下输出。</p><div class="code-wrapper"><pre><code class="hljs fallback">type of nums is []int89 found at index 0 in [89 90 95]</code></pre></div><p>这里是完整的程序供你参考。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (      <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">find</span><span class="hljs-params">(num <span class="hljs-type">int</span>, nums ...<span class="hljs-type">int</span>)</span></span> &#123;      fmt.Printf(<span class="hljs-string">&quot;type of nums is %T\n&quot;</span>, nums)    found := <span class="hljs-literal">false</span>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> nums &#123;        <span class="hljs-keyword">if</span> v == num &#123;            fmt.Println(num, <span class="hljs-string">&quot;found at index&quot;</span>, i, <span class="hljs-string">&quot;in&quot;</span>, nums)            found = <span class="hljs-literal">true</span>        &#125;    &#125;    <span class="hljs-keyword">if</span> !found &#123;        fmt.Println(num, <span class="hljs-string">&quot;not found in &quot;</span>, nums)    &#125;    fmt.Printf(<span class="hljs-string">&quot;\n&quot;</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;      nums := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">89</span>, <span class="hljs-number">90</span>, <span class="hljs-number">95</span>&#125;    find(<span class="hljs-number">89</span>, nums...)&#125;</code></pre></div><p><a href="https://play.golang.org/p/IvzwhzhFsT">Run in playground</a></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>在变参函数内部修改切片时，一定要确保你知道自己在做什么。</p><p>让我们看一个简单的例子。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">change</span><span class="hljs-params">(s ...<span class="hljs-type">string</span>)</span></span> &#123;s[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;Go&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;welcome := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>&#125;change(welcome...)fmt.Println(welcome)&#125;</code></pre></div><p><a href="https://play.golang.org/p/R0GsuW7rdd">Run in playground</a></p><p>你认为上述程序的输出是什么？如果你认为输出是 <code>[Go world]</code>，恭喜你！你已经理解了变参函数和切片的概念。如果你没有猜对，没关系，让我来解释一下我们是如何得到这个输出的。</p><p>在程序的第 13 行，我们使用了语法糖 <code>...</code>，将切片作为变参传递给 <code>change</code> 函数。</p><p>如我们之前讨论的，如果使用了 <code>...</code>，切片本身会作为参数传递，而不会创建一个新的切片。因此，<code>welcome</code> 会作为参数传递给 <code>change</code> 函数。</p><p>在 <code>change</code> 函数内部，切片的第一个元素被修改为 <code>Go</code>。因此，程序的输出是：</p><div class="code-wrapper"><pre><code class="hljs fallback">[Go world]</code></pre></div><p>这里有一个程序，帮助你更好地理解变参函数。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">change</span><span class="hljs-params">(s ...<span class="hljs-type">string</span>)</span></span> &#123;s[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;Go&quot;</span>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-string">&quot;playground&quot;</span>)fmt.Println(s)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;welcome := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>&#125;change(welcome...)fmt.Println(welcome)&#125;</code></pre></div><p><a href="https://play.golang.org/p/WdbFIkdLoe">Run in playground</a></p><p>我把上面的程序作为一个练习留给你，让你自己弄明白它是如何工作的 :）。</p><blockquote><p>这里说一点我自己的理解，程序输出结果是</p><div class="code-wrapper"><pre><code class="hljs fallback">[Go world playground][Go world]</code></pre></div><p>原因在于，当append之前，切片是对底层数组的引用，s的改变会导致welcome的改变。</p><p>但在append运行之后，s的长度超过了cap，因此变成了一个副本，两者就不想干了。可以通过调换第8行和第9行的顺序来验证。</p></blockquote><p><strong>下一篇教程 - <a href="../%E3%80%90GolangBot%E3%80%9113-Maps">Maps</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GolangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】11-数组和切片</title>
    <link href="/%E3%80%90GolangBot%E3%80%9111-%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/"/>
    <url>/%E3%80%90GolangBot%E3%80%9111-%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到<a href="../golangbot/">Golang系列教程</a>的第11篇。我们将学习Go中的数组和切片。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是一组属于同一类型的元素的集合。例如，整数集合 5、8、9、79、76 构成一个数组。在 Go 语言中，不允许混合不同类型的值，例如一个同时包含字符串和整数的数组是非法的。</p><h5 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h5><p>数组属于类型 <code>[n]T</code>。其中，<code>n</code> 表示数组中的元素数量，<code>T</code> 表示每个元素的类型。元素数量 <code>n</code> 也是类型的一部分（我们稍后会对此进行更详细的讨论）。</p><p>声明数组有多种方式，让我们逐一来看。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> a [<span class="hljs-number">3</span>]<span class="hljs-type">int</span> <span class="hljs-comment">//int array with length 3</span>fmt.Println(a)&#125;</code></pre></div><p><a href="https://play.golang.org/p/Zvgh82u0ej">Run in playground</a></p><p><strong><code>var a [3]int</code></strong> 声明了一个长度为 3 的整数数组。<strong>数组中的所有元素会自动赋值为该数组类型的零值</strong>。在这个例子中，<code>a</code> 是一个整数数组，因此 <code>a</code> 的所有元素都被赋值为 <code>0</code>，即整数类型的零值。运行上述程序将会打印</p><div class="code-wrapper"><pre><code class="hljs fallback">[0 0 0]</code></pre></div><p>数组的索引从 <code>0</code> 开始，到 <code>length - 1</code> 结束。让我们为上述数组分配一些值。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> a [<span class="hljs-number">3</span>]<span class="hljs-type">int</span> <span class="hljs-comment">//int array with length 3</span>a[<span class="hljs-number">0</span>] = <span class="hljs-number">12</span> <span class="hljs-comment">// array index starts at 0</span>a[<span class="hljs-number">1</span>] = <span class="hljs-number">78</span>a[<span class="hljs-number">2</span>] = <span class="hljs-number">50</span>fmt.Println(a)&#125;</code></pre></div><p><a href="https://play.golang.org/p/WF0Uj8sv39">Run in playground</a></p><p><code>a[0]</code> 为数组的第一个元素赋值。运行程序将会打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">[12 78 50]</code></pre></div><p>让我们使用<strong>简写声明</strong>创建相同的数组。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">12</span>, <span class="hljs-number">78</span>, <span class="hljs-number">50</span>&#125; <span class="hljs-comment">// short hand declaration to create array</span>fmt.Println(a)&#125;</code></pre></div><p><a href="https://play.golang.org/p/NKOV04zgI6">Run in playground</a></p><p>上面的程序将打印相同的输出。</p><div class="code-wrapper"><pre><code class="hljs fallback">[12 78 50]</code></pre></div><p>在使用简写声明时，并不一定需要为数组中的所有元素都赋值。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">12</span>&#125; fmt.Println(a)&#125;</code></pre></div><p><a href="https://play.golang.org/p/AdPH0kXRly">Run in playground</a></p><p>在上面的程序中，第 8 行 <code>a := [3]int&#123;12&#125;</code> 声明了一个长度为 3 的数组，但只提供了一个值 <code>12</code>。剩余的 2 个元素会自动赋值为 <code>0</code>。该程序将打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">[12 0 0]</code></pre></div><p>你甚至可以在声明中忽略数组的长度，并用 <code>...</code> 替代，让编译器自动推导数组的长度。以下程序就是这样做的：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">12</span>, <span class="hljs-number">78</span>, <span class="hljs-number">50</span>&#125; <span class="hljs-comment">// ... makes the compiler determine the length</span>fmt.Println(a)&#125;</code></pre></div><p><a href="https://play.golang.org/p/_fVmr6KGDh">Run in playground</a></p><p><strong>数组的大小是类型的一部分。</strong> 因此，<code>[5]int</code> 和 <code>[25]int</code> 是不同的类型。由于这个原因，数组的大小不能被修改。不要担心这个限制，因为存在 <code>切片</code>（slices）来解决这个问题。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">78</span>, <span class="hljs-number">8</span>&#125;<span class="hljs-keyword">var</span> b [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>b = a <span class="hljs-comment">//not possible since [3]int and [5]int are distinct types</span>&#125;</code></pre></div><p><a href="https://play.golang.org/p/kBdot3pXSB">Run in playground</a></p><p>在上面程序的第 6 行，我们尝试将一个类型为 <code>[3]int</code> 的变量赋值给一个类型为 <code>[5]int</code> 的变量，这是不允许的，因此编译器会打印以下错误：</p><div class="code-wrapper"><pre><code class="hljs fallback">./prog.go:6:7: cannot use a (type [3]int) as type [5]int in assignment</code></pre></div><h5 id="数组是值类型。"><a href="#数组是值类型。" class="headerlink" title="数组是值类型。"></a>数组是值类型。</h5><p>Go 中的数组是值类型，而不是引用类型。这意味着当数组被赋值给一个新变量时，会将原数组的副本赋值给新变量。如果对新变量进行更改，原数组不会受到影响。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := [...]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;USA&quot;</span>, <span class="hljs-string">&quot;China&quot;</span>, <span class="hljs-string">&quot;India&quot;</span>, <span class="hljs-string">&quot;Germany&quot;</span>, <span class="hljs-string">&quot;France&quot;</span>&#125;b := a <span class="hljs-comment">// a copy of a is assigned to b</span>b[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;Singapore&quot;</span>fmt.Println(<span class="hljs-string">&quot;a is &quot;</span>, a)fmt.Println(<span class="hljs-string">&quot;b is &quot;</span>, b)&#125;</code></pre></div><p><a href="https://play.golang.org/p/-ncGk1mqPd">Run in playground</a></p><p>在上面的程序中，第 7 行将 <code>a</code> 的副本赋值给 <code>b</code>。在第 8 行，<code>b</code> 的第一个元素被更改为 <code>Singapore</code>。由于数组是值类型，这一更改不会影响原始数组 <code>a</code>。程序将打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">a is [USA China India Germany France]b is [Singapore China India Germany France]</code></pre></div><p>同样，当数组作为参数传递给函数时，它们是按值传递的，原始数组不会被改变。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">changeLocal</span><span class="hljs-params">(num [5]<span class="hljs-type">int</span>)</span></span> &#123;num[<span class="hljs-number">0</span>] = <span class="hljs-number">55</span>fmt.Println(<span class="hljs-string">&quot;inside function &quot;</span>, num)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;num := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">8</span>&#125;fmt.Println(<span class="hljs-string">&quot;before passing to function &quot;</span>, num)changeLocal(num) <span class="hljs-comment">//num is passed by value</span>fmt.Println(<span class="hljs-string">&quot;after passing to function &quot;</span>, num)&#125;</code></pre></div><p><a href="https://play.golang.org/p/e3U75Q8eUZ">Run in playground</a></p><p>在上面的程序中，第 13 行，数组 <code>num</code> 实际上是按值传递给函数 <code>changeLocal</code> 的，因此由于函数调用，数组 <code>num</code> 不会被更改。程序将打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">before passing to function  [5 6 7 8 8]inside function  [55 6 7 8 8]after passing to function  [5 6 7 8 8]</code></pre></div><h5 id="数组的长度"><a href="#数组的长度" class="headerlink" title="数组的长度"></a>数组的长度</h5><p>数组的长度可以通过将数组作为参数传递给 <code>len</code> 函数来获得。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := [...]<span class="hljs-type">float64</span>&#123;<span class="hljs-number">67.7</span>, <span class="hljs-number">89.8</span>, <span class="hljs-number">21</span>, <span class="hljs-number">78</span>&#125;fmt.Println(<span class="hljs-string">&quot;length of a is&quot;</span>,<span class="hljs-built_in">len</span>(a))&#125;</code></pre></div><p><a href="https://play.golang.org/p/UrIeNlS0RN">Run in playground</a></p><p>上面程序的输出是：</p><div class="code-wrapper"><pre><code class="hljs fallback">length of a is 4</code></pre></div><h5 id="使用-range-遍历数组"><a href="#使用-range-遍历数组" class="headerlink" title="使用 range 遍历数组"></a>使用 <code>range</code> 遍历数组</h5><p>可以使用 <code>for</code> 循环遍历数组的元素。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := [...]<span class="hljs-type">float64</span>&#123;<span class="hljs-number">67.7</span>, <span class="hljs-number">89.8</span>, <span class="hljs-number">21</span>, <span class="hljs-number">78</span>&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(a); i++ &#123; <span class="hljs-comment">//looping from 0 to the length of the array</span>fmt.Printf(<span class="hljs-string">&quot;%d th element of a is %.2f\n&quot;</span>, i, a[i])&#125;&#125;</code></pre></div><p><a href="https://play.golang.org/p/80ejSTACO6">Run in playground</a></p><p>上述程序使用 <code>for</code> 循环遍历数组的元素，从索引 <code>0</code> 开始，到数组的长度减一为止。这个程序能够正常运行，并将打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">0 th element of a is 67.701 th element of a is 89.802 th element of a is 21.003 th element of a is 78.00</code></pre></div><p>Go 提供了一种更简洁的方式来遍历数组，即使用 <code>for</code> 循环的 <strong>range</strong> 形式。<code>range</code> 会返回数组元素的索引和值。让我们使用 <code>range</code> 重写上述代码，并计算数组所有元素的和。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := [...]<span class="hljs-type">float64</span>&#123;<span class="hljs-number">67.7</span>, <span class="hljs-number">89.8</span>, <span class="hljs-number">21</span>, <span class="hljs-number">78</span>&#125;sum := <span class="hljs-type">float64</span>(<span class="hljs-number">0</span>)<span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> a &#123;<span class="hljs-comment">//range returns both the index and value</span>fmt.Printf(<span class="hljs-string">&quot;%d the element of a is %.2f\n&quot;</span>, i, v)sum += v&#125;fmt.Println(<span class="hljs-string">&quot;\nsum of all elements of a&quot;</span>,sum)&#125;</code></pre></div><p><a href="https://play.golang.org/p/Ji6FRon36m">Run in playground</a></p><p>第 8 行 <code>for i, v := range a</code> 是上述程序中 <code>for</code> 循环的 range 形式。它将返回数组 <code>a</code> 中每个元素的索引和该索引处的值。我们打印这些值，并计算数组 <code>a</code> 中所有元素的和。该程序的 <strong>输出</strong> 是：</p><div class="code-wrapper"><pre><code class="hljs fallback">the element of a is 67.70the element of a is 89.80the element of a is 21.00the element of a is 78.00sum of all elements of a 256.5</code></pre></div><p>如果你只需要值并且想忽略索引，可以通过将索引替换为 <code>_</code> 空白标识符来实现。</p><div class="code-wrapper"><pre><code class="hljs fallback">for _, v := range a &#123; //ignores index&#125;</code></pre></div><p>上述 <code>for</code> 循环忽略了索引。同样，值也可以被忽略。</p><h5 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h5><p>到目前为止，我们创建的数组都是一维数组。实际上，可以创建多维数组。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printarray</span><span class="hljs-params">(a [3][2]<span class="hljs-type">string</span>)</span></span> &#123;<span class="hljs-keyword">for</span> _, v1 := <span class="hljs-keyword">range</span> a &#123;<span class="hljs-keyword">for</span> _, v2 := <span class="hljs-keyword">range</span> v1 &#123;fmt.Printf(<span class="hljs-string">&quot;%s &quot;</span>, v2)&#125;fmt.Printf(<span class="hljs-string">&quot;\n&quot;</span>)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := [<span class="hljs-number">3</span>][<span class="hljs-number">2</span>]<span class="hljs-type">string</span>&#123;&#123;<span class="hljs-string">&quot;lion&quot;</span>, <span class="hljs-string">&quot;tiger&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;cat&quot;</span>, <span class="hljs-string">&quot;dog&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;pigeon&quot;</span>, <span class="hljs-string">&quot;peacock&quot;</span>&#125;, <span class="hljs-comment">//this comma is necessary. The compiler will complain if you omit this comma</span>&#125;printarray(a)<span class="hljs-keyword">var</span> b [<span class="hljs-number">3</span>][<span class="hljs-number">2</span>]<span class="hljs-type">string</span>b[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;apple&quot;</span>b[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;samsung&quot;</span>b[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;microsoft&quot;</span>b[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;google&quot;</span>b[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;AT&amp;T&quot;</span>b[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;T-Mobile&quot;</span>fmt.Printf(<span class="hljs-string">&quot;\n&quot;</span>)printarray(b)&#125;</code></pre></div><p><a href="https://play.golang.org/p/InchXI4yY8">Run in playground</a></p><p>在上面的程序中，第 17 行使用简写语法声明了一个二维字符串数组 <code>a</code>。第 20 行末尾的逗号是必须的。这是因为词法分析器（lexer）会根据简单的规则自动插入分号。如果你有兴趣了解更多关于为什么需要分号的原因，可以阅读 <a href="https://golang.org/doc/effective_go.html#semicolons">Effective Go</a>。</p><p>在第 23 行声明了另一个二维数组 <code>b</code>，并逐个为每个索引添加字符串。这是初始化二维数组的另一种方式。</p><p>第 7 行的 <code>printarray</code> 函数使用了两个 <code>for range</code> 循环来打印二维数组的内容。上述程序将打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">lion tiger cat dog pigeon peacock apple samsung microsoft google AT&amp;T T-Mobile</code></pre></div><p>数组的内容就到这里。虽然数组看起来足够灵活，但它们有一个限制，即长度是固定的。无法增加数组的长度。在这里，<strong>切片</strong>（slices）发挥了作用。事实上，在 Go 中，切片比传统的数组更常见。</p><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>切片是数组之上的一种方便、灵活且强大的封装。切片本身并不拥有任何数据，它们只是对现有数组的引用。</p><h5 id="创建切片"><a href="#创建切片" class="headerlink" title="创建切片"></a>创建切片</h5><p>元素类型为 T 的切片表示为 <code>[]T</code>。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">76</span>, <span class="hljs-number">77</span>, <span class="hljs-number">78</span>, <span class="hljs-number">79</span>, <span class="hljs-number">80</span>&#125;<span class="hljs-keyword">var</span> b []<span class="hljs-type">int</span> = a[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>] <span class="hljs-comment">//creates a slice from a[1] to a[3]</span>fmt.Println(b)&#125;</code></pre></div><p><a href="https://play.golang.org/p/Za6w5eubBB">Run in playground</a></p><p>语法 <code>a[start:end]</code> 创建一个从数组 <code>a</code> 中索引 <code>start</code> 到索引 <code>end - 1</code> 的切片。所以在上述程序的第 9 行，<code>a[1:4]</code> 创建了数组 <code>a</code> 从索引 1 到索引 3 的切片表示。因此，切片 <code>b</code> 的值是 <code>[77 78 79]</code>。</p><p>让我们看看另一种创建切片的方式。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;c := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125; <span class="hljs-comment">//creates an array and returns a slice reference</span>fmt.Println(c)&#125;</code></pre></div><p><a href="https://go.dev/play/p/anQIndv7Sm6">Run in playground</a></p><p>在上述程序的第 8 行，<code>c := []int&#123;6, 7, 8&#125;</code> 创建了一个包含 3 个整数的数组，并返回一个切片引用，该引用存储在 <code>c</code> 中。</p><h5 id="修改切片"><a href="#修改切片" class="headerlink" title="修改切片"></a>修改切片</h5><p>切片本身不拥有任何数据，它只是对底层数组的一个表示。对切片所做的任何修改都会反映在底层数组中。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (      <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;      darr := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">57</span>, <span class="hljs-number">89</span>, <span class="hljs-number">90</span>, <span class="hljs-number">82</span>, <span class="hljs-number">100</span>, <span class="hljs-number">78</span>, <span class="hljs-number">67</span>, <span class="hljs-number">69</span>, <span class="hljs-number">59</span>&#125;    dslice := darr[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>]    fmt.Println(<span class="hljs-string">&quot;array before&quot;</span>,darr)    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dslice &#123;        dslice[i]++    &#125;    fmt.Println(<span class="hljs-string">&quot;array after&quot;</span>,darr) &#125;</code></pre></div><p><a href="https://play.golang.org/p/6FinudNf1k">Run in playground</a></p><p>在上述程序的第 9 行，我们从数组的索引 2、3、4 创建了 <code>dslice</code>。<code>for</code> 循环将这些索引中的值增加了 1。当我们在 <code>for</code> 循环后打印数组时，可以看到切片的更改反映在了数组中。程序的输出是：</p><div class="code-wrapper"><pre><code class="hljs fallback">array before [57 89 90 82 100 78 67 69 59]array after [57 89 91 83 101 78 67 69 59]</code></pre></div><p>当多个切片共享相同的底层数组时，每个切片所做的更改都会反映在该数组中。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;numa := [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">78</span>, <span class="hljs-number">79</span> ,<span class="hljs-number">80</span>&#125;nums1 := numa[:] <span class="hljs-comment">//creates a slice which contains all elements of the array</span>nums2 := numa[:]fmt.Println(<span class="hljs-string">&quot;array before change 1&quot;</span>,numa)nums1[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span>fmt.Println(<span class="hljs-string">&quot;array after modification to slice nums1&quot;</span>, numa)nums2[<span class="hljs-number">1</span>] = <span class="hljs-number">101</span>fmt.Println(<span class="hljs-string">&quot;array after modification to slice nums2&quot;</span>, numa)&#125;</code></pre></div><p><a href="https://play.golang.org/p/mdNi4cs854">Run in playground</a></p><p>在第 9 行，<code>numa[:]</code> 中缺少起始值和结束值。默认情况下，起始值为 <code>0</code>，结束值为 <code>len(numa)</code>。因此，两个切片 <code>nums1</code> 和 <code>nums2</code> 共享相同的数组。程序的输出是：</p><div class="code-wrapper"><pre><code class="hljs fallback">array before change 1 [78 79 80]array after modification to slice nums1 [100 79 80]array after modification to slice nums2 [100 101 80]</code></pre></div><p>从输出可以看出，当切片共享相同的数组时，对切片所做的修改会反映在数组中。</p><h5 id="切片的长度和容量"><a href="#切片的长度和容量" class="headerlink" title="切片的长度和容量"></a>切片的长度和容量</h5><p>切片的长度是切片中元素的数量。<strong>切片的容量是从切片创建的索引开始，底层数组中元素的数量。</strong></p><p>让我们编写一些代码来更好地理解这一点。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fruitarray := [...]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>, <span class="hljs-string">&quot;grape&quot;</span>, <span class="hljs-string">&quot;mango&quot;</span>, <span class="hljs-string">&quot;water melon&quot;</span>, <span class="hljs-string">&quot;pine apple&quot;</span>, <span class="hljs-string">&quot;chikoo&quot;</span>&#125;fruitslice := fruitarray[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]fmt.Printf(<span class="hljs-string">&quot;length of slice %d capacity %d&quot;</span>, <span class="hljs-built_in">len</span>(fruitslice), <span class="hljs-built_in">cap</span>(fruitslice)) <span class="hljs-comment">//length of fruitslice is 2 and capacity is 6</span>&#125;</code></pre></div><p><a href="https://play.golang.org/p/a1WOcdv827">Run in playground</a></p><p>在上述程序中，<code>fruitslice</code> 是从 <code>fruitarray</code> 的索引 1 和 2 创建的。因此，<code>fruitslice</code> 的长度是 2。</p><p><code>fruitarray</code> 的长度是 7，<code>fruitslice</code> 是从 <code>fruitarray</code> 的索引 1 创建的。因此，<code>fruitslice</code> 的容量是从索引 1 开始的 <code>fruitarray</code> 中的元素数量，即从 <code>orange</code> 开始，容量为 6。因此，<code>fruitslice</code> 的容量是 6。该程序（<a href="https://play.golang.org/p/a1WOcdv827">程序链接</a>）打印出 <strong>slice 的长度 2 容量 6</strong>。</p><p>切片可以重新切片，直到其容量为止。超出此范围将导致程序抛出运行时错误。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (      <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;      fruitarray := [...]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>, <span class="hljs-string">&quot;grape&quot;</span>, <span class="hljs-string">&quot;mango&quot;</span>, <span class="hljs-string">&quot;water melon&quot;</span>, <span class="hljs-string">&quot;pine apple&quot;</span>, <span class="hljs-string">&quot;chikoo&quot;</span>&#125;    fruitslice := fruitarray[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]    fmt.Printf(<span class="hljs-string">&quot;length of slice %d capacity %d\n&quot;</span>, <span class="hljs-built_in">len</span>(fruitslice), <span class="hljs-built_in">cap</span>(fruitslice)) <span class="hljs-comment">//length of is 2 and capacity is 6</span>    fruitslice = fruitslice[:<span class="hljs-built_in">cap</span>(fruitslice)] <span class="hljs-comment">//re-slicing fruitslice till its capacity</span>    fmt.Println(<span class="hljs-string">&quot;After re-slicing length is&quot;</span>,<span class="hljs-built_in">len</span>(fruitslice), <span class="hljs-string">&quot;and capacity is&quot;</span>,<span class="hljs-built_in">cap</span>(fruitslice))&#125;</code></pre></div><p><a href="https://go.dev/play/p/GI1gkZReeya">Run in playground</a></p><p>在上述程序的第 11 行，<code>fruitslice</code> 被重新切片，直到其容量为止。该程序的输出是：</p><div class="code-wrapper"><pre><code class="hljs fallback">length of slice 2 capacity 6After re-slicing length is 6 and capacity is 6</code></pre></div><h5 id="使用-make-创建切片"><a href="#使用-make-创建切片" class="headerlink" title="使用 make 创建切片"></a>使用 <code>make</code> 创建切片</h5><p><code>func make([]T, len, cap) []T</code> 可以通过传递类型、长度和容量来创建一个切片。容量参数是可选的，默认为长度。<code>make</code> 函数创建一个数组并返回一个切片引用。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;i := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>)fmt.Println(i)&#125;</code></pre></div><p><a href="https://play.golang.org/p/M4OqxzerxN">Run in playground</a></p><p>当使用 <code>make</code> 创建切片时，默认情况下切片中的值会被初始化为零。上述程序的输出将是 <code>[0 0 0 0 0]</code>。</p><h5 id="向切片追加元素"><a href="#向切片追加元素" class="headerlink" title="向切片追加元素"></a>向切片追加元素</h5><p>正如我们所知道的，数组的长度是固定的，不能增加。而切片是动态的，可以使用 <code>append</code> 函数向切片中追加新元素。<code>append</code> 函数的定义是 <code>func append(s []T, x ...T) []T</code>。</p><p><strong>x …T</strong> 在函数定义中表示该函数接受可变数量的参数。这样的函数被称为 <a href="../%E3%80%90GolangBot%E3%80%9112-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0">变参函数</a>。</p><p>不过，有一个问题可能困扰你。如果切片是由数组支持的，而数组本身是固定长度的，那么切片是如何具有动态长度的呢？实际上，发生的情况是，当向切片中追加新元素时，首先会创建一个新的数组。现有数组的元素会被复制到这个新数组中，并且返回一个指向新数组的切片引用。新切片的容量将是旧切片容量的两倍。很酷，对吧？下面的程序将使这一点更加清晰。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;cars := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;Ferrari&quot;</span>, <span class="hljs-string">&quot;Honda&quot;</span>, <span class="hljs-string">&quot;Ford&quot;</span>&#125;fmt.Println(<span class="hljs-string">&quot;cars:&quot;</span>, cars, <span class="hljs-string">&quot;has old length&quot;</span>, <span class="hljs-built_in">len</span>(cars), <span class="hljs-string">&quot;and capacity&quot;</span>, <span class="hljs-built_in">cap</span>(cars)) <span class="hljs-comment">//capacity of cars is 3</span>cars = <span class="hljs-built_in">append</span>(cars, <span class="hljs-string">&quot;Toyota&quot;</span>)fmt.Println(<span class="hljs-string">&quot;cars:&quot;</span>, cars, <span class="hljs-string">&quot;has new length&quot;</span>, <span class="hljs-built_in">len</span>(cars), <span class="hljs-string">&quot;and capacity&quot;</span>, <span class="hljs-built_in">cap</span>(cars)) <span class="hljs-comment">//capacity of cars is doubled to 6</span>&#125;</code></pre></div><p><a href="https://play.golang.org/p/VUSXCOs1CF">Run in playground</a></p><p>在上述程序中，<code>cars</code> 的初始容量为 3。在第 10 行，我们向 <code>cars</code> 中追加了一个新元素，并将 <code>append(cars, &quot;Toyota&quot;)</code> 返回的切片重新赋值给 <code>cars</code>。现在，<code>cars</code> 的容量翻倍，变成了 6。该程序的输出是：</p><div class="code-wrapper"><pre><code class="hljs fallback">cars: [Ferrari Honda Ford] has old length 3 and capacity 3cars: [Ferrari Honda Ford Toyota] has new length 4 and capacity 6</code></pre></div><p>切片类型的零值是 <code>nil</code>。一个 <code>nil</code> 切片的长度和容量都是 0。可以使用 <code>append</code> 函数向一个 <code>nil</code> 切片追加值。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> names []<span class="hljs-type">string</span> <span class="hljs-comment">//zero value of a slice is nil</span><span class="hljs-keyword">if</span> names == <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;slice is nil going to append&quot;</span>)names = <span class="hljs-built_in">append</span>(names, <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;Sebastian&quot;</span>, <span class="hljs-string">&quot;Vinay&quot;</span>)fmt.Println(<span class="hljs-string">&quot;names contents:&quot;</span>,names)&#125;&#125;</code></pre></div><p><a href="https://play.golang.org/p/x_-4XAJHbM">Run in playground</a></p><p>在上述程序中，<code>names</code> 是 <code>nil</code>，我们向 <code>names</code> 中追加了 3 个字符串。该程序的输出是：</p><div class="code-wrapper"><pre><code class="hljs fallback">slice is nil going to appendnames contents: [John Sebastian Vinay]</code></pre></div><p>也可以使用 <code>...</code> 操作符将一个切片追加到另一个切片。你可以在 <a href="../%E3%80%90GolangBot%E3%80%9112-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0">变参函数</a> 教程中了解更多关于这个操作符的信息。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;veggies := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;potatoes&quot;</span>,<span class="hljs-string">&quot;tomatoes&quot;</span>,<span class="hljs-string">&quot;brinjal&quot;</span>&#125;fruits := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;oranges&quot;</span>,<span class="hljs-string">&quot;apples&quot;</span>&#125;food := <span class="hljs-built_in">append</span>(veggies, fruits...)fmt.Println(<span class="hljs-string">&quot;food:&quot;</span>,food)&#125;</code></pre></div><p><a href="https://play.golang.org/p/UnHOH_u6HS">Run in playground</a></p><p>在上述程序的第 10 行，<code>food</code> 是通过将 <code>fruits</code> 追加到 <code>veggies</code> 上创建的。程序的输出是 <code>food: [potatoes tomatoes brinjal oranges apples]</code>。</p><h5 id="将切片传递给函数"><a href="#将切片传递给函数" class="headerlink" title="将切片传递给函数"></a>将切片传递给函数</h5><p>切片可以被认为是通过一个结构类型在内部表示的。它的结构如下所示：</p><div class="code-wrapper"><pre><code class="hljs fallback">type slice struct &#123;    Length        int    Capacity      int    ZerothElement *byte&#125;</code></pre></div><p>一个切片包含长度、容量以及指向数组第零元素的指针。当切片传递给函数时，尽管是按值传递，但指针变量仍然指向相同的底层数组。因此，当切片作为参数传递给函数时，函数内部所做的更改在函数外部也可见。让我们编写一个程序来验证这一点。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subtactOne</span><span class="hljs-params">(numbers []<span class="hljs-type">int</span>)</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> numbers &#123;numbers[i] -= <span class="hljs-number">2</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;nos := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>&#125;fmt.Println(<span class="hljs-string">&quot;slice before function call&quot;</span>, nos)subtactOne(nos)                               <span class="hljs-comment">//function modifies the slice</span>fmt.Println(<span class="hljs-string">&quot;slice after function call&quot;</span>, nos) <span class="hljs-comment">//modifications are visible outside</span>&#125;</code></pre></div><p><a href="https://play.golang.org/p/IzqDihNifq">Run in playground</a></p><p>在上述程序的第 17 行，函数调用将切片的每个元素都减少了 2。当函数调用之后打印切片时，这些更改是可见的。如果你还记得，这与数组不同，因为数组在函数内部所做的更改在函数外部是不可见的。该<a href="https://play.golang.org/p/bWUb6R-1bS">程序</a>的输出是：</p><div class="code-wrapper"><pre><code class="hljs fallback">slice before function call [8 7 6]slice after function call [6 5 4]</code></pre></div><h5 id="多维切片"><a href="#多维切片" class="headerlink" title="多维切片"></a>多维切片</h5><p>与数组类似，切片也可以具有多个维度。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123; pls := [][]<span class="hljs-type">string</span> &#123;&#123;<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;C++&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;JavaScript&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;Go&quot;</span>, <span class="hljs-string">&quot;Rust&quot;</span>&#125;,&#125;<span class="hljs-keyword">for</span> _, v1 := <span class="hljs-keyword">range</span> pls &#123;<span class="hljs-keyword">for</span> _, v2 := <span class="hljs-keyword">range</span> v1 &#123;fmt.Printf(<span class="hljs-string">&quot;%s &quot;</span>, v2)&#125;fmt.Printf(<span class="hljs-string">&quot;\n&quot;</span>)&#125;&#125;</code></pre></div><p><a href="https://play.golang.org/p/--p1AvNGwN">Run in playground</a></p><p>程序的输出是，</p><div class="code-wrapper"><pre><code class="hljs fallback">C C++ JavaScript Go Rust</code></pre></div><h5 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h5><p>切片持有对底层数组的引用。只要切片存在于内存中，数组就无法被垃圾回收。当涉及到内存管理时，这可能会成为一个问题。假设我们有一个非常大的数组，并且只关心处理其中的一小部分。接下来，我们从该数组创建一个切片并开始处理该切片。这里需要注意的一个重要问题是，由于切片引用了数组，数组仍然会保留在内存中。</p><p>解决这个问题的一种方法是使用 <a href="https://golang.org/pkg/builtin/#copy">copy</a> 函数 <code>func copy(dst, src []T) int</code> 来创建该切片的副本。通过这种方式，我们可以使用新的切片，并且原始数组可以被垃圾回收。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countries</span><span class="hljs-params">()</span></span> []<span class="hljs-type">string</span> &#123;     countries := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;USA&quot;</span>, <span class="hljs-string">&quot;Singapore&quot;</span>, <span class="hljs-string">&quot;Germany&quot;</span>, <span class="hljs-string">&quot;India&quot;</span>, <span class="hljs-string">&quot;Australia&quot;</span>&#125;neededCountries := countries[:<span class="hljs-built_in">len</span>(countries)<span class="hljs-number">-2</span>]countriesCpy := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-built_in">len</span>(neededCountries))<span class="hljs-built_in">copy</span>(countriesCpy, neededCountries) <span class="hljs-comment">//copies neededCountries to countriesCpy</span><span class="hljs-keyword">return</span> countriesCpy&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;countriesNeeded := countries()fmt.Println(countriesNeeded)&#125;</code></pre></div><p><a href="https://play.golang.org/p/35ayYBhcDE">Run in playground</a></p><p>在上述程序的第 9 行，<code>neededCountries := countries[:len(countries)-2]</code> 创建了一个切片，去除了 <code>countries</code> 的最后两个元素。第 11 行将 <code>neededCountries</code> 复制到 <code>countriesCpy</code> 中，并在下一行将其返回。现在，<code>countries</code> 数组可以被垃圾回收，因为 <code>neededCountries</code> 不再被引用。</p><p>我已经将我们讨论过的所有概念汇总到一个程序中。你可以从 <a href="https://github.com/golangbot/arraysandslices">GitHub</a> 下载它。</p><p><strong>下一篇教程 - <a href="../%E3%80%90GolangBot%E3%80%9112-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0">变参函数</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GolangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】10-switch语句</title>
    <link href="/%E3%80%90GolangBot%E3%80%9110-switch%E8%AF%AD%E5%8F%A5/"/>
    <url>/%E3%80%90GolangBot%E3%80%9110-switch%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<p>这是<a href="../golangbot/">Golang系列教程</a>的第10篇。</p><h3 id="什么是switch语句？"><a href="#什么是switch语句？" class="headerlink" title="什么是switch语句？"></a>什么是switch语句？</h3><p><strong>Switch是一种条件语句，它会评估一个表达式，将其与一系列可能的匹配项进行比较，并执行相应的代码块。它可以被视为代替复杂的<code>if else</code>语句的一种简洁方式。</strong></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>一例胜千言。让我们以一个简单的例子开始。这个例子接收一个手指数作为输入，并且输出这个手指的名字:)。比如，1是拇指，2是食指，以此类推。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;finger := <span class="hljs-number">4</span>fmt.Printf(<span class="hljs-string">&quot;Finger %d is &quot;</span>, finger)<span class="hljs-keyword">switch</span> finger &#123;<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:fmt.Println(<span class="hljs-string">&quot;Thumb&quot;</span>)<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:fmt.Println(<span class="hljs-string">&quot;Index&quot;</span>)<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:fmt.Println(<span class="hljs-string">&quot;Middle&quot;</span>)<span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:fmt.Println(<span class="hljs-string">&quot;Ring&quot;</span>)<span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:fmt.Println(<span class="hljs-string">&quot;Pinky&quot;</span>)&#125;&#125;</code></pre></div><p><a href="https://go.dev/play/p/94ktmJWlUom">Run in playground</a></p><p>在上面的程序中的第十行<code>switch finger</code>，将<code>finger</code>的值与每一个<code>case</code>语句进行比较。Case们从上往下执行，第一个匹配表达式的case会执行。在这个例子中，<code>finger</code>的值是<code>4</code>因此打印如下。</p><div class="code-wrapper"><pre><code class="hljs fallback">Finger 4 is Ring</code></pre></div><h3 id="重复的case是不允许的"><a href="#重复的case是不允许的" class="headerlink" title="重复的case是不允许的"></a>重复的case是不允许的</h3><p>拥有相同常量值的重复case是不允许的。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;finger := <span class="hljs-number">4</span>fmt.Printf(<span class="hljs-string">&quot;Finger %d is &quot;</span>, finger)<span class="hljs-keyword">switch</span> finger &#123;<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:fmt.Println(<span class="hljs-string">&quot;Thumb&quot;</span>)<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:fmt.Println(<span class="hljs-string">&quot;Index&quot;</span>)<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:fmt.Println(<span class="hljs-string">&quot;Middle&quot;</span>)<span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:fmt.Println(<span class="hljs-string">&quot;Ring&quot;</span>)<span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: <span class="hljs-comment">//duplicate case</span>fmt.Println(<span class="hljs-string">&quot;Another Ring&quot;</span>)<span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:fmt.Println(<span class="hljs-string">&quot;Pinky&quot;</span>)&#125;&#125;</code></pre></div><p><a href="https://go.dev/play/p/7qrmR0hdvHH">Run in playground</a></p><p>运行上面的程序将会得到如下的编译错误</p><div class="code-wrapper"><pre><code class="hljs fallback">./prog.go:19:7: duplicate case 4 (constant of type int) in expression switch./prog.go:17:7: previous case</code></pre></div><h3 id="默认case"><a href="#默认case" class="headerlink" title="默认case"></a>默认case</h3><p>我们受伤只有5根手指。如果输入了错误的手指数会发生什么呢？这就是默认case该登场的时候了。默认case将会在其它case都不匹配的情况下运行。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">switch</span> finger := <span class="hljs-number">8</span>; finger &#123;<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:fmt.Println(<span class="hljs-string">&quot;Thumb&quot;</span>)<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:fmt.Println(<span class="hljs-string">&quot;Index&quot;</span>)<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:fmt.Println(<span class="hljs-string">&quot;Middle&quot;</span>)<span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:fmt.Println(<span class="hljs-string">&quot;Ring&quot;</span>)<span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:fmt.Println(<span class="hljs-string">&quot;Pinky&quot;</span>)<span class="hljs-keyword">default</span>: <span class="hljs-comment">//default case</span>fmt.Println(<span class="hljs-string">&quot;incorrect finger number&quot;</span>)&#125;&#125;</code></pre></div><p><a href="https://go.dev/play/p/P3zBv7zHITF">Run in playground</a></p><p>在上面的程序中，<code>finfer</code>是<code>8</code>，并且他不匹配任何case。因此在默认case中的<code>incorrct finger number</code>被打印。<code>default</code>并不一定要放在switch语句的最后一个case。它可以出现在switch语句中的任何地方。</p><p>你也许注意到了<code>finger</code>定义的小改动。它在switch自身中被定义。Switch可以包含一个可选语句，这个语句在表达式执行之前被执行。在第8行，<code>finger</code>是首先被定义，然后在表达式中被使用。在这个例子中<code>finger</code>的作用域仅限于switch代码块。</p><h3 id="case中的多表达式"><a href="#case中的多表达式" class="headerlink" title="case中的多表达式"></a>case中的多表达式</h3><p>在一个case中，包含多个用逗号分隔的表达式也是可以的。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;letter := <span class="hljs-string">&quot;i&quot;</span><span class="hljs-keyword">switch</span> letter &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;i&quot;</span>, <span class="hljs-string">&quot;o&quot;</span>, <span class="hljs-string">&quot;u&quot;</span>: <span class="hljs-comment">//multiple expressions in case</span>fmt.Printf(<span class="hljs-string">&quot;%s is a vowel&quot;</span>, letter)<span class="hljs-keyword">default</span>:fmt.Printf(<span class="hljs-string">&quot;%s is not a vowel&quot;</span>, letter)&#125;&#125;</code></pre></div><p><a href="https://go.dev/play/p/fYI-vbKNGfc">Run in playground</a></p><p>上面的程序检测<code>letter</code>是不是元音字母。第10行的代码<code>case &quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;:</code>匹配所有的元音字母。因为<code>i</code>是原因，这个程序将会打印</p><div class="code-wrapper"><pre><code class="hljs fallback">i is a vowel</code></pre></div><h3 id="无表达式switch"><a href="#无表达式switch" class="headerlink" title="无表达式switch"></a>无表达式switch</h3><p>“switch 语句中的表达式是可选的，可以省略。如果省略了表达式，switch 会被视为 <code>switch true</code>，每个 <code>case</code> 表达式都会被求值判断其真假，并执行相应的代码块。”</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;hour := <span class="hljs-number">15</span> <span class="hljs-comment">// hour in 24 hour format</span><span class="hljs-comment">// Using switch to determine the work shift</span><span class="hljs-keyword">switch</span> &#123;<span class="hljs-keyword">case</span> hour &gt;= <span class="hljs-number">6</span> &amp;&amp; hour &lt; <span class="hljs-number">12</span>:fmt.Println(<span class="hljs-string">&quot;It&#x27;s the morning shift.&quot;</span>)<span class="hljs-keyword">case</span> hour &gt;= <span class="hljs-number">12</span> &amp;&amp; hour &lt; <span class="hljs-number">17</span>:fmt.Println(<span class="hljs-string">&quot;It&#x27;s the afternoon shift.&quot;</span>)<span class="hljs-keyword">case</span> hour &gt;= <span class="hljs-number">17</span> &amp;&amp; hour &lt; <span class="hljs-number">21</span>:fmt.Println(<span class="hljs-string">&quot;It&#x27;s the evening shift.&quot;</span>)<span class="hljs-keyword">case</span> (hour &gt;= <span class="hljs-number">21</span> &amp;&amp; hour &lt;= <span class="hljs-number">24</span>) || (hour &gt;= <span class="hljs-number">0</span> &amp;&amp; hour &lt; <span class="hljs-number">6</span>):fmt.Println(<span class="hljs-string">&quot;It&#x27;s the night shift.&quot;</span>)<span class="hljs-keyword">default</span>:fmt.Println(<span class="hljs-string">&quot;Invalid hour.&quot;</span>)&#125;&#125;</code></pre></div><p><a href="https://go.dev/play/p/Bso-wGY040c">Run in playground</a></p><p>在上面的程序中，switch中没有表达式，因此他被认为是true并且每个case都执行。13行的<code>hour &gt;= 12 &amp;&amp; hour &lt; 17</code>是<code>true</code>并且程序打印</p><div class="code-wrapper"><pre><code class="hljs fallback">It&#x27;s the afternoon shift.</code></pre></div><p>这种类型的switch可以被看作多个<code>if else</code>语句的替代方案。</p><h3 id="Fallthrough"><a href="#Fallthrough" class="headerlink" title="Fallthrough"></a>Fallthrough</h3><p>“在 Go 语言中，执行完一个 case 后，控制流会立即跳出 switch 语句。<code>fallthrough</code> 语句用于将控制转移到刚执行完的 case 之后的下一个 case 的第一条语句。</p><p>让我们编写一个程序来理解 fallthrough。我们的程序将检查输入的数字是否小于 50、100 或 200。例如，如果我们输入 75，程序将打印出 75 小于 100 和 200。我们将使用 <code>fallthrough</code> 来实现这个功能。”</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">number</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;num := <span class="hljs-number">15</span> * <span class="hljs-number">5</span><span class="hljs-keyword">return</span> num&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">switch</span> num := number(); &#123; <span class="hljs-comment">//num is not a constant</span><span class="hljs-keyword">case</span> num &lt; <span class="hljs-number">50</span>:fmt.Printf(<span class="hljs-string">&quot;%d is lesser than 50\n&quot;</span>, num)<span class="hljs-keyword">fallthrough</span><span class="hljs-keyword">case</span> num &lt; <span class="hljs-number">100</span>:fmt.Printf(<span class="hljs-string">&quot;%d is lesser than 100\n&quot;</span>, num)<span class="hljs-keyword">fallthrough</span><span class="hljs-keyword">case</span> num &lt; <span class="hljs-number">200</span>:fmt.Printf(<span class="hljs-string">&quot;%d is lesser than 200&quot;</span>, num)&#125;&#125;</code></pre></div><p><a href="https://go.dev/play/p/yt3kMvYlzLR">Run in playground</a></p><p>switch 和 case 表达式不一定要是常量，它们也可以在运行时求值。在上面的程序中，<code>num</code> 在第 13 行被初始化为函数 <code>number()</code> 的返回值。控制流进入 switch 后开始求值各个 case。第 17 行的 <code>case num &lt; 100:</code> 判断为真，程序打印出 <code>75 小于 100</code>。下一条语句是 <code>fallthrough</code>。当遇到 <code>fallthrough</code> 时，控制流会移动到下一个 case 的第一条语句，因此也会打印出 <code>75 小于 200</code>。程序的输出结果是</p><div class="code-wrapper"><pre><code class="hljs fallback">75 is lesser than 10075 is lesser than 200</code></pre></div><p><em><code>fallthrough</code> 必须是 <code>case</code> 中的最后一条语句。如果它出现在中间位置，编译器会报错：<code>fallthrough statement out of place</code>（fallthrough 语句位置不正确）</em></p><h3 id="即使case为false，fallthrough也会运行"><a href="#即使case为false，fallthrough也会运行" class="headerlink" title="即使case为false，fallthrough也会运行"></a>即使case为false，fallthrough也会运行</h3><p><code>fallthrough</code> 使用时有一个需要特别注意的细节：即使 case 的条件判断为 false，fallthrough 也会执行。 让我们看看下面这个程序。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">switch</span> num := <span class="hljs-number">25</span>; &#123; <span class="hljs-keyword">case</span> num &lt; <span class="hljs-number">50</span>:fmt.Printf(<span class="hljs-string">&quot;%d is lesser than 50\n&quot;</span>, num)<span class="hljs-keyword">fallthrough</span><span class="hljs-keyword">case</span> num &gt; <span class="hljs-number">100</span>:fmt.Printf(<span class="hljs-string">&quot;%d is greater than 100\n&quot;</span>, num)&#125;&#125;</code></pre></div><p>go</p><p><a href="https://go.dev/play/p/u2AN8LhYYMM">Run in playground</a></p><p>在上面的程序中，<code>num</code>是25，它小于50，因此第9行的case是<code>true</code>。<code>fallthrough</code>出现在第11行。下一个<code>casecase num &gt; 100:</code>在第12行，因为num &lt; 100所以它是false。但是fallthrough不考虑这个。即便case是false，fallthrough也会运行。</p><p>上面的程序将会打印</p><div class="code-wrapper"><pre><code class="hljs fallback">25 is lesser than 5025 is greater than 100</code></pre></div><p>所以使用fallthrough的时候，确保你知道你在干什么。</p><p>还有一点要注意，<code>fallthrough</code> 不能用在 switch 的最后一个 case 中，因为后面没有更多的 case 可以执行。如果在最后一个 case 中使用 <code>fallthrough</code>，会导致编译错误：<code>cannot fallthrough final case in switch</code>（不能在 switch 的最后一个 case 中使用 fallthrough）。</p><p>One more thing is <code>fallthrough</code> cannot be used in the last case of a switch since there are no more cases to fallthrough. If <code>fallthrough</code> is present in the last case, it will result in the following compilation error <code>cannot fallthrough final case in switch</code></p><h3 id="中断switch"><a href="#中断switch" class="headerlink" title="中断switch"></a>中断switch</h3><p><code>break</code> 语句可以用来提前终止 switch 的执行。让我们修改上面的例子，创建一个简单的示例来理解 break 是如何工作的。 让我们添加一个条件：如果 <code>num</code> 小于 0，则终止 switch 的执行。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">switch</span> num := <span class="hljs-number">-5</span>; &#123;<span class="hljs-keyword">case</span> num &lt; <span class="hljs-number">50</span>:<span class="hljs-keyword">if</span> num &lt; <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">break</span>&#125;fmt.Printf(<span class="hljs-string">&quot;%d is lesser than 50\n&quot;</span>, num)<span class="hljs-keyword">fallthrough</span><span class="hljs-keyword">case</span> num &lt; <span class="hljs-number">100</span>:fmt.Printf(<span class="hljs-string">&quot;%d is lesser than 100\n&quot;</span>, num)<span class="hljs-keyword">fallthrough</span><span class="hljs-keyword">case</span> num &lt; <span class="hljs-number">200</span>:fmt.Printf(<span class="hljs-string">&quot;%d is lesser than 200&quot;</span>, num)&#125;&#125;</code></pre></div><p><a href="https://go.dev/play/p/UHwBXPYLv1B">Run in playground</a></p><p>在上面的程序中，<code>num</code> 的值是 <code>-5</code>。当控制流到达第 10 行的 <a href="../%E3%80%90GolangBot%E3%80%918-if-else%E8%AF%AD%E5%8F%A5">if 语句</a> 时，由于 <code>num &lt; 0</code> 这个条件成立。break 语句会在 switch 完成之前终止它的执行，因此程序不会打印任何内容 :)。</p><h3 id="Breaking-the-outer-for-loop中断外层for循环"><a href="#Breaking-the-outer-for-loop中断外层for循环" class="headerlink" title="Breaking the outer for loop中断外层for循环"></a>Breaking the outer for loop中断外层for循环</h3><p>当switch在一个<a href="../%E3%80%90GolangBot%E3%80%919-%E5%BE%AA%E7%8E%AF">for循环</a>中时，可能需要提前中断for循环。这可以通过给for循环打标签，使用switch语句中的标签来中断for循环。我们来看一个例子。</p><p>让我们写一个程序生成一个随机奇数。</p><p>我们会创建一个死循环，使用switch case来断定生成的随机数是不是奇数。如果是奇数，生成数被打印，for循环使用它的标签中止。<code>rand</code><a href="">包</a><code>中的Intn</code>函数用来生成非负伪随机数。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;math/rand&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;randloop:<span class="hljs-keyword">for</span> &#123;<span class="hljs-keyword">switch</span> i := rand.Intn(<span class="hljs-number">100</span>); &#123;<span class="hljs-keyword">case</span> i%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>:fmt.Printf(<span class="hljs-string">&quot;Generated even number %d&quot;</span>, i)<span class="hljs-keyword">break</span> randloop&#125;&#125;&#125;</code></pre></div><p><a href="https://go.dev/play/p/0bLYOgs2TUk">Run in playground</a></p><p>在上面的程序中，第9行的for循环被打了标签<code>randloop</code>。第11行使用<code>Intn</code>函数生成了一个0到99的随机数(100不包含在内)。如果生成数是奇数，循环将在14行使用标签中断。</p><p>这个程序打印，</p><div class="code-wrapper"><pre><code class="hljs fallback">Generated even number 18</code></pre></div><p><strong>请注意，如果break语句没有和标签一起使用，仅仅只会有switch语句被中断，而循环还会继续。所以要中断外层循环，为循环打标签，并用它在switch语句里它中断循环是必要的。</strong></p><p><strong>下一篇教程 - <a href="../%E3%80%90GolangBot%E3%80%9111-%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87">数组和切片</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GolangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】9-循环</title>
    <link href="/%E3%80%90GolangBot%E3%80%919-%E5%BE%AA%E7%8E%AF/"/>
    <url>/%E3%80%90GolangBot%E3%80%919-%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到<a href="../golangbot/">Golang教程系列</a>的第9课</p><p>循环用于重复执行一段代码，直到满足某个条件为止。</p><p>在Go中，<code>for</code> 是唯一的循环。Go没有像C语言那样的<code>while</code>或<code>do while</code>循环。</p><h3 id="for-循环语法"><a href="#for-循环语法" class="headerlink" title="for 循环语法"></a>for 循环语法</h3><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">for</span> 初始化; 条件; 后续操作 &#123;&#125;</code></pre></div><p>初始化语句只会执行一次。循环初始化后，会检查条件。如果条件为真，则会执行 <code>&#123;&#125;</code> 中的循环体代码，然后执行后续操作语句。后续操作语句会在每次成功迭代后执行。执行完后续操作语句后，会再次检查条件。如果条件为真，循环将继续执行，否则<code>for</code>循环终止。</p><p>在Go中，初始化、条件和后续操作这三个部分都是可选的。让我们通过一个例子来更好地理解<code>for</code>循环。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>我们来写一个程序，使用<code>for</code>循环打印从1到10的数字。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++ &#123;fmt.Printf(<span class="hljs-string">&quot;%d &quot;</span>, i)&#125;&#125;</code></pre></div><p><a href="https://go.dev/play/p/C7lOa1D_0-1">在Playground中运行</a></p><p>在上述程序中，<code>i</code>被初始化为1。条件语句检查<code>i &lt;= 10</code>是否为真。如果条件为真，则打印<code>i</code>的值，否则循环终止。后续操作语句在每次迭代结束时将<code>i</code>增加1。一旦<code>i</code>大于10，循环终止。</p><p>上述程序将打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">1 2 3 4 5 6 7 8 9 10</code></pre></div><p>在<code>for</code>循环中声明的变量只能在循环的作用域内访问。因此，<code>i</code>无法在<code>for</code>循环体外部访问。</p><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p><code>break</code>语句用于在<code>for</code>循环完成正常执行之前中断循环，并将控制转移到<code>for</code>循环之后的代码行。</p><p>让我们修改上述程序，使其在打印到5时中断。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++ &#123;<span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">5</span> &#123;<span class="hljs-keyword">break</span> <span class="hljs-comment">//如果i &gt; 5，循环终止</span>&#125;fmt.Printf(<span class="hljs-string">&quot;%d &quot;</span>, i)&#125;fmt.Printf(<span class="hljs-string">&quot;</span><span class="hljs-string">loop ended&quot;</span>)&#125;</code></pre></div><p><a href="https://go.dev/play/p/v5MIpHz6H6J">在Playground中运行</a></p><p>在上述程序中，每次迭代都会检查<code>i</code>的值。如果<code>i</code>大于5，则执行<code>break</code>并终止循环。随后执行循环之后的打印语句。上述程序将输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">1 2 3 4 5 loop ended</code></pre></div><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p><code>continue</code>语句用于跳过当前迭代的剩余代码。<code>for</code>循环中<code>continue</code>之后的所有代码在当前迭代中将不会被执行。循环将直接跳到下一次迭代。</p><p>让我们编写一个程序，使用<code>continue</code>打印1到10之间的所有奇数。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++ &#123;<span class="hljs-keyword">if</span> i%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">continue</span>&#125;fmt.Printf(<span class="hljs-string">&quot;%d &quot;</span>, i)&#125;&#125;</code></pre></div><p><a href="https://go.dev/play/p/ZGsEFZzxYhD">在Playground中运行</a></p><p>在上述程序中，第9行检查<code>i</code>除以2的余数是否为0。如果为0，则数字是偶数，执行<code>continue</code>语句，控制直接跳到循环的下一次迭代。因此，<code>continue</code>后的打印语句不会被调用，循环进入下一次迭代。上述程序的输出为：</p><div class="code-wrapper"><pre><code class="hljs fallback">1 3 5 7 9</code></pre></div><h3 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h3><p>一个<code>for</code>循环如果里面还有另一个<code>for</code>循环，那它就被称为嵌套循环。</p><p>我们写个程序打印如下序列来了解嵌套循环。</p><div class="code-wrapper"><pre><code class="hljs fallback">***************</code></pre></div><p>下面的程序使用嵌套打印序列。第8行的变量<code>n</code>存储了序列的行数。在我们的示例中是<code>5</code>。外层循环<code>i</code>从<code>0</code>迭代到<code>4</code>，内层循环<code>j</code>从<code>0</code>迭代到当前<code>i</code>的值。内层循环每次迭代都会打印<code>*</code>，外层循环每次迭代都会打印一个空行。运行这个程序你会看到序列打印出来作为输出。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;n := <span class="hljs-number">5</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt;= i; j++ &#123;fmt.Print(<span class="hljs-string">&quot;*&quot;</span>)&#125;fmt.Println()&#125;&#125;</code></pre></div><p><a href="https://go.dev/play/p/0rq8fWjVDLb">Run in playground</a></p><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>标签可以用来从内层循环内部终止外层循环。让我们用一个简单的例子来理解这是什么意思。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">4</span>; j++ &#123;fmt.Printf(<span class="hljs-string">&quot;i = %d , j = %d\n&quot;</span>, i, j)&#125;&#125;&#125;</code></pre></div><p><a href="https://go.dev/play/p/BnCKho2x5hM">Run in playground</a></p><p>上面的程序的作用不言自明，它会打印</p><div class="code-wrapper"><pre><code class="hljs fallback">i = 0 , j = 1i = 0 , j = 2i = 0 , j = 3i = 1 , j = 1i = 1 , j = 2i = 1 , j = 3i = 2 , j = 1i = 2 , j = 2i = 2 , j = 3</code></pre></div><p>在这里没什么特别的:)。</p><p>如果我想在<code>i</code>和<code>j</code>相等的时候停止打印该怎么办呢？为了达成目的，我们需要从外层<code>for</code>循环<code>break</code>。当内层<code>for</code>循环<code>i</code>和<code>j</code>相等的时候添加一个<code>break</code>，将会只结束内层<code>for</code>循环。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">4</span>; j++ &#123;fmt.Printf(<span class="hljs-string">&quot;i = %d , j = %d\n&quot;</span>, i, j)<span class="hljs-keyword">if</span> i == j &#123;<span class="hljs-keyword">break</span>&#125;&#125;&#125;&#125;</code></pre></div><p><a href="https://go.dev/play/p/uMjbF8Ii41d">Run in playground</a></p><p>在上面的程序中，我已经在第10行内层<code>for</code>循环<code>i</code>和<code>j</code>相等的时候添加了一个<code>break</code>。这只是<code>break</code>掉了内层循环，而外层循环还在继续。这个程序将会打印</p><div class="code-wrapper"><pre><code class="hljs fallback">i = 0 , j = 1i = 0 , j = 2i = 0 , j = 3i = 1 , j = 1i = 2 , j = 1i = 2 , j = 2</code></pre></div><p>这不是我们预期的输出。我们需要在<code>i</code>和<code>j</code>相等的时候停止打印，比如他们都等于<code>1</code>的时候。</p><p>这时就需要标签来救我们了。标签可以用来终止外层循环。我们用标签重写上面的程序。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;outer:<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">4</span>; j++ &#123;fmt.Printf(<span class="hljs-string">&quot;i = %d , j = %d\n&quot;</span>, i, j)<span class="hljs-keyword">if</span> i == j &#123;<span class="hljs-keyword">break</span> outer&#125;&#125;&#125;&#125;</code></pre></div><p><a href="https://go.dev/play/p/BI10Rmp_Z3y">Run in playground</a></p><p>在上面的程序中，我们已经为外层循环在第8行添加了一个<code>outer</code>标签，并且我们在第13行已通过指定标签break了外层循环。这个程序将会在<code>i</code>和<code>j</code>相等的时候停止打印。程序将会输出</p><div class="code-wrapper"><pre><code class="hljs fallback">i = 0 , j = 1i = 0 , j = 2i = 0 , j = 3i = 1 , j = 1</code></pre></div><h3 id="使用for循环实现while循环"><a href="#使用for循环实现while循环" class="headerlink" title="使用for循环实现while循环"></a>使用for循环实现while循环</h3><p>我们在前面讨论过，<code>for</code>循环是go中唯一可用的循环语句。我们可以使用for循环的变体来实现<code>while</code>循环的功能。让我们来讨论一下如何实现。下面的程序打印从0到10的所有偶数。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;i := <span class="hljs-number">0</span><span class="hljs-keyword">for</span> ;i &lt;= <span class="hljs-number">10</span>; &#123; <span class="hljs-comment">// initialisation and post are omitted</span>fmt.Printf(<span class="hljs-string">&quot;%d &quot;</span>, i)i += <span class="hljs-number">2</span>&#125;&#125;</code></pre></div><p><a href="https://go.dev/play/p/xstHXjQrWcc">Run in playground</a></p><p>我们已经知道for循环的所有三个组成部分，即初始化、条件和后置条件，它们都是可选的。在山脉呢程序中忽略了初始化和后置条件。<code>i</code>在循环外面被初始化为<code>0</code>。只要<code>i&lt;=10</code>循环就会执行。<code>i</code>在循环内每次加<code>2</code>。上面的程序将会打印<code>0 2 4 6 8 10 </code>。</p><p>上面程序中循环的封号也可以被省略。这种格式可以看作是<code>while</code>循环的一种替代格式。上面的程序可以重写为</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;i := <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i &lt;= <span class="hljs-number">10</span> &#123; <span class="hljs-comment">//semicolons are ommitted and only condition is present. This is similar to while loop.</span>fmt.Printf(<span class="hljs-string">&quot;%d &quot;</span>, i)i += <span class="hljs-number">2</span>&#125;&#125;</code></pre></div><p><a href="https://go.dev/play/p/4kU5944zDto">Run in playground</a></p><h3 id="多重变量声明"><a href="#多重变量声明" class="headerlink" title="多重变量声明"></a>多重变量声明</h3><p>在一个<code>for</code>循环中声明和操作多个变量也是可以的。让我们写一个程序，用多重变量声明来打印如下的序列。</p><div class="code-wrapper"><pre><code class="hljs fallback">10 * 1 = 1011 * 2 = 2212 * 3 = 3613 * 4 = 5214 * 5 = 7015 * 6 = 9016 * 7 = 11217 * 8 = 13618 * 9 = 16219 * 10 = 190</code></pre></div><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> no, i := <span class="hljs-number">10</span>, <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span> &amp;&amp; no &lt;= <span class="hljs-number">19</span>; i, no = i+<span class="hljs-number">1</span>, no+<span class="hljs-number">1</span> &#123; <span class="hljs-comment">//multiple initialisation and increment</span>fmt.Printf(<span class="hljs-string">&quot;%d * %d = %d\n&quot;</span>, no, i, no*i)&#125;&#125;</code></pre></div><p><a href="https://go.dev/play/p/oFcmLl3NHzK">Run in playground</a></p><p>在上面的程序中<code>no</code>和<code>i</code>被声明，并且分别被初始化为10和1。每次循环结束后它们增加1。布尔操作符<code>&amp;&amp;</code>被用在条件里，它用来确保<code>i</code>小于等于10并且<code>no</code>小于等于19。</p><h3 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h3><p>创建一个死循环的语法如下，</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">for</span> &#123;&#125;</code></pre></div><p>下面的程序将会持续不断地打印<code>Hello World</code>。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> &#123;fmt.Println(<span class="hljs-string">&quot;Hello World&quot;</span>)&#125;&#125;</code></pre></div><p>如果你尝试着在<a href="https://go.dev/play/p/3Dmj7QVbQJz">在线环境</a>运行上面的程序，你会得到错误<code>timeout running program</code>。请试着在你的本地环境运行，打印无限多的”Hello World”。</p><p>还有一种结构<strong>range</strong>可以在<code>for</code>循环中用于<a href="../%E3%80%90GolangBot%E3%80%9111-%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/">数组操作</a>。我们将会在数组章节来探讨它。</p><p><strong>下一篇教程 - <a href="../%E3%80%90GolangBot%E3%80%9110-switch%E8%AF%AD%E5%8F%A5/">switch语句</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GolangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】8-if else语句</title>
    <link href="/%E3%80%90GolangBot%E3%80%918-if-else%E8%AF%AD%E5%8F%A5/"/>
    <url>/%E3%80%90GolangBot%E3%80%918-if-else%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到<a href="../golangbot/">Golang系列教程</a>的第八篇。</p><p>**<code>if</code>语句有个条件，如果这个条件值为<code>true</code>，它就会执行一段代码块。如果条件为<code>false</code>，就会执行另一段代码块。**在这个教程中，我们会看一下使用<code>if</code>语句的不同语法。</p><h3 id="If-语句语法"><a href="#If-语句语法" class="headerlink" title="If 语句语法"></a>If 语句语法</h3><p>下面是<code>if</code>语句的语法。</p><div class="code-wrapper"><pre><code class="hljs fallback">if condition &#123;&#125;</code></pre></div><p>如果<code>condition</code>运算为<code>true</code>，在<code>&#123;</code> 和 <code>&#125;</code>之间的代码块将被执行。</p><p>与C语言括号<code>&#123;&#125;</code>是可选的不同，即使<code>&#123;&#125;</code>之间只有一行语句，括号也是强制的。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>我们来写一个简单的示例判断一个数字是奇数还是偶数。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;num := <span class="hljs-number">10</span><span class="hljs-keyword">if</span> num%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">//checks if number is even</span>fmt.Println(<span class="hljs-string">&quot;The number&quot;</span>, num, <span class="hljs-string">&quot;is even&quot;</span>)<span class="hljs-keyword">return</span>&#125;fmt.Println(<span class="hljs-string">&quot;The number&quot;</span>, num, <span class="hljs-string">&quot;is odd&quot;</span>)&#125;</code></pre></div><p><a href="https://go.dev/play/p/RRxkgK07ul4">Run in Playground</a></p><p>在上面的程序中，第9行的条件<code>num%2</code>检测<code>num</code>除以<code>2</code>的余数是不是0。因为在这个例子中是<code>0</code>，文本<code>The number 10 is even</code>被打印，然后程序退出。</p><h3 id="If-else-语句"><a href="#If-else-语句" class="headerlink" title="If else 语句"></a>If else 语句</h3><p><code>if</code>语句有一个可选结构，<code>else</code>语句，如果<code>if</code>语句的值是<code>false</code>，它就会执行。</p><div class="code-wrapper"><pre><code class="hljs fallback">if condition &#123;&#125; else &#123;&#125;</code></pre></div><p>在上面的片段中，如果<code>condition</code>的值是<code>false</code>，那么在<code>else &#123;</code> 和 <code>&#125;</code>之间的代码就会被执行。</p><p>让我们用上<code>if else</code>语句重写程序，重新检测数值的奇偶。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;num := <span class="hljs-number">11</span><span class="hljs-keyword">if</span> num%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">//checks if number is even</span>fmt.Println(<span class="hljs-string">&quot;The number&quot;</span>, num, <span class="hljs-string">&quot;is even&quot;</span>)&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(<span class="hljs-string">&quot;The number&quot;</span>, num, <span class="hljs-string">&quot;is odd&quot;</span>)&#125;&#125;</code></pre></div><p><a href="https://go.dev/play/p/Ku3HivlA5N4">Run in playground</a></p><p>在上面的代码中，与我们在<a href="../%E3%80%90GolangBot%E3%80%918-if-else%E8%AF%AD%E5%8F%A5/#%E7%A4%BA%E4%BE%8B">上一节</a>中直接在条件为true时返回不同，我们创建了一个else语句，该语句会在条件为false时执行。这里，因为11是奇数，所以if条件为false，else语句内的代码会被执行。上述程序将输出：</p><div class="code-wrapper"><pre><code class="hljs fallback">The number 11 is odd</code></pre></div><h3 id="If-…-else-if-…-else-语句"><a href="#If-…-else-if-…-else-语句" class="headerlink" title="If … else if … else 语句"></a>If … else if … else 语句</h3><p><code>if</code>语句还可以包含可选的<code>else if</code>和<code>else</code>组件。其语法如下：</p><div class="code-wrapper"><pre><code class="hljs fallback">if condition1 &#123;...&#125; else if condition2 &#123;...&#125; else &#123;...&#125;</code></pre></div><p>条件从上到下进行判断。</p><p>在上述语句中，如果<code>condition1</code>为<code>true</code>，那么<code>if condition1 &#123;</code>和紧接着的结束括号<code>&#125;</code>之间的代码块将被执行。</p><p>如果<code>condition1</code>为<code>false</code>且<code>condition2</code>为<code>true</code>，则<code>else if condition2 &#123;</code>和下一个结束括号<code>&#125;</code>之间的代码块将被执行。</p><p>如果<code>condition1</code>和<code>condition2</code>都为<code>false</code>，则<code>else</code>语句中的代码块，即<code>else &#123;</code>和<code>&#125;</code>之间的代码，将会被执行。</p><p>可以包含任意数量的<code>else if</code>语句。</p><p><strong>一般而言，无论是<code>if</code>还是<code>else if</code>，只要条件满足<code>true</code>，相应的代码块就会被执行。如果所有条件都为<code>false</code>，则执行<code>else</code>块中的代码。</strong></p><p>让我们用<code>else if</code>来编写一个公交车票价计算程序。程序需满足以下要求：</p><ul><li>如果乘客的年龄小于5岁，则票免费。</li><li>如果乘客的年龄在5到22岁之间，则票价为10美元。</li><li>如果乘客的年龄超过22岁，则票价为15美元。</li></ul><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;age := <span class="hljs-number">10</span>ticketPrice := <span class="hljs-number">0</span><span class="hljs-keyword">if</span> age &lt; <span class="hljs-number">5</span> &#123;ticketPrice = <span class="hljs-number">0</span>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> age &gt;= <span class="hljs-number">5</span> &amp;&amp; age &lt;= <span class="hljs-number">22</span> &#123;ticketPrice = <span class="hljs-number">10</span>&#125; <span class="hljs-keyword">else</span> &#123;ticketPrice = <span class="hljs-number">15</span>&#125;fmt.Printf(<span class="hljs-string">&quot;Ticket price is $%d&quot;</span>, ticketPrice)&#125;</code></pre></div><p><a href="https://go.dev/play/p/CPaydvwiegY">Run in playground</a></p><p>在上述程序中，乘客的年龄被设为<code>10</code>。第12行的条件为<code>true</code>，因此程序将打印：</p><div class="code-wrapper"><pre><code class="hljs fallback">Ticket price is $10</code></pre></div><p>请尝试更改乘客年龄以测试<code>if else</code>语句中不同块是否按预期执行。</p><h3 id="If语句中的赋值"><a href="#If语句中的赋值" class="headerlink" title="If语句中的赋值"></a>If语句中的赋值</h3><p><code>if</code>语句还有一种变体，包含一个可选的<a href="../%E3%80%90GolangBot%E3%80%913-%E5%8F%98%E9%87%8F/#%E7%AE%80%E7%9F%AD%E5%A3%B0%E6%98%8E">简短赋值</a>语句，在条件判断之前执行。语法如下：</p><div class="code-wrapper"><pre><code class="hljs fallback">if assignment-statement; condition &#123;&#125;</code></pre></div><p>在上述语法中，<code>assignment-statement</code>在条件判断前被执行。</p><p>让我们使用这种简短语法重写公交车票价程序：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;ticketPrice := <span class="hljs-number">0</span><span class="hljs-keyword">if</span> age := <span class="hljs-number">10</span>; age &lt; <span class="hljs-number">5</span> &#123;ticketPrice = <span class="hljs-number">0</span>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> age &gt;= <span class="hljs-number">5</span> &amp;&amp; age &lt;= <span class="hljs-number">22</span> &#123;ticketPrice = <span class="hljs-number">10</span>&#125; <span class="hljs-keyword">else</span> &#123;ticketPrice = <span class="hljs-number">15</span>&#125;fmt.Printf(<span class="hljs-string">&quot;Ticket price is $%d&quot;</span>, ticketPrice)&#125;</code></pre></div><p><a href="https://go.dev/play/p/JHmL4h_MB2F">Run in playground</a></p><p>在此程序中，<code>age</code>在第9行的<code>if</code>语句中被初始化。<strong><code>age</code>只能在<code>if</code>结构中访问。也就是说，它的作用域仅限于<code>if</code>、<code>else if</code>和<code>else</code>块。如果尝试在这些块外访问<code>age</code>，编译器将会报错。</strong></p><p>这种语法常用于声明仅在<code>if else</code>构造中使用的变量。它能确保变量的作用域只限于<code>if</code>语句。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p><code>else</code>语句必须紧跟在<code>if</code>语句的结束括号<code>&#125;</code>所在的同一行。如果不是，编译器会报错。</p><p>让我们通过一个程序来理解：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;num := <span class="hljs-number">10</span><span class="hljs-keyword">if</span> num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">//checks if number is even</span>fmt.Println(<span class="hljs-string">&quot;the number is even&quot;</span>) &#125;      <span class="hljs-keyword">else</span> &#123;fmt.Println(<span class="hljs-string">&quot;the number is odd&quot;</span>)&#125;&#125;</code></pre></div><p><a href="https://go.dev/play/p/RiZ3drcztcI">Run in playground</a></p><p>在上面的程序中，<code>else</code>语句没有紧跟在第11行的<code>if</code>语句结束括号<code>&#125;</code>之后，而是换行写在下一行。这在Go语言中是不允许的。如果运行该程序，编译器会打印如下错误：</p><div class="code-wrapper"><pre><code class="hljs fallback">./prog.go:12:5: syntax error: unexpected else, expected &#125;</code></pre></div><p>这是因为Go语言的分号自动插入规则。可以阅读<a href="https://go.dev/ref/spec#Semicolons">此处</a>的语法说明了解更多。</p><p>规则中说明，如果<code>&#125;</code>是该行的最后一个标记，则在<code>&#125;</code>后会自动插入一个分号。因此，Go编译器会在第11行的<code>if</code>语句结束括号<code>&#125;</code>后插入分号。</p><p>因此，程序实际上变成：</p><div class="code-wrapper"><pre><code class="hljs fallback">...if num%2 == 0 &#123;       fmt.Println(&quot;the number is even&quot;) &#125;;  //semicolon inserted by Go Compilerelse &#123;      fmt.Println(&quot;the number is odd&quot;)&#125;</code></pre></div><p>由于<code>if &#123;...&#125; else &#123;...&#125;</code>是一条完整的语句，因此在中间不能有分号。故此程序无法通过编译。因此，<code>else</code>必须紧跟在<code>if</code>语句的结束括号<code>&#125;</code>后。</p><p>让我们重新编写程序，将<code>else</code>放到同一行：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;num := <span class="hljs-number">10</span><span class="hljs-keyword">if</span> num%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">//checks if number is even</span>fmt.Println(<span class="hljs-string">&quot;the number is even&quot;</span>) &#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(<span class="hljs-string">&quot;the number is odd&quot;</span>)&#125;&#125;</code></pre></div><p><a href="https://go.dev/play/p/NKELadXVQse">Run in playground</a></p><p>现在编译器会正常通过，我们也会感到满意 😃。</p><h3 id="Go的惯用写法"><a href="#Go的惯用写法" class="headerlink" title="Go的惯用写法"></a>Go的惯用写法</h3><p>我们已经看到多种<code>if else</code>构造，也看到了多种方式实现相同功能的程序。例如，通过不同的<code>if else</code>构造编写检查数字是奇数还是偶数的程序。那么哪一种是Go语言的惯用写法？<strong>在Go的惯用写法中，最好避免不必要的分支和代码缩进，同时尽可能早地返回。</strong></p><p>我提供了上一节的程序：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">if</span> num := <span class="hljs-number">10</span>; num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">//checks if number is even</span>fmt.Println(num,<span class="hljs-string">&quot;is even&quot;</span>) &#125;  <span class="hljs-keyword">else</span> &#123;fmt.Println(num,<span class="hljs-string">&quot;is odd&quot;</span>)&#125;&#125;</code></pre></div><p><a href="https://go.dev/play/p/ed3YK5cM3Hw">Run in playground</a></p><p>在Go中，惯用写法是尽早返回并避免<code>else</code>分支：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;num := <span class="hljs-number">10</span>;<span class="hljs-keyword">if</span> num%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">//checks if number is even</span>fmt.Println(num, <span class="hljs-string">&quot;is even&quot;</span>)<span class="hljs-keyword">return</span>&#125;fmt.Println(num, <span class="hljs-string">&quot;is odd&quot;</span>)&#125;</code></pre></div><p><a href="https://go.dev/play/p/JpWZRmFcdSG">Run in playground</a></p><p>在此程序中，当确定数字是偶数后，立即返回。这避免了不必要的<code>else</code>分支。这是Go语言中的推荐做法 😃。编写Go程序时，请牢记这一点。</p><p><strong>下一篇教程 - <a href="../%E3%80%90GolangBot%E3%80%919-%E5%BE%AA%E7%8E%AF/">循环</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GolangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】7-包</title>
    <link href="/%E3%80%90GolangBot%E3%80%917-%E5%8C%85/"/>
    <url>/%E3%80%90GolangBot%E3%80%917-%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到<a href="../golangbot/">Golang系列教程</a>的第七篇。</p><h3 id="什么是包？我们为什么要用它？"><a href="#什么是包？我们为什么要用它？" class="headerlink" title="什么是包？我们为什么要用它？"></a>什么是包？我们为什么要用它？</h3><p>到目前为止，我们已经看过了只有一个文件的Go程序，这个文件中有一个main<a href="../%E3%80%90GolangBot%E3%80%916-%E5%87%BD%E6%95%B0/">函数</a>和一些其他的函数。在实际的场景中，把所有的源码都写在一个文件中是不可扩展的。这样编写的代码不太可能复用和维护。这时候包就派上用场了。</p><p><strong>包被用于管理源代码，使其有更好的复用性和可读性。包是所有处于同一目录中文件的集合。包提供了代码分隔功能，因此可以轻松的维护Go项目。</strong></p><p>例如，加入我们正在用Go编写一个金融科技应用，其中一些功能包括单利计算、复利计算和贷款偿还计算。管理这个应用的一个简单的方式是通过功能划分。我们可以创建包<code>simpleinterest</code>, <code>compoundinterest</code> 和 <code>loanrepayment</code>。如果<code>loanrepayment</code>包需要计算单利，它可以直接导入<code>simpleinterest</code>包来完成。这样代码就实现了复用。</p><p>我们将通过创建一个简单的应用来学习包，在给定本金、利率和以年为单位的时间期限的情况下确定单利。</p><h3 id="Go-Modules"><a href="#Go-Modules" class="headerlink" title="Go Modules"></a>Go Modules</h3><p>我们将以这样的方式来组织代码，所有和单利相关的功能都放在<code>simpleinterest</code>包。为了实现目的，我们需要创建一个自定义包<code>simpleinterest</code>，在这里包含了计算单利的函数。在创建自定义包之前，我们需要先理解Go Modules，因为<strong>Go Modules</strong>被用于创建自定义包。</p><p><strong>Go Module只是Go软件包的集合。<strong>现在你可能想到了一个问题，我们为什么需要Go Modules来创建自定义包？答案是</strong>我们创建的自定义包的导入路径来自Go Modules的名字</strong>。除此之外，所有的第三方包(例如来自github的源码)及其版本都由<code>go.mod</code>文件管理。<code>go.mod</code>文件是我们在创建新模块时创建的。你会在下一节更好地理解它。</p><h3 id="创建一个Go-module"><a href="#创建一个Go-module" class="headerlink" title="创建一个Go module"></a>创建一个Go module</h3><p>运行下面的命令，在当前用户的文档目录下创建一个名为learnpackage的目录。</p><div class="code-wrapper"><pre><code class="hljs fallback">mkdir ~/Documents/learnpackage/</code></pre></div><p>通过输入<code>cd !/Documents/learnpackage</code>命令确保你在目录<code>learnpackage</code>当中。在这个目录中运行下面的命令，创建一个名为<em>learnpackage</em>的go module。</p><div class="code-wrapper"><pre><code class="hljs fallback">go mod init learnpackage</code></pre></div><p>上述命令会创建一个名为<code>go.mod</code>的文件。下面是文件中将会出现的内容。</p><div class="code-wrapper"><pre><code class="hljs v"><span class="hljs-keyword">module</span> learnpackagego <span class="hljs-number">1</span><span class="hljs-variable">.21</span><span class="hljs-variable">.0</span></code></pre></div><p><code>module learnpackage</code>表明模块的名称是<code>learnpackage</code>。正如我们前面提到的，<code>learnpackage</code>将是导入任何在这个模块中创建的包的基础路径。<code>go 1.21.0</code>指定这个模组中的文件使用的go版本是<code>1.21.0</code>。</p><h3 id="创建一个简单的单利自定义包"><a href="#创建一个简单的单利自定义包" class="headerlink" title="创建一个简单的单利自定义包"></a>创建一个简单的单利自定义包</h3><p><strong>属于同一个包的所有Go文件应该被放在它们所属的单独的文件夹内。Go的惯例是将该文件夹命名为与包相同的名称。</strong></p><p>让我们在<code>learnpackage</code>文件夹中创建一个名为<code>simpleinterest</code>的文件夹，<code>mkdir simpleinterest</code>命令将会为我们创建这个文件夹。</p><p>**<code>package packagename</code>指定某个特定的.go文件属于<code>packagename</code>包。这应该在每个源文件的第一行。*<em>因此所有</em>simpleinterest*文件夹中的文件都应该以这行代码开始，因为它们都属于<code>simpleinterest</code>包。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> simpleinterest</code></pre></div><p>在 <em>simpleinterest</em>包中创建一个<code>simpleinterest.go</code>文件。</p><p>下面是我们应用的目录结构。</p><div class="code-wrapper"><pre><code class="hljs fallback">learnpackage/├── go.mod└── simpleinterest    └── simpleinterest.go</code></pre></div><p>在<code>simpleinterest.go</code>文件中添加如下代码。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-number">1</span><span class="hljs-keyword">package</span> simpleinterest<span class="hljs-number">2</span><span class="hljs-number">3</span><span class="hljs-comment">//Calculate calculates and returns the simple interest for a principal p, rate of interest r for time duration t years</span><span class="hljs-number">4</span><span class="hljs-keyword">func</span> Calculate(p <span class="hljs-type">float64</span>, r <span class="hljs-type">float64</span>, t <span class="hljs-type">float64</span>) <span class="hljs-type">float64</span> &#123;<span class="hljs-number">5</span>interest := p * (r / <span class="hljs-number">100</span>) * t<span class="hljs-number">6</span><span class="hljs-keyword">return</span> interest<span class="hljs-number">7</span>&#125;</code></pre></div><p>在上面的代码中，我们已经创建了<code>Calculate</code>函数，它能够计算并返回单利。这个函数的作用不言自明。</p><p><em>请注意，函数名称Calculate以大写字母开头。这一点很重要，我们很快就会解释为什么需要这么做。</em></p><h3 id="main包和main函数"><a href="#main包和main函数" class="headerlink" title="main包和main函数"></a>main包和main函数</h3><p>教程的下一步是导入我们刚刚创建的<code>simpleinterest</code>包并且使用它。我们将从<code>main</code>包中导入simpleinterest包。让我们首先来理解一下<code>main</code>函数和<code>main</code>包。</p><p>每个可执行的Go应用都应该包含<code>main</code>函数。这个函数是执行的入口点。<code>main</code>函数应该位于<code>main</code>包中。</p><p>让我们通过为我们的应用创建<code>main</code>函数和<code>main</code>包来开始。</p><p>在我们的<code>learnpackage</code>目录下创建一个名为<code>main.go</code>的文件，其中有以下内容。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123; fmt.Println(<span class="hljs-string">&quot;Simple interest calculation&quot;</span>)&#125;</code></pre></div><p><code>package main</code>指定这个文件属于main包。<code>import packagename</code>语句用来导入一个已经存在的包。<code>packagename.FunctionName()</code>是调用包中函数的语法。</p><p>在第3行，我们导入了<code>fmt</code>包来使用<code>Println</code>函数。<code>fmt</code>是一个标准包，作为Go标准库的一部分提供。然后是打印<code>Simple interest calculation</code>的<code>main</code>函数。</p><p>使用如下命令移动到<code>learnpackage</code>目录</p><div class="code-wrapper"><pre><code class="hljs fallback">cd ~/Documents/learnpackage/</code></pre></div><p>用下面的命令，编译上面的程序</p><div class="code-wrapper"><pre><code class="hljs fallback">go build</code></pre></div><p>如果一切正常，我们的二进制文件将会被编译出来，而且准备好运行。在终端中输入<code>./learnpackage</code>命令，你会看到下面的输出。</p><div class="code-wrapper"><pre><code class="hljs fallback">Simple interest calculation</code></pre></div><p>如果你不理解<code>go build</code>是如何工作的，请前往<a href="../%E3%80%90GolangBot%E3%80%912-Hello-World/">Hello World教程</a>了解详情。</p><h3 id="在main包中印入simpleinterest包"><a href="#在main包中印入simpleinterest包" class="headerlink" title="在main包中印入simpleinterest包"></a>在main包中印入simpleinterest包</h3><p>为了使用自定义包，我们必须先导入它。导入路径是由包所在目录和包名称连接的go module的名称。</p><p>在我们的示例中，go module的名称是<code>learnpackage</code>，<code>simpleinterest</code>包在<code>learnpackage</code>正下方的<code>simpleinterest</code>文件夹中。</p><div class="code-wrapper"><pre><code class="hljs fallback">├── learnpackage│   └── simpleinterest</code></pre></div><p>所以<code>import &quot;learnpackage/simpleinterest&quot;</code>这一行会引入<em>simpleinterest</em>包。</p><p>在这种情况下，我们的目录结构是这样的。</p><div class="code-wrapper"><pre><code class="hljs fallback">learnpackage│   └── finance│       └── simpleinterest</code></pre></div><p>导入语句就是<code>import &quot;learnpackage/finance/simpleinterest&quot;</code>。</p><p>添加如下代码到<code>main.go</code>。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;learnpackage/simpleinterest&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;Simple interest calculation&quot;</span>)p := <span class="hljs-number">5000.0</span>r := <span class="hljs-number">10.0</span>t := <span class="hljs-number">1.0</span>si := simpleinterest.Calculate(p, r, t)fmt.Println(<span class="hljs-string">&quot;Simple interest is&quot;</span>, si)&#125;</code></pre></div><p>上面的代码引入了<code>simpleinterest</code>包并且使用了<code>Calculate</code>函数求单利。标准库中的包不需要使用模块名作为前缀，因此<code>fmt</code>不需要模组前缀就可以工作。当程序运行时，输出将会是</p><div class="code-wrapper"><pre><code class="hljs fallback">Simple interest calculationSimple interest is 500</code></pre></div><h3 id="关于go-build的更多内容"><a href="#关于go-build的更多内容" class="headerlink" title="关于go build的更多内容"></a>关于go build的更多内容</h3><p>现在我们理解了包如何工作，是时候聊一下<code>go build</code>了。像<code>go build</code>的Go工具在当前目录的上下文中工作。我们来理解一下这是什么意思。到目前为止，我们一直在<code>~/Documents/learnpackage</code>中运行<code>go build</code>。如果我们尝试在其他目录中运行，它就会报错。</p><p>试着用<code>cd ~/Documents/</code>进入<code>~/Documents/</code>，然后运行<code>go build learnpackage</code>。它会报下面的错误。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> learnpackage is not in std (/usr/local/<span class="hljs-keyword">go</span>/src/learnpackage)</code></pre></div><p>我们来理解一下错误背后的原因。<code>go build</code>用一个可选的报名作为参数(在我们的例子中包名是<code>learnpackage</code>)，如果运行时的当前目录、它的父级目录或者父级目录的父级目录，以此类推……存在包，他就会尝试编译main函数。</p><p>我们在<code>Documents</code>目录中，这里没有<code>go.mod</code>文件，因此<code>go build</code>抱怨它找不到<code>learnpackage</code>包。</p><p>当我们移动到<code>~/Documents/learnpackage</code>,这里有<code>go.mod</code>文件，并且在那个<code>go.mode</code>文件中，我们的模组名就是<code>learnpackage</code>。</p><p>所以<code>go build learnpackage</code>在<code>~/Documents/learnpackage/</code>目录中就会奏效。</p><p>但是到目前为止，我们只是使用了<code>go build</code>但并没有指定一个包名。如果没有包名被指定，<code>go build</code>会默认使用当前工作目录下的模块名称。这就是为什么在<code>~/Documents/learnpackage/</code>中不带包名运行<code>go build</code>正常的原因。所以当我们在<code>~/Documents/learnpackage/</code>中运行时，以下3种命令都是同样的。</p><div class="code-wrapper"><pre><code class="hljs fallback">go buildgo build .go build learnpackage</code></pre></div><p>我也提到了<code>go build</code>能够递归搜索父目录的go.mod文件。让我们看下这是否有效。</p><div class="code-wrapper"><pre><code class="hljs fallback">cd ~/Documents/learnpackage/simpleinterest/</code></pre></div><p>上面的命令让我们进入<code>simpleinterest</code>目录。在这个目录运行</p><div class="code-wrapper"><pre><code class="hljs fallback">go build learnpackage</code></pre></div><p><code>go build</code>将会从定义了<code>learnpackage</code>模组的<code>learnpackage</code>目录成功找到<code>go.mod</code>文件，因此它正常运行:)。</p><p>还可以使用<code>go build</code>更改输出二进制文件的位置。移至<code>~/Documents/learnpackage</code>并键入</p><div class="code-wrapper"><pre><code class="hljs fallback">1go build -o fintechapp</code></pre></div><p><code>-o</code>参数用于指定输出的二进制文件的名称。在示例中，一个名为<code>fintechapp</code>的二进制文件将会被创建。运行<code>./fintechapp</code>，二进制文件将会成功运行。</p><h3 id="导出的名称"><a href="#导出的名称" class="headerlink" title="导出的名称"></a>导出的名称</h3><p>我们在计算单利包中大写了<code>Calculate</code>函数。这在Go中有特殊意义。在go中任意大写字母开头的<a href="../%E3%80%90GolangBot%E3%80%913-%E5%8F%98%E9%87%8F/">变量</a>或者函数都是可导出的名称。只有可导出函数和变量才在其他包中可用。在我们的示例中，我们想要在main包中使用<code>Calculate</code>函数。因此这是大写。</p><p>如果在<code>simpleinterest.go</code>中，函数名称从<code>Calculate</code>改为<code>calculete</code>，如果我们尝试在main.go中使用<code>simpleinterest.calculate(p, r, t)</code>，编译会出错。</p><div class="code-wrapper"><pre><code class="hljs fallback"># learnpackage./main.go:13:8: undefined: simpleinterest.calculate</code></pre></div><p>因此如果你想在包外使用函数，它就应该被大写。</p><h3 id="init函数"><a href="#init函数" class="headerlink" title="init函数"></a>init函数</h3><p>Go的每一个包都可以有一个<code>init</code>函数。<code>init</code>函数必须不含邮任何返回类型，也不能有任何参数。init函数不能在我们的源码中被显式调用。当包被初始化的时候它会被自动调用。init函数有如下格式</p><div class="code-wrapper"><pre><code class="hljs fallback">func init() &#123;&#125;</code></pre></div><p><code>init</code>函数可被用于执行初始化任务，也可以用来在执行开始前验证程序的正确性。</p><p>一个包的初始化顺序如下：</p><ol><li>包等级变量首先被初始化</li><li>init函数接着被调用。一个包可以有多个init函数(可以在单个文件中，也可以分布在多个文件当中)，并且它们依照出现在编译器的顺序被依次调用。</li></ol><p>如果一个包引入了其他包，被引入的包首先初始化。</p><p>如果一个包被多个包引用，它只会初始化一次。</p><p>让我们在我们的应用上做些修改，来理解<code>init</code>函数。</p><p>首先，我们在<code>simpleinterest.go</code>文件添加一个<code>init</code>函数。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> simpleinterest<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-comment">/*</span><span class="hljs-comment"> * init function added</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;Simple interest package initialized&quot;</span>)&#125;<span class="hljs-comment">//Calculate calculates and returns the simple interest for principal p, rate of interest r for time duration t years</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(p <span class="hljs-type">float64</span>, r <span class="hljs-type">float64</span>, t <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">float64</span> &#123;interest := p * (r / <span class="hljs-number">100</span>) * t<span class="hljs-keyword">return</span> interest&#125;</code></pre></div><p>我们已经添加了一个简单的init函数，它只打印<code>Simple interest package initialised</code>。</p><p>现在让我们修改main包。我们知道，但计算单利的时候，本金、利率和时间期限应该比0大。我们会在<code>main.go</code>文件中使用init函数和包级别变量定义一个检查。</p><p>按如下修改<code>main.go</code>。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;learnpackage/simpleinterest&quot;</span> <span class="hljs-comment">//importing custom package</span><span class="hljs-string">&quot;log&quot;</span>)<span class="hljs-keyword">var</span> p, r, t = <span class="hljs-number">5000.0</span>, <span class="hljs-number">10.0</span>, <span class="hljs-number">1.0</span><span class="hljs-comment">/*</span><span class="hljs-comment">* init function to check if p, r and t are greater than zero</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;Main package initialized&quot;</span>)<span class="hljs-keyword">if</span> p &lt; <span class="hljs-number">0</span> &#123;log.Fatal(<span class="hljs-string">&quot;Principal is less than zero&quot;</span>)&#125;<span class="hljs-keyword">if</span> r &lt; <span class="hljs-number">0</span> &#123;log.Fatal(<span class="hljs-string">&quot;Rate of interest is less than zero&quot;</span>)&#125;<span class="hljs-keyword">if</span> t &lt; <span class="hljs-number">0</span> &#123;log.Fatal(<span class="hljs-string">&quot;Duration is less than zero&quot;</span>)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;Simple interest calculation&quot;</span>)si := simpleinterest.Calculate(p, r, t)fmt.Println(<span class="hljs-string">&quot;Simple interest is&quot;</span>, si)&#125;</code></pre></div><p>下面是对<code>main.go</code>文件所做的修改</p><ol><li><strong>p</strong>, <strong>r</strong> 和 <strong>t</strong> 从main函数级别移到了package级别。</li><li>添加了一个init函数。<em>init</em>函数打印一条日志，并通过<strong>log.Fatal</strong>在本金、利率或时间期限小于0时终止程序的运行。</li></ol><p>初始化的顺序如下，</p><ol><li>首先初始化导入的包。因此<strong>simpleinterest</strong>包首先被初始化，init方法被调用。</li><li>package级别变量<strong>p</strong>, <strong>r</strong> 和 <strong>t</strong>被初始化。</li><li>main包中的<strong>init</strong>函数被调用。</li><li><strong>main</strong>函数最后被调用。</li></ol><p>如果你运行程序，你会得到如下的输出。</p><div class="code-wrapper"><pre><code class="hljs go">Simple interest <span class="hljs-keyword">package</span> initializedMain <span class="hljs-keyword">package</span> initializedSimple interest calculationSimple interest is <span class="hljs-number">500</span></code></pre></div><p>正如我们所预期的，<code>simpleinterest</code>包首先被调用，接下来是package级别的变量<code>p</code>, <code>r</code> 和 <code>t</code>被初始化。main包中的init函数接着被调用，它检查<code>p</code>, <code>r</code> 和 <code>t</code>是否小于0，在条件为true的时候终止程序。我们将会在<a href="../%E3%80%90GolangBot%E3%80%918-if-else%E8%AF%AD%E5%8F%A5/">单独的教程</a>中详细学习<code>if</code>语句。到目前为止，可以假设。<code>if p &lt; 0</code>会检查<code>p</code>是否小于0，如果它确实小于0，程序将被终止。我们已经为<code>r</code>和<code>t</code>写了类似的条件。在这个例子中，所有这些条件都是false，程序执行会继续。最后，main函数被调用。</p><p>让我们微调一下程序，学习init函数的使用。</p><p>在<code>main.go</code>中找到这一行，</p><div class="code-wrapper"><pre><code class="hljs fallback">var p, r, t = 5000.0, 10.0, 1.0</code></pre></div><p>修改为</p><div class="code-wrapper"><pre><code class="hljs fallback">var p, r, t = -5000.0, 10.0, 1.0</code></pre></div><p>我们已经把<code>p</code>初始化成了负数。</p><p>现在如果你运行程序，你会看到</p><div class="code-wrapper"><pre><code class="hljs go">Simple interest <span class="hljs-keyword">package</span> initializedMain <span class="hljs-keyword">package</span> initialized<span class="hljs-number">2024</span>/<span class="hljs-number">04</span>/<span class="hljs-number">01</span> <span class="hljs-number">02</span>:<span class="hljs-number">58</span>:<span class="hljs-number">32</span> Principal is less than zero</code></pre></div><p><em>p</em>是负数。因此当init函数运行时，程序会在打印<code>Principal is less than zero</code>后终止。</p><h3 id="空白标识符的使用"><a href="#空白标识符的使用" class="headerlink" title="空白标识符的使用"></a>空白标识符的使用</h3><p>在Go中，引入一个包但是不使用它是不合法的。如果你这么做，编译器会抱怨。原因是避免为使用的包膨胀，浙江显著增加编译时间。把<code>main.go</code>中的代码替换为如下所示</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main  <span class="hljs-keyword">import</span> (        <span class="hljs-string">&quot;learnpackage/simpleinterest&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;&#125;</code></pre></div><p>上面的程序将会报错</p><div class="code-wrapper"><pre><code class="hljs fallback"># learnpackage./main.go:4:2: imported and not used: &quot;learnpackage/simpleinterest&quot;</code></pre></div><p>但是，当程序正在处于开发活跃状态时，导入包并稍后(如果不是现在)在代码中的某个位置使用它们是很常见的。在这些情况下，<code>_</code>空白标识符可以拯救我们。</p><p>上面的程序的错误可以被下面的代码改动所消除。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main  <span class="hljs-keyword">import</span> (        <span class="hljs-string">&quot;learnpackage/simpleinterest&quot;</span>)<span class="hljs-keyword">var</span> _ = simpleinterest.Calculate<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;&#125;</code></pre></div><p>这一行，<code>var _ = simpleinterest.Calculate</code>,屏蔽了错误。我们应该跟踪这些类型的错误消音器，并在应用程序开发结束时移除它们，包括导入的包(如果不使用的话)。因此，建议在导入语句后在package级别编写错误消音器。</p><p>有时候，我们需要导入一个包只是为了确保该包的初始化过程得以执行，即使我们并不需要在代码中使用该包的任何函数或变量。例如，我们可能需要确保 <code>simpleinterest</code> 包中的 <code>init</code> 函数被调用，即使我们并不打算在代码的任何地方使用这个包。在这种情况下，也可以使用<strong>空白标识符</strong> _ 来实现，如下所示。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (_ <span class="hljs-string">&quot;learnpackage/simpleinterest&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;&#125;</code></pre></div><p>运行上述代码，程序会输出<code>Simple interest package initialized</code>。我们已经成功初始化了<code>simpleinterest</code>包，即使它没有在任何地方使用。</p><p><strong>下一篇教程 - <a href="../%E3%80%90GolangBot%E3%80%918-if-else%E8%AF%AD%E5%8F%A5/">if else 语句</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GolangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】6-函数</title>
    <link href="/%E3%80%90GolangBot%E3%80%916-%E5%87%BD%E6%95%B0/"/>
    <url>/%E3%80%90GolangBot%E3%80%916-%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到<a href="../golangbot/">Golang系列教程</a>的第六篇。</p><h3 id="什么是函数？"><a href="#什么是函数？" class="headerlink" title="什么是函数？"></a>什么是函数？</h3><p>函数是执行特定任务的代码块。函数接受输入，对输入执行一些操作并产生输出。例如，一个函数可以把半径作为输入然后计算出面积和周长作为输出。</p><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>下面是Go中声明一个函数的语法。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">functionname</span><span class="hljs-params">(parametername datatype)</span></span> returntype &#123; <span class="hljs-comment">//function body</span>&#125;</code></pre></div><p>函数声明以<code>func</code>关键字开始，后面跟着<code>functionname</code>。参数被指定在<code> (</code> 和 <code>)</code>之间，再往后是函数的<code>returntype</code>。指定参数的语法是，参数类型跟在参数名字后面。任何数量的参数都是可以的，比如：<code>(parameter1 datatype, parameter2 datatype)</code>。然后在<code>&#123;</code> 和 <code>&#125;</code>之间有一个代码块，这是函数体。</p><p>参数和返回值类型在一个函数中都是可选项。因此下面的函数声明也是符合规定的。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">functionname</span><span class="hljs-params">()</span></span> &#123;&#125;</code></pre></div><h3 id="示例函数"><a href="#示例函数" class="headerlink" title="示例函数"></a>示例函数</h3><p>我们来写一个函数，把产品单价和数量作为输入参数，返回这两个值的乘积作为总价。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calculateBill</span><span class="hljs-params">(price <span class="hljs-type">int</span>, quantity <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">var</span> totalPrice = price * quantity<span class="hljs-keyword">return</span> totalPrice&#125;</code></pre></div><p>上面的函数有两个<code>int</code>类型的输入参数<code>price</code>和<code>quantity</code>，它返回<code>totalPrice</code>，这是<code>price</code>和<code>quantity</code>的乘积。返回值也是<code>int</code>类型。</p><p>**如果连着的几个参数是同一种类型，我们可以省去每次都写类型的麻烦，只在最后写一个类型就够了，即<code>price int, quantity int</code> 可以写成<code>price, quantity int</code>。**上面的函数因此可以重写为，</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calculateBill</span><span class="hljs-params">(price, quantity <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">var</span> totalPrice = price * quantity<span class="hljs-keyword">return</span> totalPrice&#125;</code></pre></div><p>现在我们有一个函数就虚了，让我们从代码里的某些地方来调用它。调用函数的语法是<code>functionname(parameters)</code>。上面的函数可以用这个代码调用。</p><div class="code-wrapper"><pre><code class="hljs go">calculateBill(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>)</code></pre></div><p>这是我们用上面的函数打印总价的完整程序。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calculateBill</span><span class="hljs-params">(price, quantity <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">var</span> totalPrice = price * quantity<span class="hljs-keyword">return</span> totalPrice&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;price, quantity := <span class="hljs-number">90</span>, <span class="hljs-number">6</span>totalPrice := calculateBill(price, quantity)fmt.Println(<span class="hljs-string">&quot;Total price is&quot;</span>, totalPrice)&#125;</code></pre></div><p><a href="https://go.dev/play/p/07SsuF0MpDP">Run in playground</a></p><p>上面的程序将会打印</p><div class="code-wrapper"><pre><code class="hljs fallback">Total price is 540</code></pre></div><h3 id="多个返回值"><a href="#多个返回值" class="headerlink" title="多个返回值"></a>多个返回值</h3><p>一个函数返回多个值这种情况也是可能的。让我们写一个函数<code>rectProps</code>，它接受一个矩形的<code>length</code>(长)和<code>width</code>(宽)，返回矩形的<code>area</code>(面积)和<code>perimeter</code>(周长)。举行的面积是长和宽的乘积，周长是长宽之和的两倍。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rectProps</span><span class="hljs-params">(length, width <span class="hljs-type">float64</span>)</span></span>(<span class="hljs-type">float64</span>, <span class="hljs-type">float64</span>) &#123;<span class="hljs-keyword">var</span> area = length * width<span class="hljs-keyword">var</span> perimeter = (length + width) * <span class="hljs-number">2</span><span class="hljs-keyword">return</span> area, perimeter&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123; area, perimeter := rectProps(<span class="hljs-number">10.8</span>, <span class="hljs-number">5.6</span>)fmt.Printf(<span class="hljs-string">&quot;Area %f Perimeter %f&quot;</span>, area, perimeter)&#125;</code></pre></div><p><a href="https://go.dev/play/p/wlUbh-WyOKt">Run in playground</a></p><p>如果一个函数返回多个值，那他们必须被再<code>(</code> 和 <code>)</code>之间被指定。<code>func rectProps(length, width float64)(float64, float64)</code>有两个float64类型的参数<code>length</code>和<code>width</code>，并且返回两个<code>float64</code>类型的值。上面的程序打印</p><div class="code-wrapper"><pre><code class="hljs fallback">Area 60.480000 Perimeter 32.800000</code></pre></div><h3 id="为返回值命名"><a href="#为返回值命名" class="headerlink" title="为返回值命名"></a>为返回值命名</h3><p>从函数中返回一个命名好的值也是可以的。如果返回值被命名，它可以被视为函数第一行的变量。</p><p>上面的rectProps可以用命名返回值重写为</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rectProps</span><span class="hljs-params">(length, width <span class="hljs-type">float64</span>)</span></span>(area, perimeter <span class="hljs-type">float64</span>) &#123;      area = length * width    perimeter = (length + width) * <span class="hljs-number">2</span>    <span class="hljs-keyword">return</span> <span class="hljs-comment">//no explicit return value</span>&#125;</code></pre></div><p><strong>area</strong>和<strong>perimeter</strong>在上面的函数中是被命名的返回值。请注意，函数的返回语句没有显式地返回任何值。因为<code>area</code>和<code>perimeter</code>在函数声明中被指定为返回值，所以当运行到返回语句的时候它们被自动返回了。</p><h3 id="空白标识符"><a href="#空白标识符" class="headerlink" title="空白标识符"></a>空白标识符</h3><p><strong>_</strong> 在Go中是空白标识符。它可以用于代替任何类型的任何值。让我们看看这个空白标识符的作用是什么。</p><p>函数<code>rectProps</code>返回矩形的面积和周长。如果我们只需要<code>area</code>并且想要抛掉<code>perimeter</code>该怎么办呢？这就是<code>_</code>的作用场景。</p><p>下面的程序只使用了<code>rectProps</code>函数返回的<code>area</code>。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rectProps</span><span class="hljs-params">(length, width <span class="hljs-type">float64</span>)</span></span> (<span class="hljs-type">float64</span>, <span class="hljs-type">float64</span>) &#123;<span class="hljs-keyword">var</span> area = length * width<span class="hljs-keyword">var</span> perimeter = (length + width) * <span class="hljs-number">2</span><span class="hljs-keyword">return</span> area, perimeter&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;area, _ := rectProps(<span class="hljs-number">10.8</span>, <span class="hljs-number">5.6</span>) <span class="hljs-comment">// perimeter is discarded</span>fmt.Printf(<span class="hljs-string">&quot;Area %f &quot;</span>, area)&#125;</code></pre></div><p><a href="https://go.dev/play/p/Tw6KYjo5zoI">Run in playground</a></p><p>在第13行，我们只用了<code>area</code>，而<code>_</code>标识符用于抛掉<code>perimeter</code>。</p><p><strong>下一篇教程 - <a href="../_GolangBot%E3%80%917-%E5%8C%85/">包</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GolangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】5-常量</title>
    <link href="/%E3%80%90GolangBot%E3%80%915-%E5%B8%B8%E9%87%8F/"/>
    <url>/%E3%80%90GolangBot%E3%80%915-%E5%B8%B8%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到我们<a href="../golangbot/">Golang系列教程</a>的第五篇。</p><h3 id="什么是常量？"><a href="#什么是常量？" class="headerlink" title="什么是常量？"></a>什么是常量？</h3><p>Go中的常量用于定义固定的值，例如：</p><div class="code-wrapper"><pre><code class="hljs fallback">95 &quot;I love Go&quot; 67.89</code></pre></div><p>等等。常量通常用来表示一个值，这个值在应用的整个生命周期中都不会改变。</p><h3 id="声明一个常量"><a href="#声明一个常量" class="headerlink" title="声明一个常量"></a>声明一个常量</h3><p>关键字<code>const</code>在Go中用来声明一个常量。我们用一个例子来看看如何声明一个常量。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">const</span> a = <span class="hljs-number">50</span>fmt.Println(a)&#125;</code></pre></div><p><a href="https://go.dev/play/p/mv3B-q3h0zh">Run in playground</a></p><p>在上面的代码中，<code>a</code>是一个常量，它被赋值为<code>50</code>。</p><h3 id="定义一组常量"><a href="#定义一组常量" class="headerlink" title="定义一组常量"></a>定义一组常量</h3><p>Go中也有语法用于使用一条语句声明一组常量。下面是用这个语法来声明一组常量的例子。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">const</span> (retryLimit = <span class="hljs-number">4</span>httpMethod = <span class="hljs-string">&quot;GET&quot;</span>)fmt.Println(retryLimit)fmt.Println(httpMethod)&#125;</code></pre></div><p><a href="https://go.dev/play/p/gSPJC0y49Sm">Run in playground</a></p><p>在上面的程序中，我们已经定义了2个常量<code>retryLimit</code>和<code>httpMethod</code>。上面的程序将会打印，</p><div class="code-wrapper"><pre><code class="hljs fallback">4GET</code></pre></div><p>常量，顾名思义，不能被再赋值为其他值。在上面的程序中，我们尝试为<code>a</code>赋值另一个值<code>89</code>。因为<code>a</code>是一个常量，所以这是不允许的。这个程序将会运行失败，报错<code>cannot assign to a (neither addressable nor a map index expression)</code>。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;      <span class="hljs-keyword">const</span> a = <span class="hljs-number">55</span> <span class="hljs-comment">//allowed</span>    a = <span class="hljs-number">89</span> <span class="hljs-comment">//reassignment not allowed</span>&#125;</code></pre></div><p><a href="https://go.dev/play/p/5ggPss1iSsl">Run in playground</a></p><p>**常量的值应该在编译时就已经知道了。**因此，它不能被赋值为<a href="../%E3%80%90GolangBot%E3%80%916-%E5%87%BD%E6%95%B0/">函数调用</a>的值，因为函数调用发生在运行时。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;math&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> a = math.Sqrt(<span class="hljs-number">4</span>) <span class="hljs-comment">//allowed</span>fmt.Println(a)<span class="hljs-keyword">const</span> b = math.Sqrt(<span class="hljs-number">4</span>) <span class="hljs-comment">//not allowed</span>fmt.Println(b)&#125;</code></pre></div><p><a href="https://go.dev/play/p/fFLfoN0L3Nf">Run in playground</a></p><p>在上面的程序中，<code>a</code>是一个<a href="../%E3%80%90GolangBot%E3%80%913-%E5%8F%98%E9%87%8F/">变量</a>，因此它可以被赋值为函数<code>math.Sqrt(4)</code>的结果（我们将在<a href="../%E3%80%90GolangBot%E3%80%916-%E5%87%BD%E6%95%B0/">单独的教程</a>中讨论函数）。</p><p><code>b</code>是一个常量，并且<code>b</code>的值需要在编译时就知道。函数<code>math.Sqrt(4)</code>仅在运行时求值，因此<code>const b = math.Sqrt(4)</code>编译失败，出现错误，</p><div class="code-wrapper"><pre><code class="hljs fallback">./prog.go:11:12: math.Sqrt(4) (value of type float64) is not constant</code></pre></div><h3 id="字符串常量、类型常量和无类型常量"><a href="#字符串常量、类型常量和无类型常量" class="headerlink" title="字符串常量、类型常量和无类型常量"></a>字符串常量、类型常量和无类型常量</h3><p>在Go中任何被双引号包起来的值都是一个字符串常量。例如，像<code>&quot;Hello World&quot;</code>,<code>&quot;Sam&quot;</code>在Go中都是常量。</p><p>一个字符串常量属于什么类型？答案是<strong>无类型。</strong></p><p><strong>一个像”Hello World”的字符串没有任何类型。</strong></p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">const</span> hello = <span class="hljs-string">&quot;Hello World&quot;</span></code></pre></div><p>在上面这行代码中，常量<code>hello</code>没有任何类型。</p><p>Go是强类型语言。所有变量都需要显式的类型。下面的程序中，为变量<code>name</code>赋值无类型的常量<code>n</code>会发生什么？</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">const</span> n = <span class="hljs-string">&quot;Sam&quot;</span><span class="hljs-keyword">var</span> name = nfmt.Printf(<span class="hljs-string">&quot;type %T value %v&quot;</span>, name, name)&#125;</code></pre></div><p><a href="https://go.dev/play/p/CFqbC8yfe6C">Run in playground</a></p><p><strong>答案是无类型常量有一个与之关联的默认类型，只有在某行代码需要时才会提供默认类型。在第9行的语句<code>var name = n</code>中，<code>name</code>需要一个类型，它从<code>string</code>常量<code>n</code>的默认类型中获取</strong></p><p>有没有一种办法可以创建一个<strong>类型常量</strong>？答案是有的。下面的代码创建了一个类型常量。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">const</span> name <span class="hljs-type">string</span> = <span class="hljs-string">&quot;Hello World&quot;</span></code></pre></div><p><em>name</em> 在上面的代码中是一个<code>string</code>类型的常量。</p><p>Go is a strongly typed language. Mixing types during the assignment is not allowed. Let’s see what this means with the help of a program.</p><p>Go是强类型语言。赋值过程中是不允许混合类型的。我们用一个程序来看看这是啥意思。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> defaultName = <span class="hljs-string">&quot;Sam&quot;</span> <span class="hljs-comment">//allowed</span><span class="hljs-keyword">type</span> myString <span class="hljs-type">string</span><span class="hljs-keyword">var</span> customName myString = <span class="hljs-string">&quot;Sam&quot;</span> <span class="hljs-comment">//allowed</span>customName = defaultName        <span class="hljs-comment">//not allowed</span>fmt.Println(customName)&#125;</code></pre></div><p><a href="https://go.dev/play/p/sJ1rCtzebkP">Run in playground</a></p><p>在上面的代码中，我们首先创建了一个变量<code>defaultName</code>，并将常量<code>Sam</code>赋值给他。<strong>常量<code>Sam</code>的默认类型是<code>string</code>，所以在赋值之后，<code>defaultName</code>的类型是<code>string</code>。</strong></p><p>在下一行，我们创建了一个新的类型<code>myString</code>，这是<code>string</code>类型的别称。</p><p>然后我们创建一个<code>myString</code>类型的变量<code>customName</code>，并且将常量<code>Sam</code>赋值给它。因为常量<code>Sam</code>是无类型的，它可以被赋值给任意<code>string</code>类型的变量。因此这个赋值操作是允许的，<code>customName</code>得到类型<code>myString</code>。</p><p>现在我们有一个<code>string</code>类型的变量<code>defalutName</code>，另一个<code>myString</code>类型的变量<code>customName</code>。尽管我们知道<code>myString</code>是<code>string</code>的别名，Go的强类型规则不允许将一种类型的值赋值给另外一种类型。<strong>因此赋值操作<code>customName = defaultName</code>是不被允许的，编译操作会抛出一个错误：<code>./prog.go:9:15: cannot use defaultName (variable of type string) as myString value in assignment</code></strong></p><p>为了让上面的程序正常工作，<code>defalutName</code>必须被转换为<code>myString</code>类型。这在下面的程序中的第9行进行操作。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> defaultName = <span class="hljs-string">&quot;Sam&quot;</span> <span class="hljs-comment">//allowed</span><span class="hljs-keyword">type</span> myString <span class="hljs-type">string</span><span class="hljs-keyword">var</span> customName myString = <span class="hljs-string">&quot;Sam&quot;</span>    <span class="hljs-comment">//allowed</span>customName = myString(defaultName) <span class="hljs-comment">//allowed</span>fmt.Println(customName)&#125;</code></pre></div><p><a href="https://go.dev/play/p/EObC2BTq4KW">Run in playground</a></p><p>上面的程序将会打印<code>Sam</code>。</p><h3 id="布尔型常量"><a href="#布尔型常量" class="headerlink" title="布尔型常量"></a>布尔型常量</h3><p>布尔型常量和字符串常量没有什么区别。它们是两个无类型的常量<code>true</code>和<code>false</code>。字符串常量的规则对于布尔型常量也同样适用，所以我们就不再赘述了。下面是一个简单的程序来解释布尔型常量。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">const</span> trueConst = <span class="hljs-literal">true</span><span class="hljs-keyword">type</span> myBool <span class="hljs-type">bool</span><span class="hljs-keyword">var</span> defaultBool = trueConst <span class="hljs-comment">//allowed</span><span class="hljs-keyword">var</span> customBool myBool = trueConst <span class="hljs-comment">//allowed</span>defaultBool = customBool <span class="hljs-comment">//not allowed</span>&#125;</code></pre></div><p><a href="https://go.dev/play/p/YWZ80x94Q1D">Run in playground</a></p><p>The above program is self-explanatory.</p><p>上面的程序是不言自明的。</p><h3 id="数字常量"><a href="#数字常量" class="headerlink" title="数字常量"></a>数字常量</h3><p>数字常量包括整数、浮点数和复数。数字常量有一些细节需要注意。</p><p>让我们举一些例子来说明问题。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">const</span> c = <span class="hljs-number">5</span><span class="hljs-keyword">var</span> intVar <span class="hljs-type">int</span> = c<span class="hljs-keyword">var</span> int32Var <span class="hljs-type">int32</span> = c<span class="hljs-keyword">var</span> float64Var <span class="hljs-type">float64</span> = c<span class="hljs-keyword">var</span> complex64Var <span class="hljs-type">complex64</span> = cfmt.Println(<span class="hljs-string">&quot;intVar&quot;</span>, intVar, <span class="hljs-string">&quot;\nint32Var&quot;</span>, int32Var, <span class="hljs-string">&quot;\nfloat64Var&quot;</span>, float64Var, <span class="hljs-string">&quot;\ncomplex64Var&quot;</span>, complex64Var)&#125;</code></pre></div><p><a href="https://go.dev/play/p/9MzdS-nmA1Z">Run in playground</a></p><p>在上面的程序中，常量<code>c</code>是<code>untyped</code>类型并且有一个值<code>5</code>。**你也许想知道c的默认类型是什么，以及如果它确实有默认类型，我们又该如何将其赋值给其他不同类型的变量。**答案就在<code>c</code>的语法当中。下面的程序将会让这个问题更加清晰。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> i = <span class="hljs-number">5</span><span class="hljs-keyword">var</span> f = <span class="hljs-number">5.6</span><span class="hljs-keyword">var</span> c = <span class="hljs-number">5</span> + <span class="hljs-number">6i</span>fmt.Printf(<span class="hljs-string">&quot;i&#x27;s type is %T, f&#x27;s type is %T, c&#x27;s type is %T&quot;</span>, i, f, c)&#125;</code></pre></div><p><a href="https://go.dev/play/p/XVEGb9aUsxs">Run in playground</a></p><p>在上面的程序中，每个变量的类型都被数字常量的语法所定义。根据语法，<strong>5</strong>是一个整数，<strong>5.6</strong>是一个浮点数，<strong>5 + 6i</strong>是一个复数。上面的程序运行会打印</p><div class="code-wrapper"><pre><code class="hljs fallback">i&#x27;s type is int, f&#x27;s type is float64, c&#x27;s type is complex128</code></pre></div><p>知道了这些，我们来试着理解下面的程序会如何工作。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">const</span> c = <span class="hljs-number">5</span><span class="hljs-keyword">var</span> intVar <span class="hljs-type">int</span> = c<span class="hljs-keyword">var</span> int32Var <span class="hljs-type">int32</span> = c<span class="hljs-keyword">var</span> float64Var <span class="hljs-type">float64</span> = c<span class="hljs-keyword">var</span> complex64Var <span class="hljs-type">complex64</span> = cfmt.Println(<span class="hljs-string">&quot;intVar&quot;</span>, intVar, <span class="hljs-string">&quot;\nint32Var&quot;</span>, int32Var, <span class="hljs-string">&quot;\nfloat64Var&quot;</span>, float64Var, <span class="hljs-string">&quot;\ncomplex64Var&quot;</span>, complex64Var)&#125;</code></pre></div><p><a href="https://go.dev/play/p/9MzdS-nmA1Z">Run in playground</a></p><p>在上面的程序中，<code>c</code>的值是<code>5</code>并且<code>c</code>的语法是通用语法。它可以表示浮点数、整数，甚至是无虚部复数。因此它可以赋值给任意兼容类型。可以认为，这些类型的常量的默认类型是由它们所使用的上下文生成的。<code>var intVar int = c</code>需要<code>c</code>是<code>int</code>类型，所以它变成了一个<code>int</code>常量。<code>var complex64Var complex64 = c</code>需要<code>c</code>是复数类型，因此它变成一个复数常量。以此类推:)。</p><h3 id="数字表达式"><a href="#数字表达式" class="headerlink" title="数字表达式"></a>数字表达式</h3><p>数字常量可以在表达式中自由混合和匹配，只有当它们赋值给变量或者用于需要类型的代码中才需要类型。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> a = <span class="hljs-number">5.9</span> / <span class="hljs-number">8</span>fmt.Printf(<span class="hljs-string">&quot;a&#x27;s type is %T and value is %v&quot;</span>, a, a)&#125;</code></pre></div><p><a href="https://go.dev/play/p/Nsak9scUAWg">Run in playground</a></p><p>在上面的程序中，<code>5.9</code>语法上是一个浮点数，<code>8</code>语法上是一个整数。不过，由于两者都是数字常量，因此<code>5.9/8</code>是被允许的。相除后的结果是<code>0.7375</code>是一个浮点数<code>float</code>。程序的输出是</p><div class="code-wrapper"><pre><code class="hljs fallback">a&#x27;s type is float64 and value is 0.7375</code></pre></div><p><strong>下一篇教程 - <a href="../_posts/%E3%80%90GolangBot%E3%80%916-%E5%87%BD%E6%95%B0/">函数</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GolangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】4-数据类型</title>
    <link href="/%E3%80%90GolangBot%E3%80%914-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/%E3%80%90GolangBot%E3%80%914-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>这是我们<a href="../golangbot/">Golang系列教程</a>的第四篇.</p><p>请阅读<a href="../%E3%80%90GolangBot%E3%80%913-%E5%8F%98%E9%87%8F/">第三部分：变量</a>来学习变量。</p><p>下面是Go中可用的基本类型。</p><ul><li>bool</li><li>Numeric Types<ul><li>int8, int16, int32, int64, int</li><li>uint8, uint16, uint32, uint64, uint</li><li>float32, float64</li><li>complex64, complex128</li><li>byte</li><li>rune</li></ul></li><li>string</li></ul><h3 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h3><p><code>bool</code>类型表示布尔值。它要么是<code>true</code>要么是<code>false</code>。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main  <span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;      a := <span class="hljs-literal">true</span>    b := <span class="hljs-literal">false</span>    fmt.Println(<span class="hljs-string">&quot;a:&quot;</span>, a, <span class="hljs-string">&quot;b:&quot;</span>, b)    c := a &amp;&amp; b    fmt.Println(<span class="hljs-string">&quot;c:&quot;</span>, c)    d := a || b    fmt.Println(<span class="hljs-string">&quot;d:&quot;</span>, d)&#125;</code></pre></div><p><a href="https://go.dev/play/p/v_W3HQ0MdY">Run in playground</a></p><p>在上面的程序中，a被分配了<code>true</code>,b被分配了<code>false</code>。</p><p><code>&amp;&amp;</code>是一个布尔操作符，当两个操作数都为true的时候才返回true。</p><p>c被分配了值<code>a &amp;&amp; b</code>。在这个示例中，<code>c</code>是<code>false</code>，因为<code>a</code>和<code>b</code>不都为<code>true</code>。</p><p><code>||</code>操作符当<code>a</code>或<code>b</code>有一个为<code>true</code>的时候返回true。在这个示例中，<code>d</code>为<code>true</code>，因为<code>a</code>是true。这个程序我们将会得到下面的输出。</p><div class="code-wrapper"><pre><code class="hljs fallback">a: true b: falsec: falsed: true</code></pre></div><h3 id="带符号整数"><a href="#带符号整数" class="headerlink" title="带符号整数"></a>带符号整数</h3><p>下面是在go中可用的带符号整数数据类型。</p><table><thead><tr><th>数据类型</th><th>描述</th><th>大小</th><th>范围</th></tr></thead><tbody><tr><td>int8</td><td>8 bit 带符号整数</td><td>8 bits</td><td>-128 to 127</td></tr><tr><td>int16</td><td>16 bit 带符号整数</td><td>16 bits</td><td>-32768 to 32767</td></tr><tr><td>int32</td><td>32 bit 带符号整数</td><td>32 bits</td><td>-2147483648 to 2147483647</td></tr><tr><td>int64</td><td>64 bit 带符号整数</td><td>64 bits</td><td>-9223372036854775808 to 9223372036854775807</td></tr><tr><td>int</td><td>表示32bit或64bit整数，取决于底层架构。通常应该用<code>int</code>表示整数，除非有需要使用特定大小的整数。</td><td>32位系统中 32 bits ，64位系统中64 bits .</td><td>在32位系统中：-2147483648 to 2147483647  <br />在64位系统中：<br />-9223372036854775808 to 9223372036854775807</td></tr></tbody></table><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> a <span class="hljs-type">int</span> = <span class="hljs-number">89</span>b := <span class="hljs-number">95</span>fmt.Println(<span class="hljs-string">&quot;value of a is&quot;</span>, a, <span class="hljs-string">&quot;and b is&quot;</span>, b)&#125;</code></pre></div><p><a href="https://go.dev/play/p/Up5vcjHyunS">Run in playground</a></p><p>上面的程序将会打印</p><div class="code-wrapper"><pre><code class="hljs fallback">value of a is 89 and b is 95</code></pre></div><p>在上面的程序中，<code>a</code>是<code>int</code>类型，<code>b</code>的类型是根据分配给它的值(95)推断出来的。如上所述，int的尺寸是<em>32位系统中 32 bits ，64位系统中64 bits</em>。让我们继续验证这个说法。</p><p>一个变量的类型可以使用<code>Printf</code>函数中的<code>%T</code>格式指定符来打印出来。Go有一个<a href="https://pkg.go.dev/unsafe">unsafe</a>包，其中有一个<a href="https://pkg.go.dev/unsafe#Sizeof">Sizeof</a>函数，它可以返回以字节为单位的变量大小。<em>unsafe</em>包应该谨慎使用，因为它可能存在可移植性问题。但出于教程目的，我们可以使用它。</p><p>下面的程序输出了变量<code>a</code>和<code>b</code>的类型和大小。<code>%T</code>是一个格式指定符用来打印类型，<code>%d</code>用来打印大小。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;unsafe&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> a = <span class="hljs-number">89</span>b := <span class="hljs-number">95</span>fmt.Println(<span class="hljs-string">&quot;value of a is&quot;</span>, a, <span class="hljs-string">&quot;and b is&quot;</span>, b)fmt.Printf(<span class="hljs-string">&quot;type of a is %T, size of a is %d bytes&quot;</span>, a, unsafe.Sizeof(a))   <span class="hljs-comment">//type and size of a</span>fmt.Printf(<span class="hljs-string">&quot;\ntype of b is %T, size of b is %d bytes&quot;</span>, b, unsafe.Sizeof(b)) <span class="hljs-comment">//type and size of b</span>&#125;</code></pre></div><p><a href="https://go.dev/play/p/fAIGqDZGm7C">Run in playground</a></p><p>上面的程序将会打印如下输出。</p><div class="code-wrapper"><pre><code class="hljs fallback">value of a is 89 and b is 95type of a is int, size of a is 8 bytestype of b is int, size of b is 8 bytes</code></pre></div><p>我们可以从上面的输出中推断出<code>a</code>和<code>b</code>都是<code>int</code>类型，并且它们有8字节大小(64bits)。当你在32位系统运行上述程序时，结果会有所不同。在32位系统，a和b占4字节(32bits)。</p><h3 id="无符号整数"><a href="#无符号整数" class="headerlink" title="无符号整数"></a>无符号整数</h3><p>顾名思义，无符号整数只能用于存储正整数。以下是Go中可用的无符号整数数据类型。</p><table><thead><tr><th>数据类型</th><th>描述</th><th>大小</th><th>范围</th></tr></thead><tbody><tr><td>uint8</td><td>8 bit 无符号整数</td><td>8 bits</td><td>0 to 255</td></tr><tr><td>uint16</td><td>16 bit 无符号整数</td><td>16 bits</td><td>0 to 65535</td></tr><tr><td>uint32</td><td>32 bit 无符号整数</td><td>32 bits</td><td>0 to 4294967295</td></tr><tr><td>uint64</td><td>64 bit 无符号整数</td><td>64 bits</td><td>0 to 18446744073709551615</td></tr><tr><td>uint</td><td>取决于底层架构，32 or 64 bit 无符号整数</td><td>32位系统上32 bits;64位系统上64 bits</td><td>0 to 4294967295 in 32 bit systems and 0 to 18446744073709551615 in 64 bit systems</td></tr></tbody></table><p>无符号整数用于不需要使用负数的场景。</p><p>在下面的程序中，变量<code>a</code>和<code>b</code>是<code>uint</code>类型。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> a <span class="hljs-type">uint</span> = <span class="hljs-number">60</span><span class="hljs-keyword">var</span> b <span class="hljs-type">uint</span> = <span class="hljs-number">30</span>c := a * bfmt.Println(<span class="hljs-string">&quot;c =&quot;</span>, c)fmt.Printf(<span class="hljs-string">&quot;Data type of variable c is %T&quot;</span>, c)&#125;</code></pre></div><p><a href="https://go.dev/play/p/5CKH28Wl_k6">Run in playground</a></p><p>上面的程序打印结果</p><div class="code-wrapper"><pre><code class="hljs fallback">1c = 18002Data type of variable c is uint</code></pre></div><p>因为<code>a</code>和<code>b</code>都是<code>uint</code>类型，所以推断<code>c</code>的类型也是<code>uint</code>。</p><h3 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h3><table><thead><tr><th>数据类型</th><th>Description</th></tr></thead><tbody><tr><td>float32</td><td>32 bit 浮点数</td></tr><tr><td>float64</td><td>64 bit 浮点数</td></tr></tbody></table><p>下面是一个简单的程序，用来说明整数和浮点数类型。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a, b := <span class="hljs-number">5.67</span>, <span class="hljs-number">8.97</span>fmt.Printf(<span class="hljs-string">&quot;type of a %T b %T\n&quot;</span>, a, b)sum := a + bdiff := a - bfmt.Printf(<span class="hljs-string">&quot;sum of %f and %f is %f, diff is %f\n&quot;</span>, a, b, sum, diff)no1, no2 := <span class="hljs-number">56</span>, <span class="hljs-number">89</span>fmt.Printf(<span class="hljs-string">&quot;type of no1 %T no2 %T\n&quot;</span>, no1, no2)fmt.Printf(<span class="hljs-string">&quot;sum of %d and %d is %d, diff is %d&quot;</span>, no1, no2, no1+no2, no1-no2)&#125;</code></pre></div><p><a href="https://go.dev/play/p/ST637417mye">Run in playground</a></p><p><code>a</code>和<code>b</code>的类型是从分配给它们的值推断出来的。在这个例子里面，<code>a</code>和<code>b</code>是<code>float64</code>类型。<code>float64</code>是浮点值的默认类型。我们把<code>a</code>和<code>b</code>相加，然后把结果分配给变量<code>sum</code>。我们用<code>a</code>减去<code>b</code>，然后把结果分配给变量<code>diff</code>。把<code>sum</code>和<code>diff</code>打印出来。相似的计算在<code>no1</code>和<code>no2</code>中进行。上面的程序将会打印,</p><div class="code-wrapper"><pre><code class="hljs fallback">type of a float64 b float64sum of 5.670000 and 8.970000 is 14.640000, diff is -3.300000type of no1 int no2 intsum of 56 and 89 is 145, diff is -33</code></pre></div><h3 id="复数类型"><a href="#复数类型" class="headerlink" title="复数类型"></a>复数类型</h3><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>complex64</td><td>具有float32类型的实部和虚部的复数</td></tr><tr><td>complex128</td><td>具有float64类型的实部和虚部的复数</td></tr></tbody></table><p>标准库函数**<a href="https://pkg.go.dev/builtin#complex">complex</a>**用于构建具有实部和虚部的复数。complex函数具有如下定义</p><div class="code-wrapper"><pre><code class="hljs fallback">func complex(r, i FloatType) ComplexType</code></pre></div><p>它将实部和虚部作为参数并返回复数类型。<em>实部和虚部必须是相同的数据类型，即float32或float64。如果实部和虚部都是float32，函数将返回complex64类型的复数值。如果实部和虚部都是float64，则此函数返回complex128类型的复数值。</em></p><p>复数类型也可以使用短语法创建。</p><div class="code-wrapper"><pre><code class="hljs fallback">c := 6 + 7i</code></pre></div><p>让我们写一个小程序来理解复数。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;c1 := <span class="hljs-built_in">complex</span>(<span class="hljs-number">5</span>, <span class="hljs-number">7</span>)c2 := <span class="hljs-number">8</span> + <span class="hljs-number">27i</span>cadd := c1 + c2fmt.Println(<span class="hljs-string">&quot;sum:&quot;</span>, cadd)cmul := c1 * c2fmt.Println(<span class="hljs-string">&quot;product:&quot;</span>, cmul)&#125;</code></pre></div><p><a href="https://go.dev/play/p/-d_Y_medfSb">Run in playground</a></p><p>在上面的程序中，c1和c2是两个复数。c1有5作为实部，7作为虚部。c2有8作为实部，27作为虚部。<code>cadd</code>被指定为c1和c2的和，<code>cmul</code>被指定为c1和c2的乘积。这个程序将会输出</p><div class="code-wrapper"><pre><code class="hljs fallback">sum: (13+34i)product: (-149+191i)</code></pre></div><h3 id="其他数字类型"><a href="#其他数字类型" class="headerlink" title="其他数字类型"></a>其他数字类型</h3><p><strong>byte</strong> 是uint8的别名。<br><strong>rune</strong> 是int32的别名。</p><p>我们将会在学习<a href="../%E3%80%90GolangBot%E3%80%9114-Strings/">strings</a>的时候详细讨论bytes和runes。</p><h3 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h3><p>Strings在Go中是bytes的集合。如果这个定义没有任何意义也没有关系。现在，我们可以假定字符串是字符的集合。我们将在单独的<a href="../%E3%80%90GolangBot%E3%80%9114-Strings/">strings教程</a>中详细了解字符串。</p><p>让我们用字符串写一个程序。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;first := <span class="hljs-string">&quot;Naveen&quot;</span>last := <span class="hljs-string">&quot;Ramanathan&quot;</span>name := first +<span class="hljs-string">&quot; &quot;</span>+ lastfmt.Println(<span class="hljs-string">&quot;My name is&quot;</span>,name)&#125;</code></pre></div><p><a href="https://go.dev/play/p/kYnedsD6OmN">Run in playground</a></p><p>在上面的程序中，<code>first</code>被指定为字符串<code>Naveen</code>，<code>last</code>被指定为字符串<code>Ramanathan</code>。可以使用<code>+</code>运算符连接字符串。<code>name</code>的值为<code>first</code>，后加空格，最后加<code>last</code>。上述程序将打印</p><div class="code-wrapper"><pre><code class="hljs fallback">1My name is Naveen Ramanathan</code></pre></div><p>作为输出结果。</p><p>还可以对字符串执行更多操作。我们将在单独的教程中讨论这些内容。</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>Go对于显式输入非常严格。没有自动类型提升或者转换。让我们用一个例子来看一下这是什么意思。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := <span class="hljs-number">80</span>      <span class="hljs-comment">//int</span>b := <span class="hljs-number">91.8</span>    <span class="hljs-comment">//float64</span>sum := a + b <span class="hljs-comment">//int + float64 not allowed</span>fmt.Println(sum)&#125;</code></pre></div><p><a href="https://go.dev/play/p/Fo537OgUC2B">Run in playground</a></p><p>上面的代码在C语言中是完全合法的，但在<code>Go</code>当中，这个程序无法编译。<code>a</code>是一个<code>int</code>类型的变量，<code>b</code>是一个<code>float64</code>类型的变量。我们尝试将两个不同类型的数字相加，这是不允许的。当你运行这个程序，你将会看到如下的编译错误</p><div class="code-wrapper"><pre><code class="hljs fallback">1./prog.go:10:9: invalid operation: a + b (mismatched types int and float64)</code></pre></div><p>To fix the error, both <code>a</code> and <code>b</code> must be of the same type. Let’s convert <code>b</code> to <code>int</code>. <em>T(v) is the syntax to convert a value v to type T</em></p><p>为了修复这个错误，<code>a</code>和<code>b</code>必须是相同类型。让我们把<code>b</code>转换为<code>int</code>。<em>T(v) 是将值v转换为T类型的语法</em></p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := <span class="hljs-number">80</span>           <span class="hljs-comment">//int</span>b := <span class="hljs-number">91.8</span>         <span class="hljs-comment">//float64</span>sum := a + <span class="hljs-type">int</span>(b) <span class="hljs-comment">//int + float64 not allowed</span>fmt.Println(sum)&#125;</code></pre></div><p><a href="https://go.dev/play/p/Yc00DWzrYl8">Run in playground</a></p><p>因为<code>b</code>从<code>float</code>被转换为了<code>int</code>，它的浮点值将会被截断，因此我们将会看到<code>171</code>作为输出。</p><p>赋值的情况也是如此。奖一种类型的变量赋值给另一种类型的变量时，需要进行显式类型转换。下面的程序对此进行了解释。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;i := <span class="hljs-number">10</span><span class="hljs-keyword">var</span> j <span class="hljs-type">float64</span> = <span class="hljs-type">float64</span>(i) <span class="hljs-comment">//this statement will not work without explicit conversion</span>fmt.Println(<span class="hljs-string">&quot;j =&quot;</span>, j)&#125;</code></pre></div><p><a href="https://go.dev/play/p/Dia3qOrRi_j">Run in playground</a></p><p>在第9行,<code>i</code>被转换为了<code>float64</code>，然后赋值给了<code>j</code>。但你尝试在不进行类型转换的情况下，将<code>i</code>赋值给<code>j</code>时，编译器将会抛出一个错误。</p><p><strong>下一篇教程 - <a href="../%E3%80%90GolangBot%E3%80%915-%E5%B8%B8%E9%87%8F/">常量</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GolangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】3-变量</title>
    <link href="/%E3%80%90GolangBot%E3%80%913-%E5%8F%98%E9%87%8F/"/>
    <url>/%E3%80%90GolangBot%E3%80%913-%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<p>这是我们<a href="../golangbot/">Golang系列教程</a>的第三篇，这篇我们来处理Golang中的变量。</p><p>你可以阅读<a href="../%E3%80%90GolangBot%E3%80%912-Hello-World/">第二部分</a>来学习配置Go，运行Hello World程序。</p><h3 id="什么是变量？"><a href="#什么是变量？" class="headerlink" title="什么是变量？"></a>什么是变量？</h3><p>变量是给内存位置的名称，用来存储特定<a href="../%E3%80%90GolangBot%E3%80%914-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">类型</a>的值。Go中有多种语法来声明变量。我们来逐一查看。</p><h3 id="声明单个变量"><a href="#声明单个变量" class="headerlink" title="声明单个变量"></a>声明单个变量</h3><p><strong>var name type</strong> 是声明单个变量的语法。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> age <span class="hljs-type">int</span> <span class="hljs-comment">// variable declaration</span>fmt.Println(<span class="hljs-string">&quot;My initial age is&quot;</span>, age)&#125;</code></pre></div><p><a href="https://go.dev/play/p/5sC9oz7j_lR">Run in playground</a></p><p><code>var age int</code>语法定义了一个名为<code>age</code>，类型为<code>int</code>的变量。我们还没有给这个变量分配任何值。如果一个没有被分配任何值，Go会自动用变量类型的零值来为它赋值。在这个例子中，age被分配值为0，0是<code>int</code>类型的零值。如果你运行这个程序，你会看到如下输出。</p><div class="code-wrapper"><pre><code class="hljs fallback">My initial age is 0</code></pre></div><p>一个变量可以被分配它类型的任意值。在上面的程序中，<code>age</code>可以被分配任意的整型值。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> age <span class="hljs-type">int</span> <span class="hljs-comment">// variable declaration</span>fmt.Println(<span class="hljs-string">&quot;My initial age is&quot;</span>, age)age = <span class="hljs-number">29</span> <span class="hljs-comment">//assignment</span>fmt.Println(<span class="hljs-string">&quot;My age after first assignment is&quot;</span>, age)age = <span class="hljs-number">54</span> <span class="hljs-comment">//assignment</span>fmt.Println(<span class="hljs-string">&quot;My age after second assignment is&quot;</span>, age)&#125;</code></pre></div><p><a href="https://go.dev/play/p/6olrLC2kBTB">Run in playground</a></p><p>上面的程序将会打印如下内容。</p><div class="code-wrapper"><pre><code class="hljs fallback">My initial age is 0My age after first assignment is 29My age after second assignment is 54</code></pre></div><h3 id="声明一个带初始值的变量"><a href="#声明一个带初始值的变量" class="headerlink" title="声明一个带初始值的变量"></a>声明一个带初始值的变量</h3><p>当一个变量被声明时，也可以初始化一个值。下面是声明一个带初始值的变量的语法。</p><p>A variable can also be initialized with a value when it is declared. The following is the syntax to declare a variable with an initial value.</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> name <span class="hljs-keyword">type</span> = initialvalue</code></pre></div><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> age <span class="hljs-type">int</span> = <span class="hljs-number">29</span> <span class="hljs-comment">// variable declaration with initial value</span>fmt.Println(<span class="hljs-string">&quot;My initial age is&quot;</span>, age)&#125;</code></pre></div><p><a href="https://go.dev/play/p/17Py5gyLc87">Run in playground</a></p><p>在上面的程序中，<code>age</code>是一个<code>int</code>型变量，有初始值<code>29</code>。上面的程序会打印如下输出。</p><div class="code-wrapper"><pre><code class="hljs fallback">My initial age is 29</code></pre></div><p>这证实了age已被初始化为值29.</p><h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>如果一个变量有一个初始值，Go能够自动根据初始值推断出该变量的类型。因此如果变量有一个初始值，变量声明中的<code>type</code>就可以去掉。</p><p>如果变量是用下面的语法声明</p><div class="code-wrapper"><pre><code class="hljs fallback">var name = initialvalue</code></pre></div><p>Go会自动从初始值推断出变量的类型。</p><p>在下面的例子中，我们可以看到第6行变量<code>age</code>的类型<code>int</code>已经被去掉了。因为变量有一个初始值<code>29</code>，Go可以推断出它是<code>int</code>类型。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> age = <span class="hljs-number">29</span> <span class="hljs-comment">// type will be inferred</span>fmt.Println(<span class="hljs-string">&quot;My initial age is&quot;</span>, age)&#125;</code></pre></div><p><a href="https://go.dev/play/p/3ybtHsu6uLk">Run in playground</a></p><h3 id="多变量声明"><a href="#多变量声明" class="headerlink" title="多变量声明"></a>多变量声明</h3><p>多个变量可以用一条语句进行声明。</p><p><strong>var name1, name2 type &#x3D; initialvalue1, initialvalue2</strong> 是多变量声明的语法。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> price, quantity <span class="hljs-type">int</span> = <span class="hljs-number">5000</span>, <span class="hljs-number">100</span> <span class="hljs-comment">//declaring multiple variables</span>fmt.Println(<span class="hljs-string">&quot;price is&quot;</span>, price, <span class="hljs-string">&quot;quantity is&quot;</span>, quantity)&#125;</code></pre></div><p><a href="https://go.dev/play/p/ik6-iRcjggI">Run in playground</a></p><p>如果变量有初始值，类型可以去掉。因为上面的程序中，变量有初始值，类型<code>int</code>可以去掉。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> price, quantity = <span class="hljs-number">5000</span>, <span class="hljs-number">100</span> <span class="hljs-comment">//declaring multiple variables with type inference</span>fmt.Println(<span class="hljs-string">&quot;price is&quot;</span>, price, <span class="hljs-string">&quot;quantity is&quot;</span>, quantity)&#125;</code></pre></div><p><a href="https://go.dev/play/p/cwD5TmYG2Nf">Run in playground</a></p><p>上面的程序将会打印</p><div class="code-wrapper"><pre><code class="hljs fallback">price is 5000 quantity is 100</code></pre></div><p>现在也许你已经猜到了，如果初始值未指定<code>price</code>和<code>quanlity</code>的初始值，它们的初始值将是<code>0</code>。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> price, quantity <span class="hljs-type">int</span>fmt.Println(<span class="hljs-string">&quot;price is&quot;</span>, price, <span class="hljs-string">&quot;quantity is&quot;</span>, quantity)price = <span class="hljs-number">3000</span>quantity = <span class="hljs-number">500</span>fmt.Println(<span class="hljs-string">&quot;new price is&quot;</span>, price, <span class="hljs-string">&quot;new quantity is&quot;</span>, quantity)&#125;</code></pre></div><p><a href="https://go.dev/play/p/W2zBg9dNzNA">Run in playground</a></p><p>上面的程序将会打印</p><div class="code-wrapper"><pre><code class="hljs fallback">price is 0 quantity is 0new price is 3000 new quantity is 500</code></pre></div><p>有一种情况，我们可能会想要在一条语句中定义多个变量，并且它们属于不同的数据类型。这么做的语法是</p><div class="code-wrapper"><pre><code class="hljs fallback">var (      name1 = initialvalue1      name2 = initialvalue2)</code></pre></div><p>下面的程序使用了上面的语法来声明不同类型的变量。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> (name   = <span class="hljs-string">&quot;Naveen&quot;</span>age    = <span class="hljs-number">38</span>height <span class="hljs-type">int</span>)fmt.Println(<span class="hljs-string">&quot;my name is&quot;</span>, name)fmt.Println(<span class="hljs-string">&quot;my age is&quot;</span>, age)fmt.Println(<span class="hljs-string">&quot;my height is&quot;</span>, height)&#125;</code></pre></div><p><a href="https://go.dev/play/p/UMeFO9KoV-U">Run in playground</a></p><p>这里我们声明了一个<code>string</code>类型的变量<code>name</code>，<code>int</code>类型的<code>age</code>和<code>height</code>。(我们将会在<a href="../%E3%80%90GolangBot%E3%80%914-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">下一篇</a>讨论Golang中不同类型的变量)</p><p>运行上面的程序将会打印。</p><div class="code-wrapper"><pre><code class="hljs fallback">my name is Naveenmy age is 38my height is 0</code></pre></div><h3 id="简短声明"><a href="#简短声明" class="headerlink" title="简短声明"></a>简短声明</h3><p>Go也提供了另一种简短的声明变量方式。这就是所谓的简短声明，它使用<code>:=</code>操作符。</p><p><strong>name :&#x3D; initialvalue</strong> 是声明一个变量的简短语法。</p><p>下面的程序使用了简短语法声明了一个初始化为<code>10</code>的变量<code>count</code>。Go会自动推断出<code>count</code>是<code>int</code>类型，因为它被整型值<code>10</code>初始化。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;count := <span class="hljs-number">10</span>fmt.Println(<span class="hljs-string">&quot;Count =&quot;</span>,count)&#125;</code></pre></div><p><a href="https://go.dev/play/p/9X5FGM0QYxS">Run in playground</a></p><p>上面的程序将会打印，</p><div class="code-wrapper"><pre><code class="hljs fallback">Count = 10</code></pre></div><p>使用简短声明语法声明多个变量也是可以的。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;name, age := <span class="hljs-string">&quot;Naveen&quot;</span>, <span class="hljs-number">29</span> <span class="hljs-comment">//short hand declaration</span>fmt.Println(<span class="hljs-string">&quot;my name is&quot;</span>, name)fmt.Println(<span class="hljs-string">&quot;my age is&quot;</span>, age)&#125;</code></pre></div><p><a href="https://go.dev/play/p/t_leq8orwxL">Run in playground</a></p><p>上面的程序声明了两个变量<code>name</code>和<code>age</code>，它们分别是<code>string</code>和<code>int</code>类型。</p><p>如果你运行上面的程序，你将会看到下面的内容被打印。</p><div class="code-wrapper"><pre><code class="hljs fallback">my name is Naveenmy age is 29</code></pre></div><p>简短声明要求赋值左侧的所有变量都有初始值。下面的程序将会打印错误<code>assignment mismatch: 2 variables but 1 value</code>。这是因为<strong>age没有被分配值</strong>。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;name, age := <span class="hljs-string">&quot;Naveen&quot;</span> <span class="hljs-comment">//error</span>fmt.Println(<span class="hljs-string">&quot;my name is&quot;</span>, name, <span class="hljs-string">&quot;age is&quot;</span>, age)&#125;</code></pre></div><p><a href="https://go.dev/play/p/kM93hDPatVP">Run in playground</a></p><p>简短声明只能在**:&#x3D;**左边至少有一个新声明的变量时才可以使用。看一下下面的程序，</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a, b := <span class="hljs-number">20</span>, <span class="hljs-number">30</span> <span class="hljs-comment">// declare variables a and b</span>fmt.Println(<span class="hljs-string">&quot;a is&quot;</span>, a, <span class="hljs-string">&quot;b is&quot;</span>, b)b, c := <span class="hljs-number">40</span>, <span class="hljs-number">50</span> <span class="hljs-comment">// b is already declared but c is new</span>fmt.Println(<span class="hljs-string">&quot;b is&quot;</span>, b, <span class="hljs-string">&quot;c is&quot;</span>, c)b, c = <span class="hljs-number">80</span>, <span class="hljs-number">90</span> <span class="hljs-comment">// assign new values to already declared variables b and c</span>fmt.Println(<span class="hljs-string">&quot;changed b is&quot;</span>, b, <span class="hljs-string">&quot;c is&quot;</span>, c)&#125;</code></pre></div><p><a href="https://go.dev/play/p/V2aMZKS5Kpj">Run in playground</a></p><p>在上面的程序中，第8行，<strong>b</strong>已经被声明过了，而<strong>c</strong>是新声明的，因此它可以正常运行并且输出。</p><div class="code-wrapper"><pre><code class="hljs fallback">a is 20 b is 30b is 40 c is 50changed b is 80 c is 90</code></pre></div><p>而如果我们运行下面的程序，</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a, b := <span class="hljs-number">20</span>, <span class="hljs-number">30</span> <span class="hljs-comment">//a and b declared</span>fmt.Println(<span class="hljs-string">&quot;a is&quot;</span>, a, <span class="hljs-string">&quot;b is&quot;</span>, b)a, b := <span class="hljs-number">40</span>, <span class="hljs-number">50</span> <span class="hljs-comment">//error, no new variables</span>&#125;</code></pre></div><p><a href="https://go.dev/play/p/SYyrrmPHMG_F">Run in playground</a></p><p>它会打印错误<code>./prog.go:8:7: no new variables on left side of :=</code>。这是因为变量<strong>a</strong>和<strong>b</strong>都已经被定义过，并且第8行**:&#x3D;**左边没有新变量了。</p><p>变量也可以分配值，这些值时在运行时计算得出的。请看下面的程序，</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;math&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a, b := <span class="hljs-number">145.8</span>, <span class="hljs-number">543.8</span>c := math.Min(a, b)fmt.Println(<span class="hljs-string">&quot;Minimum value is&quot;</span>, c)&#125;</code></pre></div><p><a href="https://go.dev/play/p/SVQ2RGT7JuP">Run in playground</a></p><p>在上面的程序中，<a href="https://golang.org/pkg/math/">math</a>是一个<a href="https://golangbot.com/go-packages/">包</a>，<a href="https://golang.org/pkg/math/#Min">Min</a>是那个包中的一个<a href="https://golangbot.com/functions/">函数</a>。现在不需要担心这个，我们将会在接下来的章节<a href="../%E3%80%90GolangBot%E3%80%917-%E5%8C%85/">包</a>和<a href="../%E3%80%90GolangBot%E3%80%916-%E5%87%BD%E6%95%B0/">函数</a>中详细介绍它们。我们现在只需要知道，<code>c</code>的值时在运行过程中计算出来的，并且它时<code>a</code>和<code>b</code>之中的最小值。上面的程序将会打印，</p><div class="code-wrapper"><pre><code class="hljs fallback">Minimum value is  145.8</code></pre></div><p>因为Go是强类型的，声明为一种类型的变量不能赋值给另外一种类型。下面的程序将会打印错误<code>cannot use &quot;Naveen&quot; (untyped string constant) as int value in assignment</code>，因为<code>age</code>声明为<code>int</code>类型，我们正尝试为它分配一个<code>string</code>值。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;age := <span class="hljs-number">29</span>      <span class="hljs-comment">// age is int</span>age = <span class="hljs-string">&quot;Naveen&quot;</span> <span class="hljs-comment">// error since we are trying to assign a string to a variable of type int</span>&#125;</code></pre></div><p><a href="https://go.dev/play/p/_L67J5Mxy8F">Run in playground</a></p><p><strong>下一篇教程 - <a href="../%E3%80%90GolangBot%E3%80%914-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">类型</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GolangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】2-Hello World</title>
    <link href="/%E3%80%90GolangBot%E3%80%912-Hello-World/"/>
    <url>/%E3%80%90GolangBot%E3%80%912-Hello-World/</url>
    
    <content type="html"><![CDATA[<p>这是我们<a href="../golangbot/">Golang系列教程</a>的第二篇。请阅读我们前一篇教程<a href="../%E3%80%90GolangBot%E3%80%911-%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%AE%89%E8%A3%85/">Golang安装和介绍</a>来了解什么是Golang，以及如何安装Golang。</p><h3 id="安装开发环境"><a href="#安装开发环境" class="headerlink" title="安装开发环境"></a>安装开发环境</h3><p>让我们在想要写Hello World程序的位置创建一个目录。打开终端运行如下命令。</p><div class="code-wrapper"><pre><code class="hljs fallback">mkdir ~/Documents/learngo/</code></pre></div><p>上面的命令将会在当前用户的文档目录下创建一个名为<code>learngo</code>的目录。你可以随意在希望存放代码的位置创建目录。</p><h3 id="创建一个Go-Module"><a href="#创建一个Go-Module" class="headerlink" title="创建一个Go Module"></a>创建一个Go Module</h3><p>下一步是在<code>~/Documents/learngo/</code>文件夹中创建一个名为<code>learngo</code>的go module。Go modules 用来追踪应用的依赖和版本。我们将会在我们学习<a href="../%E3%80%90GolangBot%E3%80%917-%E5%8C%85/">包</a>的时候详细讨论Go modules。</p><p>在<code>~/Documents/learngo/</code>目录中运行<code>go mod init learngo</code>。这将会创建一个名为<code>go.mod</code>的文件。运行<code>go mod init learngo</code>命令后，下面的内容将会被打印出来</p><p>Run <code>go mod init learngo</code> inside the <code>~/Documents/learngo/</code> directory. This will create a file named <code>go.mod</code>. The following will be printed after running the <code>go mod init learngo</code> command</p><div class="code-wrapper"><pre><code class="hljs v">go: creating <span class="hljs-keyword">new</span> go<span class="hljs-variable">.mod</span>: <span class="hljs-keyword">module</span> learngo</code></pre></div><p><code>go.mod</code>文件的内容如下。</p><div class="code-wrapper"><pre><code class="hljs v"><span class="hljs-keyword">module</span> learngogo <span class="hljs-number">1</span><span class="hljs-variable">.21</span><span class="hljs-variable">.0</span></code></pre></div><p>The first line <code>module learngo</code> specifies the module name. The next line <code>1.21.0</code> indicates that the files in this module use go version 1.21.0</p><p>第一行<code>module learngo</code>制定了module的名称。下一行<code>1.21.0</code>表明在这个module当中，使用的go版本是1.21.0。</p><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><p>用你最喜欢的文本编辑器在<code>learngo</code>目录下创建一个名为<code>main.go</code>的文件，其中包含以下内容。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;Hello World&quot;</span>)&#125;</code></pre></div><p>按照Go的管理，包含<code>main</code>函数的文件命名为<code>main.go</code>，但其他名称也同样适用。</p><h3 id="运行go程序"><a href="#运行go程序" class="headerlink" title="运行go程序"></a>运行go程序</h3><p>有几种运行Go程序的不同方式。让我们一个个地来看。</p><h4 id="1-go-install"><a href="#1-go-install" class="headerlink" title="1. go install"></a>1. go install</h4><p>第一种运行Go程序的方法是使用<code>go install</code>命令。让我们<code>cd</code>进我们刚刚创建的<code>learngo</code>目录。</p><div class="code-wrapper"><pre><code class="hljs fallback">cd ~/Documents/learngo/</code></pre></div><p>运行如下命令。</p><div class="code-wrapper"><pre><code class="hljs fallback">go install</code></pre></div><p>上面的命令将会变异程序并且安装(拷贝)二进制文件到<code>~/go/bin</code>路径。二进制文件的名称是go module的名称。在我们的示例中，它会被命名为<code>learngo</code>。</p><p>当你尝试安装程序的时候，你可能会碰到下面的错误。</p><div class="code-wrapper"><pre><code class="hljs fallback">go install: no install location for directory /home/naveen/Documents/learngo outside GOPATHFor more details see: &#x27;go help gopath&#x27;</code></pre></div><p>上面的错误通常的意思是指，<code>go install</code>找不到位置安装编译后的二进制文件。所以让我们继续，并且给他一个位置。这个位置是由<code>GOBIN</code>环境变量控制的。</p><div class="code-wrapper"><pre><code class="hljs fallback">export GOBIN=~/go/bin/</code></pre></div><p>上面的环境变量制定了<code>go install</code>应该拷贝并且编译二进制文件到<code>~go/bin</code>路径。这是对Go的二进制文件来说一个约定俗成的路径，但你也可以随心所欲的修改它到任意你想要的位置。现在试着重新运行<code>go install</code>，程序应该会正常编译并且运行了。</p><p>你可以在终端里面输入<code>ls -al ~/go/bin/learngo</code>，你会发现实际上<code>go install</code>已经把二进制文件放到了<code>~/go/bin</code>路径下。</p><p>现在，让我们来运行编译后的二进制文件。</p><div class="code-wrapper"><pre><code class="hljs fallback">~/go/bin/learngo</code></pre></div><p>上面的命令将会运行<code>learngo</code>二进制文件并且打印如下输出。</p><div class="code-wrapper"><pre><code class="hljs fallback">Hello World</code></pre></div><p>恭喜！你已经成功运行了你的第一个Go程序。</p><p>如果你不想每次运行程序的时候都输入完整的路径<code>~/go/bin/learngo</code>，你可以把<code>~/go/bin/</code>添加到你的PATH环境变量中。</p><div class="code-wrapper"><pre><code class="hljs fallback">export PATH=$PATH:~/go/bin</code></pre></div><p>现在，你只需要在终端输入<code>learngo</code>就可以运行你的程序了。</p><p>你也许想知道当<code>learngo</code>目录包含多个go文件而不只有一个<code>main.go</code>时会发生什么。在这种情况下<code>go install</code>会发生什么？请别着急，我们将会在<a href="../%E3%80%90GolangBot%E3%80%917-%E5%8C%85/">包和Go Modules</a>一节中讨论这些。</p><h4 id="2-go-build"><a href="#2-go-build" class="headerlink" title="2. go build"></a>2. go build</h4><p>运行程序的第二个选择是使用<code>go build</code>。<code>go build</code>和<code>go install</code>非常相似，除了它不会在<code>~/go/bin/</code>路径下安装(拷贝)二进制文件。相反，它会在安装<code>go build</code>的位置创建二进制文件。</p><p>在终端输入以下命令将当前目录更改为<code>learngo</code>。</p><div class="code-wrapper"><pre><code class="hljs fallback">cd ~/Documents/learngo/</code></pre></div><p>在那之后，输入下面的命令。</p><div class="code-wrapper"><pre><code class="hljs fallback">go build</code></pre></div><p>上方的命令会在当前目录创建一个名为<code>learngo</code>的二进制文件。运行<code>ls -al</code>会发现一个名为<code>learngo</code>的文件被创建了。</p><p>输入<code>./learngo</code>运行程序。这也会打印</p><div class="code-wrapper"><pre><code class="hljs fallback">Hello World</code></pre></div><p>我们用<code>go build</code>同样成功运行了我们的第一个Go程序:)</p><h4 id="3-go-run"><a href="#3-go-run" class="headerlink" title="3. go run"></a>3. go run</h4><p>第三种运行程序的方式是使用<code>go run</code>命令。</p><p>在终端中输入<code>cd ~/Documents/learngo/</code>命令来改变当前目录到<code>learngo</code>。</p><p>然后，输入如下的命令。</p><div class="code-wrapper"><pre><code class="hljs fallback">go run main.go</code></pre></div><p>执行上面的命令后，我们会看到输出</p><div class="code-wrapper"><pre><code class="hljs fallback">Hello World</code></pre></div><p><code>go run</code>与<code>go build/go install</code>命令的一个不同就在于，<code>go run</code>需要<code>.go</code>文件的名字作为一个参数。</p><p>在底层，<code>go run</code>和<code>go build</code>非常相似。但<code>go run</code>不在当前目录编译和安装程序，而是向一个临时目录编译文件，并在该目录运行文件。如果你有兴趣想知道<code>go run</code>把文件编译到了哪里，请在运行<code>go run</code>的时候加上<code>--work</code>参数。</p><div class="code-wrapper"><pre><code class="hljs fallback">go run --work main.go</code></pre></div><p>运行上面的命令，我这里输出</p><div class="code-wrapper"><pre><code class="hljs fallback">WORK=/tmp/go-build199689936Hello World</code></pre></div><p>关键字<code>WORK</code>的值制定了程序将会被编译到的临时位置。在我的示例中，程序已经被编译到了<code>/tmp/go-build199689936</code>。你的运行情况可能有所不同:)</p><h4 id="4-Go在线运行环境。"><a href="#4-Go在线运行环境。" class="headerlink" title="4. Go在线运行环境。"></a>4. Go在线运行环境。</h4><p>最后一种方式是使用Go在线运行环境。尽管有一些限制，但当我们想要运行简单的程序时，此方法将会派上用场，它使用浏览器运行，不需要在本地安装GO:)。我已经为Hello World 程序创建了一个在线环境。<a href="https://go.dev/play/p/oXGayDtoLPh">点击这里</a>在线运行程序。</p><p>你也可以使用Go在线运行环境来与其他人分享你的源码。</p><p>现在我们知道了运行程序的四种不同的方式，你可能纠结于使用哪一种。答案是，视情况而定。当我想要做一个快速逻辑检查或一个标准库函数是否生效时，我一般会选择在线环境。在大多数情况下，我更喜欢<code>go install</code>，因为它给我一种选择，让我可以在终端里可以从任意目录运行程序，因为它将所有的程序编译到靠准<code>~/go/bin</code>路径。</p><h4 id="对Hello-World程序的简短解释"><a href="#对Hello-World程序的简短解释" class="headerlink" title="对Hello World程序的简短解释"></a>对Hello World程序的简短解释</h4><p>这里是我们刚刚写的Hello World程序。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123; fmt.Println(<span class="hljs-string">&quot;Hello World&quot;</span>) &#125;</code></pre></div><p>我们会简要讨论程序的每一行的作用。我们将在接下来的每一篇教程中深入探讨程序的各个部分。</p><p><strong>package main - 每一个go文件都必须从<code>package name</code>语句开始</strong>。包用于提供代码的分隔和可重用性。这里用到了包名<code>main</code>。<code>main</code>函数应该永远处于main包中。</p><p><strong>import “fmt”</strong> - import语句用来引用其他的包。在我们的示例中，<code>fmt</code>包被引用并且它用于在main函数中向标准输出打印文本。</p><p><strong>fmt.Println(“Hello World”)</strong> - <code>fmt</code>包的 <code>Println</code> 函数用于向标准输出打印文本。<code>package.Function()</code>是调用包内函数的格式。</p><p>代码可以在<a href="https://github.com/golangbot/hello">GitHub</a>上下载。</p><p>你现在可以去<a href="">【GolangBot】3-变量</a>来学习Go中的变量。</p><p><strong>下一篇教程 - <a href="../%E3%80%90GolangBot%E3%80%913-%E5%8F%98%E9%87%8F/">变量</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GolangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GolangBot】1-介绍和安装</title>
    <link href="/%E3%80%90GolangBot%E3%80%911-%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%AE%89%E8%A3%85/"/>
    <url>/%E3%80%90GolangBot%E3%80%911-%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p>发现了一个不错的英文Golang初级教程，内容比较容易理解，开个新坑，翻译一下。一来能够巩固一下Golang基础，二来可以提高一下英文水平，如果纰漏还请指出。那我们开始吧！</p><blockquote><p><a href="https://golangbot.com/learn-golang-series/">原文地址</a></p></blockquote><p>这是我们<a href="../golangbot/">Golang系列教程</a>的第一篇。这篇文章提供了对于Go的介绍，也讨论了在其他众多编程语言中，选择Go的优点。我们也会学习如何在MacOS、Windows和Linux上安装MacOS。</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Go，也被称为Golang，是由Google开发的开源、编译型、静态类型编程语言。Go创立背后的关键人物是<a href="https://zh.wikipedia.org/wiki/Rob_Pike">Rob Pike</a>、<a href="https://zh.wikipedia.org/wiki/Ken_Thompson">Ken Thompson</a>和Robert Griesemer。Go于2009年11月公开发布。</p><p>Go是一种语法简单的通用语言，并且有强大的标准库支持。Go的主要优势之一是创建高度可用且扩展的Web应用。Go也可以用来创建命令行应用、桌面应用，甚至是移动应用。</p><h3 id="Go的优势"><a href="#Go的优势" class="headerlink" title="Go的优势"></a>Go的优势</h3><p>既然有Python、Ruby、NodeJS等大量其他语言可以完成相同的工作，为什么还要选择Go来作为你的服务端编程语言呢？</p><p>以下是我在选择Go时发现的一些优点。</p><h4 id="简单的语法"><a href="#简单的语法" class="headerlink" title="简单的语法"></a>简单的语法</h4><p>Go的语法简洁明了，没有多余的功能。这使得编写可读性和可维护性良好的代码变得容易。</p><h4 id="容易编写并发程序"><a href="#容易编写并发程序" class="headerlink" title="容易编写并发程序"></a>容易编写并发程序</h4><p><a href="../%E3%80%90GolangBot%E3%80%9120-%E5%B9%B6%E5%8F%91%E4%BB%8B%E7%BB%8D/">并发性</a>是Go语言的固有部分。因此，对于Go来说，编写多线程程序是小菜一碟。这是通过<a href="../%E3%80%90GolangBot%E3%80%9121-Goroutines/">Goroutines</a>和<a href="../%E3%80%90GolangBot%E3%80%9122-Channels/">Channels</a>实现的，我们将在接下来的教程讨论他们。</p><h4 id="编译型语言"><a href="#编译型语言" class="headerlink" title="编译型语言"></a>编译型语言</h4><p>Go是一种编译型语言。源代码被编译成原生二进制文件。这种特性是诸如nodejs所使用的Javascript这类解释型语言所没有的。</p><h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><p>Go编译器支持静态链接。整个Go工程都可以静态链接刀一个非常大的二进制文件中，并且可以很容易地部署在云服务器上，而且不需要为各种依赖所困扰。</p><h4 id="Go工具链"><a href="#Go工具链" class="headerlink" title="Go工具链"></a>Go工具链</h4><p>Go的工具链特别值得提一下。Go附送了一套强大的工具，可以帮助开发者编写更好的代码。一些常用的工具有：</p><ul><li>gofmt - <a href="https://pkg.go.dev/cmd/gofmt">gofmt</a>用于自动格式化Go的源代码。他使用制表符进行锁紧，使用空格进行对齐。</li><li>vet - <a href="https://pkg.go.dev/cmd/vet">vet</a>分析go的源代码，并且报告可疑的代码。vet报告的不是真正的问题，而是编译器不能捕获的错误。比如使用<a href="https://pkg.go.dev/fmt#Printf">Printf</a>时使用了错误的格式指定符。</li><li>staticcheck - <a href="https://staticcheck.dev/">staticcheck</a>用来强制执行代码中的样式问题。</li></ul><h4 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h4><p>Go使用垃圾收集机制，因此内存管理基本是自动完成的，开发者不需要担心内存管理。这也有助于轻松编写并发程序。</p><h4 id="简单的语言规范"><a href="#简单的语言规范" class="headerlink" title="简单的语言规范"></a>简单的语言规范</h4><p>语言规范十分简单。<a href="go.dev/ref/spec">整个规范</a>都有详细的记录，你甚至可以用它来编写自己的编译器:)。</p><h4 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h4><p>最后，同样重要的是，Go是一个开雨啊项目。你可以参与<a href="https://go.dev/doc/contribute">Go项目</a>并为其作出贡献。</p><h3 id="使用Go构建的热门产品"><a href="#使用Go构建的热门产品" class="headerlink" title="使用Go构建的热门产品"></a>使用Go构建的热门产品</h3><p>下面是一些使用Go构建的热门产品。</p><ul><li>谷歌使用Go开发了Kubernetes。</li><li>Docker，世界闻名的容器化平台是用Go开发的。</li><li>Dropbox一讲起性能关键组件从Python移植到了Go。</li><li>Infoblox’s 的下一代网络产品时使用Go开发的。</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Go可以安装在所有的三种平台上：Mac、Windows和Linux。你可以从 <a href="https://go.dev/dl/">https://go.dev/dl/</a> 下载对应平台的二进制文件。</p><h4 id="Mac-OS"><a href="#Mac-OS" class="headerlink" title="Mac OS"></a>Mac OS</h4><p>从 <a href="https://go.dev/dl/">https://go.dev/dl/</a> 下载Mac OS安装器。双击开始安装。根据提示操作，Golang将会安装在<code>/usr/local/go</code>并且会把 <code>/usr/local/go/bin</code>这个文件夹添加到你的PATH环境变量中。</p><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>从 <a href="https://go.dev/dl/">https://go.dev/dl/</a> 下载MSI安装器。双击开始安装，并根据提示进行操作。这将会把Go安装在<code>c:\Go</code>，并且会把目录 <code>c:\Go\bin</code>添加到path环境变量。</p><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>从 <a href="https://go.dev/dl/">https://go.dev/dl/</a> 下载tar文件并且解压至<code>/usr/local</code>。添加<code>/usr/local/go/bin</code>到PATH环境变量。这将在Linux中安装Go。</p><h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><p>To verify that Go installed successfully, type the command <code>go version</code> in the terminal and it will output the installed Go version. Here is the output in my terminal.</p><p>要验证Go是否安装成功，在终端输入<code>go version</code>命令，它会输出安装好的Go版本。这是我的终端输出的内容。</p><div class="code-wrapper"><pre><code class="hljs fallback">$ go versiongo version go1.19.2 linux/amd64</code></pre></div><p><code>1.19.2</code>是在写这篇教程时最新的版本。这证实Go确实安装成功了。在下一篇教程中，我们将会用Go写我们的第一个<a href="../%E3%80%90GolangBot%E3%80%912-Hello-World/">Hello World程序</a>。</p><p><strong>下一篇教程 - <a href="../%E3%80%90GolangBot%E3%80%912-Hello-World/">Hello World</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
      <category>GolangBot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GitHub + PicGo 搭建个人图床</title>
    <link href="/GitHub-PicGo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/"/>
    <url>/GitHub-PicGo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="GitHub-PicGo-搭建个人图床"><a href="#GitHub-PicGo-搭建个人图床" class="headerlink" title="GitHub + PicGo 搭建个人图床"></a>GitHub + PicGo 搭建个人图床</h1><p>最近开始了写博客计划，一般写Markdown的时候一般都喜欢用Typora，但是如果不用图床的话，很多图片上传后是无法显示的，因此用GitHub和PicGo搞一个图床，还方便一点。步骤也不是很麻烦，五分钟之内就能搞好。</p><h2 id="1-新建GitHub仓库"><a href="#1-新建GitHub仓库" class="headerlink" title="1.新建GitHub仓库"></a>1.新建GitHub仓库</h2><p>新建一个GitHub仓库，名字无所谓，自己记住就好。比如我这里创建一个名为<code>ImageRepo</code>的仓库。</p><h2 id="2-创建Token"><a href="#2-创建Token" class="headerlink" title="2.创建Token"></a>2.创建Token</h2><p>点击GitHub头像，选择<code>Settings-&gt;Developer settings-&gt;Personal access tokens-&gt;Tokens(classic)-&gt;Generate new token-&gt;classic</code>。</p><p><a href="https://cdn.jsdelivr.net/gh/ZoeKyHein/ImageRepo/image-20241216111650090.png"><img src="https://cdn.jsdelivr.net/gh/ZoeKyHein/ImageRepo/image-20241216111650090.png" alt="image-20241216111650090"></a></p><p>将这个token复制好，一会会用到。</p><h2 id="3-下载PicGo-APP"><a href="#3-下载PicGo-APP" class="headerlink" title="3.下载PicGo APP"></a>3.下载PicGo APP</h2><p><a href="https://molunerfinn.com/PicGo/">PicGo官网</a></p><p>我这里用的是macOS，下的就是dmg，根据自己的操作系统下载对应版本即可。</p><h2 id="4-配置PicGo"><a href="#4-配置PicGo" class="headerlink" title="4.配置PicGo"></a>4.配置PicGo</h2><p>打开刚才下好的APP，选择<code>图床设置-&gt;GitHub</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/ZoeKyHein/ImageRepo/image-20241216150755514.png" alt="image-20241216150755514"></p><p>如果只用这一个图床，可以直接修改默认配置：</p><ul><li>图床配置名：<code>任意</code></li><li>设定仓库名：<code>username/repoName</code>(根据自己的仓库设置：username是你的GitHub名字，repoName是仓库名字)</li><li>设定分支名：<code>main</code>(如果有其他分支，根据需要设置即可)</li><li>设定Token：刚才从GitHub复制的token</li><li>设定存储路径：根据自己需要设置</li><li>设定自定义域名：<code>https://cdn.jsdelivr.net/gh/username/repoName</code>(username和repoName同上)</li></ul><p>点击保存，这样就设置完成了。可以在上传区上传一张照片测试一下，如果在相册中出现，说明已经成功了。</p><h2 id="5-配置Typora"><a href="#5-配置Typora" class="headerlink" title="5.配置Typora"></a>5.配置Typora</h2><p>打开Typora设置，按照图上进行修改：插入图片时选择上传图片；上传服务选择PicGo APP。Windows可能还需要选择一下APP的路径，大同小异。<img src="https://cdn.jsdelivr.net/gh/ZoeKyHein/ImageRepo/image-20241216151227572.png" alt="image-20241216151227572"></p><hr><p>至此配置就全部完成了，我们就可以用Typora愉快的插入图片，而不用担心图片的现实问题了。但在不使用特殊手段的情况下，GitHub图床可能对墙内用户不那么友好，请自行取舍。</p><blockquote><p>参考：</p><p><a href="https://www.bilibili.com/opus/916418138329841670">如何使用GitHub搭建个人图床，配合typora使用</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>胡乱捣鼓</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GitHub</tag>
      
      <tag>PicGo</tag>
      
      <tag>图床</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo + GitHub Actions + Page部署自动化博客</title>
    <link href="/Hexo-GitHub-Actions-Page%E9%83%A8%E7%BD%B2%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2/"/>
    <url>/Hexo-GitHub-Actions-Page%E9%83%A8%E7%BD%B2%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo-GitHub-Actions-Page部署自动化博客"><a href="#Hexo-GitHub-Actions-Page部署自动化博客" class="headerlink" title="Hexo + GitHub Actions + Page部署自动化博客"></a>Hexo + GitHub Actions + Page部署自动化博客</h1><p>最近想部署一个博客，网上看了很多相关的教程，但大部分都要么版本不一样了，要么缺少关键步骤。不如自己总结一下，来一个自己认为比较全面的，希望能给后面有相关需求的朋友一点帮助。</p><h2 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1.安装Git"></a>1.安装Git</h2><ul><li>Windows：下载并安装 <a href="https://git-scm.com/download/win">git</a>。</li><li>Mac：使用 <a href="http://mxcl.github.com/homebrew/">Homebrew</a>, <a href="http://www.macports.org/">MacPorts</a> 或者下载 <a href="http://sourceforge.net/projects/git-osx-installer/">安装程序</a>。</li><li>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code></li><li>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code></li></ul><blockquote><p>Mac 用户</p><p>如果在编译时可能会遇到问题。 请先到 App Store 安装 Xcode。 Xcode 完成后，启动并进入 <strong>Preferences -&gt; Download -&gt; Command Line Tools -&gt; Install</strong> 安装命令行工具。</p></blockquote><h2 id="2-安装NodeJs"><a href="#2-安装NodeJs" class="headerlink" title="2.安装NodeJs"></a>2.安装NodeJs</h2><p>Node.js 为大多数平台提供了官方的 <a href="https://nodejs.org/zh-cn/download/">安装程序</a>。</p><p>其它的安装方法：</p><ul><li>Windows：通过 <a href="https://github.com/jasongin/nvs/">nvs</a>（推荐）或者 <a href="https://github.com/nvm-sh/nvm">nvm</a> 安装。</li><li>Mac：使用 <a href="https://brew.sh/">Homebrew</a> 或 <a href="http://www.macports.org/">MacPorts</a> 安装。</li><li>Linux（DEB&#x2F;RPM-based）：从 <a href="https://github.com/nodesource/distributions">NodeSource</a> 安装。</li><li>其它：使用相应的软件包管理器进行安装。 可以参考由 Node.js 提供的 <a href="https://nodejs.org/en/download/package-manager/">指导</a>。</li></ul><p>对于 Mac 和 Linux 同样建议使用 nvs 或者 nvm，以避免可能会出现的权限问题。</p><blockquote><p>Windows</p><p>使用 Node.js 官方安装程序时，请确保勾选 <strong>Add to PATH</strong> 选项（默认已勾选）<br>Mac &#x2F; Linux</p><p>如果在尝试安装 Hexo 的过程中出现 <code>EACCES</code> 权限错误，请遵循 <a href="https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally">由 npmjs 发布的指导</a> 修复该问题。<br>Linux</p><p>如果您使用 Snap 来安装 Node.js，在 <a href="https://hexo.io/zh-cn/docs/commands#init">初始化</a> 博客时您可能需要手动在目标文件夹中执行 <code>npm install</code>。</p></blockquote><h2 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3.安装Hexo"></a>3.安装Hexo</h2><p>Hexo可以使用npm进行安装,但在使用前,最好配置一下镜像.</p><div class="code-wrapper"><pre><code class="hljs sh">npm config <span class="hljs-built_in">set</span> registry https://registry.npmmirror.com</code></pre></div><p>配置完镜像后,即可使用npm进行安装.</p><div class="code-wrapper"><pre><code class="hljs sh">npm install -g hexo-cli</code></pre></div><h2 id="4-使用Hexo建站"><a href="#4-使用Hexo建站" class="headerlink" title="4.使用Hexo建站"></a>4.使用Hexo建站</h2><p>为了方便和上手，这里使用Vscode+git操作。</p><p>安装完Hexo之后,就可以在本地选择一个文件夹,开始建站了。比如我要在本地创建一个名为Hexo的文件夹。</p><p>使用Vscode打开这个文件夹，新建一个终端，运行如下命令</p><div class="code-wrapper"><pre><code class="hljs shell">hexo initnpm install</code></pre></div><p>如果<code>npm install</code>失败，可以尝试删除文件夹中的<code>node_modules</code>文件夹重试。</p><p>等到npm命令执行完毕，Hexo目录中会出现如下结构。</p><div class="code-wrapper"><pre><code class="hljs stylus">.├── _config<span class="hljs-selector-class">.landscape</span><span class="hljs-selector-class">.yml</span>├── _config<span class="hljs-selector-class">.yml</span>├── node_modules├── package-lock<span class="hljs-selector-class">.json</span>├── package<span class="hljs-selector-class">.json</span>├── pnpm-lock<span class="hljs-selector-class">.yaml</span>├── scaffolds├── <span class="hljs-selector-tag">source</span>└── themes</code></pre></div><p>初始化完成后，将目录中的内容推送至仓库的main分支，这里我选择使用Vscode+git更方便的进行创建并推送。</p><p><img src="https://cdn.jsdelivr.net/gh/ZoeKyHein/ImageRepo/image-20241216111417720.png" alt="image-20241216111417720"></p><h2 id="5-创建Token。"><a href="#5-创建Token。" class="headerlink" title="5.创建Token。"></a>5.创建Token。</h2><p>点击GitHub头像，选择<code>Settings-&gt;Developer settings-&gt;Personal access tokens-&gt;Tokens(classic)-&gt;Generate new token-&gt;classic</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/ZoeKyHein/ImageRepo/image-20241216111650090.png" alt="image-20241216111650090"></p><p>勾选<code>repo</code>和<code>workflow</code>，Note填入<code>GH_TOKEN</code>(其实都可以，与后面对应即可，如果不熟悉就跟着来吧)。有效期根据自己的需要选择。设置完成后点击生成，然后复制生成的token，注意保存，token只能查看一次，如果忘记了后面需要重新生成。</p><p><img src="https://cdn.jsdelivr.net/gh/ZoeKyHein/ImageRepo/image-20241216111819418.png" alt="image-20241216111819418"></p><h2 id="6-将创建的token放入仓库内。"><a href="#6-将创建的token放入仓库内。" class="headerlink" title="6.将创建的token放入仓库内。"></a>6.将创建的token放入仓库内。</h2><p>进入刚才推送出来的仓库，选择<code>Settings-&gt;Secrets and Variables-&gt;Actions-&gt;New repository secret</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/ZoeKyHein/ImageRepo/image-20241216112206006.png" alt="image-20241216112206006"></p><p>将刚才我们复制的token填入，名称填写<code>GH_TOKEN</code>。</p><h2 id="7-配置仓库地址。"><a href="#7-配置仓库地址。" class="headerlink" title="7.配置仓库地址。"></a>7.配置仓库地址。</h2><p>回到Vscode，找到我们新建文件夹中的<code>_config.yml</code>文件，拉到最下方，将配置进行如下修改。</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/ZoeKyHein/Hexo.git</span>  <span class="hljs-attr">branch:</span> <span class="hljs-string">gh-pages</span></code></pre></div><p>仓库名称和地址根据自己的，灵活修改。</p><h2 id="8-配置GitHub-Actions工作流"><a href="#8-配置GitHub-Actions工作流" class="headerlink" title="8.配置GitHub Actions工作流"></a>8.配置GitHub Actions工作流</h2><p>在<code>.github</code>目录下新建一个名为<code>workflows</code>的文件夹(注意是有s的)。在其中新建一个名为<code>deploy.yml</code>的文件，复制以下内容。</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">Hexo</span> <span class="hljs-string">to</span> <span class="hljs-string">GitHub</span> <span class="hljs-string">Pages</span><span class="hljs-attr">on:</span>  <span class="hljs-attr">push:</span>    <span class="hljs-attr">branches:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">main</span> <span class="hljs-comment"># default branch</span><span class="hljs-attr">jobs:</span>  <span class="hljs-attr">build:</span>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span>    <span class="hljs-attr">steps:</span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span> <span class="hljs-string">repository</span>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span>        <span class="hljs-attr">with:</span>          <span class="hljs-comment"># If your repository depends on submodule, please see: https://github.com/actions/checkout</span>          <span class="hljs-attr">submodules:</span> <span class="hljs-literal">false</span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Setup</span> <span class="hljs-string">Node.js</span>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v2</span>        <span class="hljs-attr">with:</span>          <span class="hljs-comment"># Examples: 20, 18.19, &gt;=16.20.2, lts/Iron, lts/Hydrogen, *, latest, current, node</span>          <span class="hljs-comment"># Ref: https://github.com/actions/setup-node#supported-version-syntax</span>          <span class="hljs-attr">node-version:</span> <span class="hljs-string">&quot;22&quot;</span>           <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">Dependencies</span>        <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">Hexo</span> <span class="hljs-string">Git</span> <span class="hljs-string">Deployer</span>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><span class="hljs-string">          npm install hexo-deployer-git --save</span><span class="hljs-string">          npm install hexo-cli -g</span><span class="hljs-string"></span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Clean</span> <span class="hljs-string">and</span> <span class="hljs-string">Generate</span> <span class="hljs-string">Static</span> <span class="hljs-string">Files</span>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><span class="hljs-string">          hexo clean</span><span class="hljs-string">          hexo generate</span><span class="hljs-string"></span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Configure</span> <span class="hljs-string">Git</span>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><span class="hljs-string">          git config --global user.name &#x27;github-actions[bot]&#x27;</span><span class="hljs-string">          git config --global user.email &#x27;github-actions[bot]@users.noreply.github.com&#x27;</span><span class="hljs-string"></span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">to</span> <span class="hljs-string">GitHub</span> <span class="hljs-string">Pages</span>        <span class="hljs-attr">env:</span>          <span class="hljs-attr">GH_TOKEN:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.GH_TOKEN</span> <span class="hljs-string">&#125;&#125;</span>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><span class="hljs-string">          cd public/</span><span class="hljs-string">          git init</span><span class="hljs-string">          git add -A</span><span class="hljs-string">          git commit -m &quot;Create by workflows&quot;</span><span class="hljs-string">          git remote add origin https://$&#123;&#123; secrets.GH_TOKEN &#125;&#125;@github.com/ZoeKyHein/Hexo.git</span><span class="hljs-string">          git push origin HEAD:gh-pages -f</span></code></pre></div><p>其中有两个位置需要修改：</p><ul><li>一是node版本需要与本地对应。在本地运行<code>node -v</code>得到版本，替换上面的<code>22</code>。</li><li>二是最下方仓库地址修改为自己的仓库路径。</li></ul><p>其实Actions工作流的本质就是，当你提交git时，自动帮你把markdown转静态网页，发布等工作给做了。相当于我们在后续维护博客的过程中，只需要使用git提交即可，后续操作都会自动帮我们完成。</p><p>修改完成后，将刚才的所有修改全部推送上去，查看GitHub仓库的<code>Action</code>是否有工作流工作。</p><p><img src="https://cdn.jsdelivr.net/gh/ZoeKyHein/ImageRepo/image-20241216113145810.png" alt="image-20241216113145810"></p><p>正常情况下，该工作流前面会有一个✅标志，表示没有错误发生，正常进行。</p><p>回到<code>Code</code>，查看是否出现了<code>gh-pages</code>分支，并检查<code>gh-pages</code>分支下的<code>index.html</code>文件是否为空，如果为空，需要根据工作流日志查阅一下问题。</p><h2 id="9-配置GitHub-Pages"><a href="#9-配置GitHub-Pages" class="headerlink" title="9.配置GitHub Pages"></a>9.配置GitHub Pages</h2><p>进入到仓库，选择<code>Settings-&gt;Pages</code>,确保分支时<code>gh-pages</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/ZoeKyHein/ImageRepo/image-20241216113459989.png" alt="image-20241216113459989"></p><p>关于网站的访问地址，可以在图中上方红框框起来的区域查看。规则如下：</p><ul><li>如果想要通过<code>https://username.github.io</code>直接访问，需要把仓库名称修改为<code>username.github.io</code>，且这样不会出现外部文件引用出错的问题，<strong>推荐</strong>。</li><li>如果想要通过<code>https://username.github.io/xxx</code>访问，仓库名字设置为<code>xxx</code>，但这样需要多配置一步，来解决外部文件的引用错误。</li></ul><p>访问网站，如果你用的是第一种，那么应该可以看到Hexo的默认页面。(这里图片是使用了主题，所以看起来可能与你的不太一样，问题不大，意思到了就好)</p><p><img src="https://cdn.jsdelivr.net/gh/ZoeKyHein/ImageRepo/image-20241216114436636.png" alt="image-20241216114436636"></p><p>如果是第二种，需要回到配置文件<code>_config.yml</code>，解决一下资源请求的问题。</p><p><img src="https://cdn.jsdelivr.net/gh/ZoeKyHein/ImageRepo/image-20241216114239466.png" alt="image-20241216114239466"></p><p>将<code>url</code>字段修改为仓库的地址，<code>root</code>字段修改为仓库名称。可以顺手将<code>post_asset_folder</code>属性修改为<code>true</code>来解决图片不显示的问题。</p><h2 id="10-修改主题"><a href="#10-修改主题" class="headerlink" title="10.修改主题"></a>10.修改主题</h2><p>至此，默认的Hexo的配置已经完成了。下面来说一下如何更改主题，我这里用的是<a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid</a>，以这个为例。每个主题一般都会提供安装文档。按照安装文档一步步进行即可。</p><hr><p>至此，就已经完成了全部配置，可以开始自己的博客写作之路了。</p><blockquote><p>参考资料：</p><p><a href="https://hexo.io/zh-cn/docs/">Hexo官方文档</a></p><p><a href="https://www.bilibili.com/video/BV1xTgTemEDU/?spm_id_from=333.337.search-card.all.click&vd_source=54e860cc95e5fe130d79a442d282774f">9分钟零成本搭建自动化部署个人博客(Hexo + Github Action + Page)</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>胡乱捣鼓</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
